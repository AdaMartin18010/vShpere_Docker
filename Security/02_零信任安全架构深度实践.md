# 02_é›¶ä¿¡ä»»å®‰å…¨æ¶æ„æ·±åº¦å®è·µ

## æ–‡æ¡£å…ƒä¿¡æ¯

| å±æ€§ | å€¼ |
|------|-----|
| **æ–‡æ¡£ç‰ˆæœ¬** | v2.0 (2025æ”¹è¿›ç‰ˆ) |
| **æ›´æ–°æ—¥æœŸ** | 2025-10-21 |
| **æŠ€æœ¯åŸºå‡†** | NIST SP 800-207, BeyondCorp, Zero Trust Network Access (ZTNA) |
| **å®‰å…¨æ ‡å‡†** | NIST Zero Trust Architecture, Google BeyondCorp |
| **æ ‡å‡†å¯¹é½** | é›¶ä¿¡ä»»2025æœ€ä½³å®è·µ, mTLS, Identity-based Access |
| **çŠ¶æ€** | ç”Ÿäº§å°±ç»ª |

> **ç‰ˆæœ¬é”šç‚¹**: æœ¬æ–‡æ¡£ä¸¥æ ¼å¯¹é½NIST SP 800-207é›¶ä¿¡ä»»æ¶æ„æ ‡å‡†ä¸2025å¹´å®è·µã€‚

---

## ç›®å½•

- [02_é›¶ä¿¡ä»»å®‰å…¨æ¶æ„æ·±åº¦å®è·µ](#)
  - [æ–‡æ¡£å…ƒä¿¡æ¯](#æ–‡æ¡£å…ƒä¿¡æ¯)
  - [ç›®å½•](#ç›®å½•)

---

## é›¶ä¿¡ä»»æ¶æ„æ¦‚è¿°

### ä»€ä¹ˆæ˜¯é›¶ä¿¡ä»»

```yaml
å®šä¹‰:
  - "Never Trust, Always Verify"
  - å‡è®¾ç½‘ç»œå†…å¤–éƒ½ä¸å¯ä¿¡
  - åŸºäºèº«ä»½çš„è®¿é—®æ§åˆ¶
  - æŒç»­éªŒè¯ä¸æœ€å°æƒé™

ä¼ ç»Ÿå®‰å…¨ vs é›¶ä¿¡ä»»:
  ä¼ ç»Ÿ:
    - è¾¹ç•Œé˜²æŠ¤ (åŸå ¡ä¸æŠ¤åŸæ²³)
    - å†…ç½‘å¯ä¿¡
    - é™æ€ç­–ç•¥
    - ç½‘ç»œä½ç½®å†³å®šè®¿é—®æƒé™
  
  é›¶ä¿¡ä»»:
    - æ— è¾¹ç•Œ (æ¶ˆé™¤éšå¼ä¿¡ä»»)
    - å†…ç½‘ä¸å¯ä¿¡
    - åŠ¨æ€ç­–ç•¥
    - èº«ä»½ä¸ä¸Šä¸‹æ–‡å†³å®šè®¿é—®æƒé™
```

### é›¶ä¿¡ä»»æ¶æ„æ¨¡å‹

```yaml
NIST SP 800-207 é›¶ä¿¡ä»»æ¶æ„:
  
  æ ¸å¿ƒç»„ä»¶:
    1. ç­–ç•¥å¼•æ“ (Policy Engine):
       - è¯„ä¼°è®¿é—®è¯·æ±‚
       - è€ƒè™‘å¤šå› ç´  (èº«ä»½/è®¾å¤‡/ä½ç½®/è¡Œä¸º)
       - å®æ—¶å†³ç­–
    
    2. ç­–ç•¥ç®¡ç†å™¨ (Policy Administrator):
       - å»ºç«‹/å–æ¶ˆä¼šè¯
       - é…ç½®PEP (Policy Enforcement Point)
       - åŠ¨æ€ç­–ç•¥åº”ç”¨
    
    3. ç­–ç•¥æ‰§è¡Œç‚¹ (PEP):
       - å®æ–½è®¿é—®æ§åˆ¶
       - ç›‘æ§æµé‡
       - ä¸ŠæŠ¥é¥æµ‹æ•°æ®
  
  æ•°æ®æº:
    - CDM (Continuous Diagnostics & Mitigation): è®¾å¤‡çŠ¶æ€
    - èº«ä»½ç®¡ç†ç³»ç»Ÿ: ç”¨æˆ·èº«ä»½
    - å¨èƒæƒ…æŠ¥: å®‰å…¨æ€åŠ¿
    - SIEM: å®‰å…¨äº‹ä»¶
    - è¡Œä¸ºåˆ†æ: å¼‚å¸¸æ£€æµ‹
```

### BeyondCorpæ¨¡å‹

```yaml
Google BeyondCorp:
  æ ¸å¿ƒç†å¿µ:
    - è®¿é—®å–å†³äºè®¾å¤‡å’Œç”¨æˆ·
    - ä¸ä¾èµ–ç½‘ç»œä½ç½®
    - æ‰€æœ‰æœåŠ¡æš´éœ²äºäº’è”ç½‘
    - åŠ¨æ€è®¿é—®æ§åˆ¶
  
  å…³é”®æŠ€æœ¯:
    - è®¾å¤‡æ¸…å•ä¸çŠ¶æ€è¯„ä¼°
    - ç”¨æˆ·ä¸è®¾å¤‡è®¤è¯
    - è®¿é—®ä»£ç† (Access Proxy)
    - åŠ¨æ€è®¿é—®æ§åˆ¶å¼•æ“
    - æŒç»­ç›‘æ§ä¸æ—¥å¿—
  
  éƒ¨ç½²æ¨¡å¼:
    [ç”¨æˆ·è®¾å¤‡] 
       â†“ è®¤è¯
    [Access Proxy] â† [è®¿é—®æ§åˆ¶å¼•æ“]
       â†“ æˆæƒ              â†‘
    [åº”ç”¨/æœåŠ¡] â†’ [ç›‘æ§/æ—¥å¿—]
```

---

## æ ¸å¿ƒåŸåˆ™ä¸æ¨¡å‹

### é›¶ä¿¡ä»»ä¸ƒåŸåˆ™

```yaml
1. éªŒè¯æ‰€æœ‰èµ„æºè®¿é—®:
   - ç”¨æˆ·èº«ä»½éªŒè¯
   - è®¾å¤‡å¥åº·æ£€æŸ¥
   - åº”ç”¨æˆæƒ
   - æ•°æ®æ•æ„Ÿåº¦è¯„ä¼°

2. æœ€å°æƒé™è®¿é—®:
   - Just-In-Time (JIT) è®¿é—®
   - Just-Enough-Access (JEA)
   - åŸºäºæ—¶é—´çš„æƒé™
   - åŠ¨æ€æƒé™æå‡

3. æ£€æŸ¥æ‰€æœ‰æµé‡:
   - åŠ å¯†æ‰€æœ‰é€šä¿¡
   - mTLSåŒå‘è®¤è¯
   - æµé‡è§£å¯†æ£€æŸ¥ (å¯é€‰)
   - æ·±åº¦åŒ…æ£€æµ‹

4. å¾®åˆ†æ®µç½‘ç»œ:
   - å·¥ä½œè´Ÿè½½çº§éš”ç¦»
   - åº”ç”¨çº§ç­–ç•¥
   - åŠ¨æ€ç­–ç•¥è°ƒæ•´
   - é›¶ä¿¡ä»»ç½‘ç»œ (ZTN)

5. æŒç»­ç›‘æ§:
   - å®æ—¶è¡Œä¸ºåˆ†æ
   - å¼‚å¸¸æ£€æµ‹
   - å¨èƒæƒ…æŠ¥é›†æˆ
   - å®‰å…¨æ€åŠ¿æ„ŸçŸ¥

6. è‡ªåŠ¨åŒ–å“åº”:
   - è‡ªåŠ¨å¨èƒå“åº”
   - ç­–ç•¥è‡ªåŠ¨è°ƒæ•´
   - è®¿é—®è‡ªåŠ¨æ’¤é”€
   - äº‹ä»¶è‡ªåŠ¨ä¸ŠæŠ¥

7. å‡è®¾å¤±é™·:
   - å†…éƒ¨å¨èƒé˜²æŠ¤
   - æ¨ªå‘ç§»åŠ¨é˜»æ­¢
   - æ•°æ®æ³„éœ²é˜²æŠ¤
   - å¿«é€Ÿéš”ç¦»èƒ½åŠ›
```

### é›¶ä¿¡ä»»æˆç†Ÿåº¦æ¨¡å‹

```yaml
Level 0 - ä¼ ç»Ÿå®‰å…¨:
  - VPN/é˜²ç«å¢™
  - é™æ€ç­–ç•¥
  - ç½‘ç»œä½ç½®ä¿¡ä»»

Level 1 - åˆçº§é›¶ä¿¡ä»»:
  - MFAå¤šå› ç´ è®¤è¯
  - åŸºç¡€è®¾å¤‡è¯†åˆ«
  - ç®€å•å¾®åˆ†æ®µ
  - åˆæ­¥æ—¥å¿—

Level 2 - ä¸­çº§é›¶ä¿¡ä»»:
  - åŠ¨æ€è®¿é—®æ§åˆ¶
  - è®¾å¤‡çŠ¶æ€è¯„ä¼°
  - åº”ç”¨çº§å¾®åˆ†æ®µ
  - è¡Œä¸ºåˆ†æ

Level 3 - é«˜çº§é›¶ä¿¡ä»»:
  - è‡ªé€‚åº”è®¿é—®æ§åˆ¶
  - æŒç»­ä¿¡ä»»è¯„ä¼°
  - è‡ªåŠ¨åŒ–å“åº”
  - å®Œæ•´å¯è§æ€§

Level 4 - æœ€ä¼˜é›¶ä¿¡ä»»:
  - AIé©±åŠ¨ç­–ç•¥
  - é¢„æµ‹æ€§å®‰å…¨
  - è‡ªä¸»å“åº”
  - ä¸šåŠ¡é›†æˆ
```

---

## èº«ä»½ä¸è®¿é—®ç®¡ç†

### SPIFFE/SPIREæ·±åº¦å®è·µ

#### SPIFFE IDç»“æ„

```yaml
SPIFFE IDæ ¼å¼:
  spiffe://<trust_domain>/<workload_identifier>
  
  ç¤ºä¾‹:
    - spiffe://example.org/frontend
    - spiffe://example.org/ns/default/sa/my-app
    - spiffe://example.org/region/us-west/service/api

Trust Domain:
  - ç‹¬ç«‹ä¿¡ä»»è¾¹ç•Œ
  - é€šå¸¸æ˜ å°„åˆ°ç»„ç»‡/é›†ç¾¤
  - å¯è”é‚¦ (Federation)

Workload Identifier:
  - å”¯ä¸€æ ‡è¯†å·¥ä½œè´Ÿè½½
  - å¯åˆ†å±‚ (namespace/service/version)
  - æ”¯æŒé€šé…ç¬¦ (ç”¨äºç­–ç•¥)
```

#### SPIRE Serveré…ç½®

```yaml
# spire-server.conf
server {
  bind_address = "0.0.0.0"
  bind_port = "8081"
  trust_domain = "example.org"
  data_dir = "/opt/spire/data/server"
  log_level = "INFO"
  
  # CAé…ç½®
  ca_subject = {
    country = ["US"],
    organization = ["Example Org"],
    common_name = "SPIRE Server CA",
  }
  
  # CAå¯†é’¥ç®¡ç†
  ca_key_type = "rsa-2048"  # æˆ– ec-p256
  ca_ttl = "87600h"  # 10å¹´
  
  # é»˜è®¤X.509 SVID TTL
  default_x509_svid_ttl = "1h"
  
  # JWT SVIDé…ç½®
  jwt_issuer = "spire-server"
  
  # è”é‚¦é…ç½® (å¯é€‰)
  federation {
    bundle_endpoint {
      address = "0.0.0.0"
      port = 8443
    }
    federates_with "partner.org" {
      bundle_endpoint_url = "https://spire-server.partner.org:8443"
      bundle_endpoint_profile "https_spiffe" {
        endpoint_spiffe_id = "spiffe://partner.org/spire/server"
      }
    }
  }
}

plugins {
  # èŠ‚ç‚¹è®¤è¯æ’ä»¶
  NodeAttestor "k8s_psat" {
    plugin_data {
      clusters = {
        "k8s-cluster" = {
          service_account_allow_list = ["spire:spire-agent"]
        }
      }
    }
  }
  
  # æ•°æ®å­˜å‚¨æ’ä»¶
  DataStore "sql" {
    plugin_data {
      database_type = "postgres"
      connection_string = "postgresql://spire:password@postgres:5432/spire"
    }
  }
  
  # å¯†é’¥ç®¡ç†æ’ä»¶
  KeyManager "memory" {
    plugin_data {}
  }
  
  # å·¥ä½œè´Ÿè½½è®¤è¯æ’ä»¶
  NodeResolver "noop" {
    plugin_data {}
  }
}
```

#### SPIRE Agenté…ç½®

```yaml
# spire-agent.conf
agent {
  data_dir = "/opt/spire/data/agent"
  log_level = "INFO"
  server_address = "spire-server"
  server_port = "8081"
  socket_path = "/run/spire/sockets/agent.sock"
  trust_domain = "example.org"
  
  # èŠ‚ç‚¹åˆ«å (å¯é€‰)
  # ç”¨äºèŠ‚ç‚¹è®¤è¯å’Œå·¥ä½œè´Ÿè½½æ³¨å†Œ
}

plugins {
  # èŠ‚ç‚¹è®¤è¯æ’ä»¶
  NodeAttestor "k8s_psat" {
    plugin_data {
      cluster = "k8s-cluster"
    }
  }
  
  # å¯†é’¥ç®¡ç†
  KeyManager "memory" {
    plugin_data {}
  }
  
  # å·¥ä½œè´Ÿè½½è®¤è¯ - Kubernetes
  WorkloadAttestor "k8s" {
    plugin_data {
      skip_kubelet_verification = true
    }
  }
  
  # å·¥ä½œè´Ÿè½½è®¤è¯ - Unix
  WorkloadAttestor "unix" {
    plugin_data {}
  }
  
  # å·¥ä½œè´Ÿè½½è®¤è¯ - Docker
  WorkloadAttestor "docker" {
    plugin_data {
      docker_socket_path = "/var/run/docker.sock"
    }
  }
}
```

#### å·¥ä½œè´Ÿè½½æ³¨å†Œ

```bash
# æ³¨å†ŒKuberneteså·¥ä½œè´Ÿè½½

# 1. åŸºäºPodæ ‡ç­¾æ³¨å†Œ
spire-server entry create \
  -spiffeID spiffe://example.org/frontend \
  -parentID spiffe://example.org/k8s-node \
  -selector k8s:ns:default \
  -selector k8s:pod-label:app:frontend \
  -ttl 3600

# 2. åŸºäºService Accountæ³¨å†Œ
spire-server entry create \
  -spiffeID spiffe://example.org/backend \
  -parentID spiffe://example.org/k8s-node \
  -selector k8s:ns:production \
  -selector k8s:sa:backend-sa \
  -ttl 3600

# 3. å¤šé€‰æ‹©å™¨ç»„åˆ
spire-server entry create \
  -spiffeID spiffe://example.org/database-client \
  -parentID spiffe://example.org/k8s-node \
  -selector k8s:ns:production \
  -selector k8s:sa:app-sa \
  -selector k8s:pod-label:tier:backend \
  -ttl 7200

# 4. æŸ¥çœ‹æ³¨å†Œæ¡ç›®
spire-server entry show

# 5. åˆ é™¤æ³¨å†Œæ¡ç›®
spire-server entry delete -entryID <entry-id>

# 6. æ›´æ–°TTL
spire-server entry update \
  -entryID <entry-id> \
  -ttl 7200
```

#### Goåº”ç”¨é›†æˆSPIFFE

```go
// spiffe_client.go
package main

import (
    "context"
    "crypto/tls"
    "fmt"
    "io/ioutil"
    "log"
    "net/http"
    
    "github.com/spiffe/go-spiffe/v2/spiffeid"
    "github.com/spiffe/go-spiffe/v2/spiffetls/tlsconfig"
    "github.com/spiffe/go-spiffe/v2/workloadapi"
)

func main() {
    ctx := context.Background()
    
    // è¿æ¥SPIRE Agent
    source, err := workloadapi.NewX509Source(ctx)
    if err != nil {
        log.Fatalf("Unable to create X509Source: %v", err)
    }
    defer source.Close()
    
    // è·å–SVID
    svid, err := source.GetX509SVID()
    if err != nil {
        log.Fatalf("Unable to get X.509 SVID: %v", err)
    }
    
    fmt.Printf("My SPIFFE ID: %s\n", svid.ID)
    
    // åˆ›å»ºmTLS HTTPæœåŠ¡å™¨
    serverID := spiffeid.RequireFromString("spiffe://example.org/backend")
    tlsConfig := tlsconfig.MTLSServerConfig(source, source, tlsconfig.AuthorizeID(serverID))
    
    server := &http.Server{
        Addr:      ":8443",
        TLSConfig: tlsConfig,
        Handler: http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
            // éªŒè¯å®¢æˆ·ç«¯SPIFFE ID
            if len(r.TLS.VerifiedChains) > 0 {
                clientID, err := spiffeid.FromURI(r.TLS.VerifiedChains[0][0].URIs[0])
                if err == nil {
                    fmt.Fprintf(w, "Hello %s!\n", clientID)
                    return
                }
            }
            http.Error(w, "Unauthorized", http.StatusUnauthorized)
        }),
    }
    
    log.Fatal(server.ListenAndServeTLS("", ""))
}
```

```go
// spiffe_http_client.go
package main

import (
    "context"
    "crypto/tls"
    "fmt"
    "io/ioutil"
    "log"
    "net/http"
    
    "github.com/spiffe/go-spiffe/v2/spiffeid"
    "github.com/spiffe/go-spiffe/v2/spiffetls/tlsconfig"
    "github.com/spiffe/go-spiffe/v2/workloadapi"
)

func main() {
    ctx := context.Background()
    
    // åˆ›å»ºX509Source
    source, err := workloadapi.NewX509Source(ctx)
    if err != nil {
        log.Fatalf("Unable to create X509Source: %v", err)
    }
    defer source.Close()
    
    // ç›®æ ‡æœåŠ¡çš„SPIFFE ID
    serverID := spiffeid.RequireFromString("spiffe://example.org/backend")
    
    // åˆ›å»ºmTLSå®¢æˆ·ç«¯
    tlsConfig := tlsconfig.MTLSClientConfig(source, source, tlsconfig.AuthorizeID(serverID))
    client := &http.Client{
        Transport: &http.Transport{
            TLSClientConfig: tlsConfig,
        },
    }
    
    // å‘èµ·è¯·æ±‚
    resp, err := client.Get("https://backend.example.com:8443/api/data")
    if err != nil {
        log.Fatalf("Error making request: %v", err)
    }
    defer resp.Body.Close()
    
    body, _ := ioutil.ReadAll(resp.Body)
    fmt.Printf("Response: %s\n", body)
}
```

#### gRPCé›†æˆSPIFFE

```go
// spiffe_grpc_server.go
package main

import (
    "context"
    "fmt"
    "log"
    "net"
    
    "google.golang.org/grpc"
    "google.golang.org/grpc/credentials"
    "google.golang.org/grpc/peer"
    
    "github.com/spiffe/go-spiffe/v2/spiffegrpc/grpccredentials"
    "github.com/spiffe/go-spiffe/v2/spiffeid"
    "github.com/spiffe/go-spiffe/v2/workloadapi"
    
    pb "your/protobuf/package"
)

type server struct {
    pb.UnimplementedYourServiceServer
}

func (s *server) YourMethod(ctx context.Context, req *pb.YourRequest) (*pb.YourResponse, error) {
    // è·å–å®¢æˆ·ç«¯SPIFFE ID
    if p, ok := peer.FromContext(ctx); ok {
        if authInfo, ok := p.AuthInfo.(credentials.TLSInfo); ok {
            if len(authInfo.State.VerifiedChains) > 0 {
                clientID, _ := spiffeid.FromURI(authInfo.State.VerifiedChains[0][0].URIs[0])
                fmt.Printf("Request from: %s\n", clientID)
            }
        }
    }
    
    return &pb.YourResponse{Message: "Hello!"}, nil
}

func main() {
    ctx := context.Background()
    
    // åˆ›å»ºX509Source
    source, err := workloadapi.NewX509Source(ctx)
    if err != nil {
        log.Fatalf("Unable to create X509Source: %v", err)
    }
    defer source.Close()
    
    // åˆ›å»ºgRPC Server Credentials
    creds := grpccredentials.MTLSServerCredentials(source, source, grpccredentials.AuthorizeAny())
    
    // åˆ›å»ºgRPC Server
    s := grpc.NewServer(grpc.Creds(creds))
    pb.RegisterYourServiceServer(s, &server{})
    
    lis, err := net.Listen("tcp", ":50051")
    if err != nil {
        log.Fatalf("Failed to listen: %v", err)
    }
    
    log.Fatal(s.Serve(lis))
}
```

### OAuth 2.0 ä¸ OIDC

#### OAuth 2.0æµç¨‹

```yaml
æˆæƒç æµç¨‹ (Authorization Code Flow):
  
  1. ç”¨æˆ·è®¿é—®å®¢æˆ·ç«¯åº”ç”¨
  2. å®¢æˆ·ç«¯é‡å®šå‘åˆ°æˆæƒæœåŠ¡å™¨
  3. ç”¨æˆ·ç™»å½•å¹¶æˆæƒ
  4. æˆæƒæœåŠ¡å™¨è¿”å›æˆæƒç 
  5. å®¢æˆ·ç«¯ç”¨æˆæƒç æ¢å–è®¿é—®ä»¤ç‰Œ
  6. å®¢æˆ·ç«¯ç”¨è®¿é—®ä»¤ç‰Œè®¿é—®èµ„æº
  
  ä¼˜åŠ¿:
    - è®¿é—®ä»¤ç‰Œä¸æš´éœ²ç»™æµè§ˆå™¨
    - æ”¯æŒåˆ·æ–°ä»¤ç‰Œ
    - é€‚åˆWebåº”ç”¨
  
éšå¼æµç¨‹ (Implicit Flow):
  - å·²å¼ƒç”¨ (ä¸å®‰å…¨)
  - è®¿é—®ä»¤ç‰Œç›´æ¥è¿”å›åˆ°æµè§ˆå™¨
  
å®¢æˆ·ç«¯å‡­è¯æµç¨‹ (Client Credentials):
  - ç”¨äºæœåŠ¡é—´è®¤è¯
  - æ— ç”¨æˆ·å‚ä¸
  - å®¢æˆ·ç«¯ID + Secret â†’ è®¿é—®ä»¤ç‰Œ
  
è®¾å¤‡æˆæƒæµç¨‹ (Device Authorization):
  - ç”¨äºå—é™è®¾å¤‡ (TV/IoT)
  - åœ¨å…¶ä»–è®¾å¤‡ä¸Šæˆæƒ
  
PKCE (Proof Key for Code Exchange):
  - å¢å¼ºæˆæƒç æµç¨‹å®‰å…¨æ€§
  - é˜²æ­¢æˆæƒç æ‹¦æˆªæ”»å‡»
  - ç§»åŠ¨åº”ç”¨/SPAå¿…å¤‡
```

#### Keycloakéƒ¨ç½²

```bash
# Dockeréƒ¨ç½²Keycloak

docker run -d \
  --name keycloak \
  -p 8080:8080 \
  -e KEYCLOAK_ADMIN=admin \
  -e KEYCLOAK_ADMIN_PASSWORD=admin \
  quay.io/keycloak/keycloak:23.0 \
  start-dev

# Kuberneteséƒ¨ç½²
kubectl create namespace keycloak

helm repo add bitnami https://charts.bitnami.com/bitnami
helm install keycloak bitnami/keycloak \
  --namespace keycloak \
  --set auth.adminUser=admin \
  --set auth.adminPassword=admin \
  --set postgresql.enabled=true

# è®¿é—® http://localhost:8080
# ç™»å½•: admin / admin
```

#### Keycloak Realmé…ç½®

```json
{
  "realm": "edge-realm",
  "enabled": true,
  "sslRequired": "external",
  "registrationAllowed": false,
  "loginWithEmailAllowed": true,
  "duplicateEmailsAllowed": false,
  "resetPasswordAllowed": true,
  "editUsernameAllowed": false,
  
  "defaultSignatureAlgorithm": "RS256",
  "revokeRefreshToken": false,
  "refreshTokenMaxReuse": 0,
  "accessTokenLifespan": 300,
  "accessTokenLifespanForImplicitFlow": 900,
  "ssoSessionIdleTimeout": 1800,
  "ssoSessionMaxLifespan": 36000,
  
  "bruteForceProtected": true,
  "failureFactor": 5,
  "waitIncrementSeconds": 60,
  "quickLoginCheckMilliSeconds": 1000,
  "minimumQuickLoginWaitSeconds": 60,
  "maxFailureWaitSeconds": 900,
  "maxDeltaTimeSeconds": 43200,
  
  "requiredCredentials": ["password"],
  
  "otpPolicyType": "totp",
  "otpPolicyAlgorithm": "HmacSHA1",
  "otpPolicyDigits": 6,
  "otpPolicyLookAheadWindow": 1,
  "otpPolicyPeriod": 30,
  
  "webAuthnPolicyRpEntityName": "keycloak",
  "webAuthnPolicySignatureAlgorithms": ["ES256", "RS256"],
  "webAuthnPolicyAttestationConveyancePreference": "not specified",
  "webAuthnPolicyAuthenticatorAttachment": "not specified",
  "webAuthnPolicyRequireResidentKey": "not specified",
  "webAuthnPolicyUserVerificationRequirement": "preferred"
}
```

#### Python OAuth2å®¢æˆ·ç«¯

```python
# oauth2_client.py
from authlib.integrations.requests_client import OAuth2Session
from authlib.oauth2.rfc7636 import create_s256_code_challenge
import secrets

class OAuth2Client:
    """OAuth 2.0å®¢æˆ·ç«¯ (PKCE)"""
    
    def __init__(self, client_id, auth_url, token_url, redirect_uri):
        self.client_id = client_id
        self.auth_url = auth_url
        self.token_url = token_url
        self.redirect_uri = redirect_uri
        
        # PKCE
        self.code_verifier = secrets.token_urlsafe(64)
        self.code_challenge = create_s256_code_challenge(self.code_verifier)
    
    def get_authorization_url(self):
        """è·å–æˆæƒURL"""
        session = OAuth2Session(
            client_id=self.client_id,
            redirect_uri=self.redirect_uri,
            scope='openid profile email'
        )
        
        authorization_url, state = session.create_authorization_url(
            self.auth_url,
            code_challenge=self.code_challenge,
            code_challenge_method='S256'
        )
        
        return authorization_url, state
    
    def fetch_token(self, authorization_response):
        """ç”¨æˆæƒç æ¢å–è®¿é—®ä»¤ç‰Œ"""
        session = OAuth2Session(
            client_id=self.client_id,
            redirect_uri=self.redirect_uri
        )
        
        token = session.fetch_token(
            self.token_url,
            authorization_response=authorization_response,
            code_verifier=self.code_verifier
        )
        
        return token
    
    def refresh_token(self, refresh_token):
        """åˆ·æ–°è®¿é—®ä»¤ç‰Œ"""
        session = OAuth2Session(
            client_id=self.client_id,
            token={'refresh_token': refresh_token}
        )
        
        new_token = session.refresh_token(
            self.token_url,
            refresh_token=refresh_token
        )
        
        return new_token
    
    def make_authenticated_request(self, url, access_token):
        """ä½¿ç”¨è®¿é—®ä»¤ç‰Œå‘èµ·è¯·æ±‚"""
        session = OAuth2Session(
            client_id=self.client_id,
            token={'access_token': access_token, 'token_type': 'Bearer'}
        )
        
        response = session.get(url)
        return response.json()

# ä½¿ç”¨ç¤ºä¾‹
if __name__ == '__main__':
    client = OAuth2Client(
        client_id='my-client',
        auth_url='http://keycloak:8080/realms/edge-realm/protocol/openid-connect/auth',
        token_url='http://keycloak:8080/realms/edge-realm/protocol/openid-connect/token',
        redirect_uri='http://localhost:3000/callback'
    )
    
    # 1. è·å–æˆæƒURL
    auth_url, state = client.get_authorization_url()
    print(f"Visit: {auth_url}")
    
    # 2. ç”¨æˆ·æˆæƒå,è·å–æˆæƒç 
    # authorization_response = 'http://localhost:3000/callback?code=xxx&state=yyy'
    
    # 3. æ¢å–è®¿é—®ä»¤ç‰Œ
    # token = client.fetch_token(authorization_response)
    # print(f"Access Token: {token['access_token']}")
    
    # 4. ä½¿ç”¨è®¿é—®ä»¤ç‰Œ
    # data = client.make_authenticated_request('https://api.example.com/user', token['access_token'])
```

#### JWTä»¤ç‰ŒéªŒè¯

```python
# jwt_validator.py
from jose import jwt, JWTError
from jose.exceptions import ExpiredSignatureError
import requests
from functools import lru_cache

class JWTValidator:
    """JWTä»¤ç‰ŒéªŒè¯å™¨"""
    
    def __init__(self, issuer, jwks_uri):
        self.issuer = issuer
        self.jwks_uri = jwks_uri
    
    @lru_cache(maxsize=1)
    def get_jwks(self):
        """è·å–JWKS (ç¼“å­˜)"""
        response = requests.get(self.jwks_uri)
        return response.json()
    
    def validate_token(self, token, audience=None):
        """éªŒè¯JWTä»¤ç‰Œ"""
        try:
            # è·å–JWKS
            jwks = self.get_jwks()
            
            # è§£ç å¹¶éªŒè¯
            payload = jwt.decode(
                token,
                jwks,
                algorithms=['RS256', 'ES256'],
                issuer=self.issuer,
                audience=audience,
                options={
                    'verify_signature': True,
                    'verify_aud': bool(audience),
                    'verify_iat': True,
                    'verify_exp': True,
                    'verify_nbf': True,
                    'verify_iss': True,
                }
            )
            
            return {
                'valid': True,
                'payload': payload,
                'subject': payload.get('sub'),
                'scopes': payload.get('scope', '').split(),
                'email': payload.get('email'),
                'name': payload.get('name'),
                'roles': payload.get('realm_access', {}).get('roles', [])
            }
        
        except ExpiredSignatureError:
            return {'valid': False, 'error': 'Token expired'}
        except JWTError as e:
            return {'valid': False, 'error': str(e)}
    
    def extract_claims(self, token):
        """æå–JWTå£°æ˜ (ä¸éªŒè¯ç­¾å)"""
        try:
            payload = jwt.get_unverified_claims(token)
            return payload
        except:
            return None

# Flaskä¸­é—´ä»¶
from flask import Flask, request, jsonify
from functools import wraps

app = Flask(__name__)

validator = JWTValidator(
    issuer='http://keycloak:8080/realms/edge-realm',
    jwks_uri='http://keycloak:8080/realms/edge-realm/protocol/openid-connect/certs'
)

def require_auth(required_roles=[]):
    """è®¤è¯è£…é¥°å™¨"""
    def decorator(f):
        @wraps(f)
        def decorated_function(*args, **kwargs):
            # æå–Bearer Token
            auth_header = request.headers.get('Authorization')
            if not auth_header or not auth_header.startswith('Bearer '):
                return jsonify({'error': 'Missing or invalid authorization header'}), 401
            
            token = auth_header.split(' ')[1]
            
            # éªŒè¯ä»¤ç‰Œ
            result = validator.validate_token(token)
            if not result['valid']:
                return jsonify({'error': result['error']}), 401
            
            # æ£€æŸ¥è§’è‰²
            if required_roles:
                user_roles = result['roles']
                if not any(role in user_roles for role in required_roles):
                    return jsonify({'error': 'Insufficient permissions'}), 403
            
            # å°†ç”¨æˆ·ä¿¡æ¯æ·»åŠ åˆ°è¯·æ±‚ä¸Šä¸‹æ–‡
            request.user = result['payload']
            
            return f(*args, **kwargs)
        return decorated_function
    return decorator

@app.route('/api/public')
def public():
    return jsonify({'message': 'Public endpoint'})

@app.route('/api/protected')
@require_auth()
def protected():
    return jsonify({
        'message': 'Protected endpoint',
        'user': request.user.get('preferred_username')
    })

@app.route('/api/admin')
@require_auth(required_roles=['admin'])
def admin():
    return jsonify({'message': 'Admin endpoint'})

if __name__ == '__main__':
    app.run(port=5000)
```

---

## ç½‘ç»œå¾®åˆ†æ®µ

### Ciliumç½‘ç»œç­–ç•¥

#### L3/L4ç­–ç•¥

```yaml
# cilium-l3-l4-policy.yaml

# 1. é»˜è®¤æ‹’ç»æ‰€æœ‰å…¥ç«™æµé‡
apiVersion: cilium.io/v2
kind: CiliumNetworkPolicy
metadata:
  name: default-deny-ingress
  namespace: production
spec:
  endpointSelector: {}
  ingress: []

---
# 2. å…è®¸frontendè®¿é—®backendçš„8080ç«¯å£
apiVersion: cilium.io/v2
kind: CiliumNetworkPolicy
metadata:
  name: allow-frontend-to-backend
  namespace: production
spec:
  endpointSelector:
    matchLabels:
      app: backend
  
  ingress:
  - fromEndpoints:
    - matchLabels:
        app: frontend
    toPorts:
    - ports:
      - port: "8080"
        protocol: TCP

---
# 3. å…è®¸backendè®¿é—®æ•°æ®åº“
apiVersion: cilium.io/v2
kind: CiliumNetworkPolicy
metadata:
  name: allow-backend-to-database
  namespace: production
spec:
  endpointSelector:
    matchLabels:
      app: backend
  
  egress:
  - toEndpoints:
    - matchLabels:
        app: postgres
    toPorts:
    - ports:
      - port: "5432"
        protocol: TCP
  
  - toEndpoints:
    - matchLabels:
        app: redis
    toPorts:
    - ports:
      - port: "6379"
        protocol: TCP

---
# 4. å…è®¸æ‰€æœ‰Podè®¿é—®DNSå’Œå¤–éƒ¨HTTPS
apiVersion: cilium.io/v2
kind: CiliumNetworkPolicy
metadata:
  name: allow-dns-and-https
  namespace: production
spec:
  endpointSelector: {}
  
  egress:
  # å…è®¸DNS
  - toEndpoints:
    - matchLabels:
        k8s:io.kubernetes.pod.namespace: kube-system
        k8s-app: kube-dns
    toPorts:
    - ports:
      - port: "53"
        protocol: UDP
      rules:
        dns:
        - matchPattern: "*"
  
  # å…è®¸å¤–éƒ¨HTTPS
  - toFQDNs:
    - matchPattern: "*.example.com"
    - matchPattern: "api.github.com"
    toPorts:
    - ports:
      - port: "443"
        protocol: TCP

---
# 5. åŸºäºå‘½åç©ºé—´çš„ç­–ç•¥
apiVersion: cilium.io/v2
kind: CiliumNetworkPolicy
metadata:
  name: allow-from-monitoring-namespace
  namespace: production
spec:
  endpointSelector:
    matchLabels:
      app: backend
  
  ingress:
  - fromEndpoints:
    - matchLabels:
        k8s:io.kubernetes.pod.namespace: monitoring
    toPorts:
    - ports:
      - port: "9090"  # Metricsç«¯å£
        protocol: TCP
```

#### L7ç­–ç•¥ (HTTP)

```yaml
# cilium-l7-http-policy.yaml

# 1. HTTPæ–¹æ³•å’Œè·¯å¾„æ§åˆ¶
apiVersion: cilium.io/v2
kind: CiliumNetworkPolicy
metadata:
  name: http-method-path-policy
  namespace: production
spec:
  endpointSelector:
    matchLabels:
      app: api-server
  
  ingress:
  - fromEndpoints:
    - matchLabels:
        app: frontend
    toPorts:
    - ports:
      - port: "8080"
        protocol: TCP
      rules:
        http:
        # åªå…è®¸GETå’ŒPOST
        - method: "GET"
          path: "/api/v1/.*"
        - method: "POST"
          path: "/api/v1/data"
        - method: "GET"
          path: "/health"

---
# 2. HTTPå¤´éƒ¨æ§åˆ¶
apiVersion: cilium.io/v2
kind: CiliumNetworkPolicy
metadata:
  name: http-header-policy
spec:
  endpointSelector:
    matchLabels:
      app: api-server
  
  ingress:
  - fromEndpoints:
    - matchLabels:
        app: client
    toPorts:
    - ports:
      - port: "8080"
        protocol: TCP
      rules:
        http:
        - method: "POST"
          path: "/api/.*"
          headers:
          - "Content-Type: application/json"
          - "X-API-Version: v1"

---
# 3. HTTPå“åº”ä»£ç è®°å½•
apiVersion: cilium.io/v2
kind: CiliumNetworkPolicy
metadata:
  name: http-response-logging
spec:
  endpointSelector:
    matchLabels:
      app: api-server
  
  ingress:
  - fromEndpoints:
    - matchLabels:
        app: client
    toPorts:
    - ports:
      - port: "8080"
        protocol: TCP
      rules:
        http:
        - method: ".*"
          path: "/.*"
          # è®°å½•æ‰€æœ‰4xxå’Œ5xxå“åº”
          headerMatches:
          - mismatch:
              name: ":status"
              value: "^[23].*"

---
# 4. é™é€Ÿ (Rate Limiting)
apiVersion: cilium.io/v2
kind: CiliumNetworkPolicy
metadata:
  name: http-rate-limit
spec:
  endpointSelector:
    matchLabels:
      app: api-server
  
  ingress:
  - fromEndpoints:
    - matchLabels:
        app: client
    toPorts:
    - ports:
      - port: "8080"
        protocol: TCP
      rules:
        http:
        - method: "POST"
          path: "/api/.*"
          rateLimit:
            requestsPerMinute: 100
            burstSize: 20

---
# 5. gRPCæ”¯æŒ
apiVersion: cilium.io/v2
kind: CiliumNetworkPolicy
metadata:
  name: grpc-policy
spec:
  endpointSelector:
    matchLabels:
      app: grpc-server
  
  ingress:
  - fromEndpoints:
    - matchLabels:
        app: grpc-client
    toPorts:
    - ports:
      - port: "50051"
        protocol: TCP
      rules:
        grpc:
        - method: "/myapp.MyService/MyMethod"
        - method: "/myapp.MyService/AnotherMethod"
```

#### Kafka/Cassandraç­–ç•¥

```yaml
# cilium-kafka-cassandra-policy.yaml

# Kafkaç­–ç•¥
apiVersion: cilium.io/v2
kind: CiliumNetworkPolicy
metadata:
  name: kafka-policy
  namespace: production
spec:
  endpointSelector:
    matchLabels:
      app: kafka-consumer
  
  egress:
  - toEndpoints:
    - matchLabels:
        app: kafka
    toPorts:
    - ports:
      - port: "9092"
        protocol: TCP
      rules:
        kafka:
        # åªå…è®¸è¯»å–ç‰¹å®štopic
        - apiKey: "fetch"
          topic: "orders"
        - apiKey: "fetch"
          topic: "payments"
        # å…è®¸æ‰€æœ‰å…ƒæ•°æ®è¯·æ±‚
        - apiKey: "metadata"

---
# Cassandraç­–ç•¥
apiVersion: cilium.io/v2
kind: CiliumNetworkPolicy
metadata:
  name: cassandra-policy
spec:
  endpointSelector:
    matchLabels:
      app: app-server
  
  egress:
  - toEndpoints:
    - matchLabels:
        app: cassandra
    toPorts:
    - ports:
      - port: "9042"
        protocol: TCP
      rules:
        cassandra:
        # é™åˆ¶æŸ¥è¯¢ç±»å‹
        - queryType: "select"
          keyspace: "myapp"
          table: "users"
        - queryType: "insert"
          keyspace: "myapp"
          table: "events"
```

### Istio Ambientæ¨¡å¼

#### Ambientæ¨¡å¼æ¦‚è¿°

```yaml
Istio Ambient Mode:
  ç‰¹ç‚¹:
    - æ— Sidecar
    - å…±äº«Layer 4ä»£ç† (ztunnel)
    - å¯é€‰Layer 7ä»£ç† (waypoint)
    - æ›´ä½èµ„æºæ¶ˆè€—
    - æ›´ç®€å•éƒ¨ç½²
  
  æ¶æ„:
    [Pod] â†’ [ztunnel (L4)] â†’ [waypoint (L7, å¯é€‰)] â†’ [Pod]
           (Node-level DaemonSet)    (Per-namespace)
  
  å¯¹æ¯”Sidecaræ¨¡å¼:
    Sidecar:
      - æ¯Podä¸€ä¸ªä»£ç†
      - æ›´çµæ´»
      - èµ„æºæ¶ˆè€—é«˜
      - å¤æ‚åº¦é«˜
    
    Ambient:
      - å…±äº«ä»£ç†
      - ç®€åŒ–éƒ¨ç½²
      - èµ„æºèŠ‚çœ50%+
      - æ¸è¿›å¼L7èƒ½åŠ›
```

#### Ambientæ¨¡å¼å®‰è£…

```bash
# å®‰è£…Istio Ambient

# 1. å®‰è£…Istio (å¯ç”¨Ambient)
istioctl install --set profile=ambient --skip-confirmation

# 2. éªŒè¯å®‰è£…
kubectl get pods -n istio-system

# åº”è¯¥çœ‹åˆ°:
# - istiod (æ§åˆ¶å¹³é¢)
# - ztunnel (DaemonSet, æ¯èŠ‚ç‚¹ä¸€ä¸ª)

# 3. ä¸ºå‘½åç©ºé—´å¯ç”¨Ambient
kubectl label namespace default istio.io/dataplane-mode=ambient

# 4. éªŒè¯ztunnel
kubectl logs -n istio-system -l app=ztunnel -f
```

#### Ambient L4æˆæƒç­–ç•¥

```yaml
# ambient-l4-authz.yaml

# 1. é»˜è®¤æ‹’ç»ç­–ç•¥
apiVersion: security.istio.io/v1beta1
kind: AuthorizationPolicy
metadata:
  name: deny-all
  namespace: default
spec:
  {} # ç©ºspec = æ‹’ç»æ‰€æœ‰

---
# 2. å…è®¸frontendåˆ°backend
apiVersion: security.istio.io/v1beta1
kind: AuthorizationPolicy
metadata:
  name: allow-frontend-to-backend
  namespace: default
spec:
  selector:
    matchLabels:
      app: backend
  
  action: ALLOW
  
  rules:
  - from:
    - source:
        principals: ["cluster.local/ns/default/sa/frontend"]
    to:
    - operation:
        ports: ["8080"]

---
# 3. å…è®¸ç‰¹å®šIPèŒƒå›´
apiVersion: security.istio.io/v1beta1
kind: AuthorizationPolicy
metadata:
  name: allow-cidr
spec:
  selector:
    matchLabels:
      app: api-server
  
  action: ALLOW
  
  rules:
  - from:
    - source:
        ipBlocks: ["10.0.0.0/8", "192.168.0.0/16"]
    to:
    - operation:
        ports: ["443"]
```

#### æ·»åŠ Waypointä»£ç† (L7)

```bash
# ä¸ºå‘½åç©ºé—´éƒ¨ç½²Waypointä»£ç†

# 1. åˆ›å»ºWaypoint
kubectl apply -f - <<EOF
apiVersion: gateway.networking.k8s.io/v1beta1
kind: Gateway
metadata:
  name: default-waypoint
  namespace: default
  annotations:
    istio.io/waypoint-for: all  # ä¸ºæ‰€æœ‰æµé‡å¯ç”¨
spec:
  gatewayClassName: istio-waypoint
  listeners:
  - name: mesh
    port: 15008
    protocol: HBONE
EOF

# 2. æŸ¥çœ‹WaypointçŠ¶æ€
kubectl get gateway default-waypoint -n default

# 3. Waypointä¼šè‡ªåŠ¨æ‹¦æˆªå¸¦æ ‡ç­¾çš„æœåŠ¡æµé‡
kubectl label service backend istio.io/use-waypoint=default-waypoint
```

#### Ambient L7æˆæƒç­–ç•¥

```yaml
# ambient-l7-authz.yaml

# éœ€è¦å…ˆéƒ¨ç½²Waypointä»£ç†

# 1. HTTPæ–¹æ³•æ§åˆ¶
apiVersion: security.istio.io/v1beta1
kind: AuthorizationPolicy
metadata:
  name: http-method-policy
  namespace: default
spec:
  selector:
    matchLabels:
      app: api-server
      istio.io/gateway-name: default-waypoint
  
  action: ALLOW
  
  rules:
  - from:
    - source:
        principals: ["cluster.local/ns/default/sa/frontend"]
    to:
    - operation:
        methods: ["GET", "POST"]
        paths: ["/api/v1/*"]

---
# 2. HTTPå¤´éƒ¨æ£€æŸ¥
apiVersion: security.istio.io/v1beta1
kind: AuthorizationPolicy
metadata:
  name: http-header-policy
spec:
  selector:
    matchLabels:
      app: api-server
      istio.io/gateway-name: default-waypoint
  
  action: ALLOW
  
  rules:
  - when:
    - key: request.headers[x-api-key]
      values: ["valid-api-key-123"]
    to:
    - operation:
        paths: ["/api/*"]

---
# 3. JWTéªŒè¯
apiVersion: security.istio.io/v1beta1
kind: RequestAuthentication
metadata:
  name: jwt-auth
  namespace: default
spec:
  selector:
    matchLabels:
      app: api-server
      istio.io/gateway-name: default-waypoint
  
  jwtRules:
  - issuer: "https://keycloak.example.com/realms/edge-realm"
    jwksUri: "https://keycloak.example.com/realms/edge-realm/protocol/openid-connect/certs"
    audiences:
    - "my-api"

---
apiVersion: security.istio.io/v1beta1
kind: AuthorizationPolicy
metadata:
  name: jwt-authz
spec:
  selector:
    matchLabels:
      app: api-server
      istio.io/gateway-name: default-waypoint
  
  action: ALLOW
  
  rules:
  - from:
    - source:
        requestPrincipals: ["*"]  # ä»»ä½•æœ‰æ•ˆJWT
    when:
    - key: request.auth.claims[role]
      values: ["admin", "user"]
```

### Calicoç½‘ç»œç­–ç•¥

```yaml
# calico-network-policy.yaml

# 1. GlobalNetworkPolicy (é›†ç¾¤çº§åˆ«)
apiVersion: projectcalico.org/v3
kind: GlobalNetworkPolicy
metadata:
  name: deny-all-ingress
spec:
  order: 1000  # ä½ä¼˜å…ˆçº§ (æ•°å­—è¶Šå¤§ä¼˜å…ˆçº§è¶Šä½)
  types:
  - Ingress
  # é»˜è®¤æ‹’ç»æ‰€æœ‰å…¥ç«™

---
# 2. NetworkPolicy (å‘½åç©ºé—´çº§åˆ«)
apiVersion: projectcalico.org/v3
kind: NetworkPolicy
metadata:
  name: allow-frontend-to-backend
  namespace: production
spec:
  order: 100  # é«˜ä¼˜å…ˆçº§
  selector: app == "backend"
  types:
  - Ingress
  ingress:
  - action: Allow
    source:
      selector: app == "frontend"
    destination:
      ports:
      - 8080

---
# 3. æœåŠ¡è´¦å·é€‰æ‹©å™¨
apiVersion: projectcalico.org/v3
kind: NetworkPolicy
metadata:
  name: allow-by-service-account
  namespace: production
spec:
  selector: app == "api-server"
  types:
  - Ingress
  ingress:
  - action: Allow
    source:
      serviceAccounts:
        names:
        - frontend-sa
        - mobile-sa

---
# 4. å…¨å±€æ‹’ç»ç­–ç•¥ + ç™½åå•
apiVersion: projectcalico.org/v3
kind: GlobalNetworkPolicy
metadata:
  name: default-deny-egress
spec:
  order: 2000
  types:
  - Egress
  egress:
  # å…è®¸DNS
  - action: Allow
    protocol: UDP
    destination:
      ports:
      - 53
  # å…è®¸Kubernetes API
  - action: Allow
    protocol: TCP
    destination:
      nets:
      - 10.96.0.1/32
      ports:
      - 443

---
# 5. æ—¶é—´çª—å£ç­–ç•¥
apiVersion: projectcalico.org/v3
kind: NetworkPolicy
metadata:
  name: time-based-policy
  namespace: production
spec:
  selector: app == "backup"
  types:
  - Egress
  egress:
  - action: Allow
    destination:
      nets:
      - 192.168.100.0/24  # å¤‡ä»½æœåŠ¡å™¨
    source:
      selector: app == "backup"
    # åªåœ¨ç‰¹å®šæ—¶é—´å…è®¸ (éœ€è¦é¢å¤–é…ç½®)
```

---

## æ•°æ®ä¿æŠ¤

### åŠ å¯†å­˜å‚¨

#### Kubernetes SecretsåŠ å¯†

```yaml
# kms-encryption-config.yaml
# ä½¿ç”¨å¤–éƒ¨KMSåŠ å¯†Secrets

apiVersion: apiserver.config.k8s.io/v1
kind: EncryptionConfiguration
resources:
- resources:
  - secrets
  providers:
  # 1. ä½¿ç”¨AWS KMS
  - kms:
      name: aws-kms
      endpoint: unix:///var/run/kmsplugin/socket.sock
      cachesize: 1000
      timeout: 3s
  
  # 2. ä½¿ç”¨HashiCorp Vault
  - kms:
      name: vault-kms
      endpoint: unix:///var/run/kmsplugin/vault.sock
      cachesize: 1000
  
  # 3. ä½¿ç”¨AES-CBC (æœ¬åœ°å¯†é’¥)
  - aescbc:
      keys:
      - name: key1
        secret: <base64-encoded-32-byte-key>
  
  # 4. æ˜æ–‡ (ç”¨äºè¯»å–æ—§æ•°æ®)
  - identity: {}
```

```bash
# é…ç½®API Serverä½¿ç”¨åŠ å¯†

# 1. åˆ›å»ºåŠ å¯†é…ç½®
vim /etc/kubernetes/enc/encryption-config.yaml

# 2. ä¿®æ”¹API Serveré…ç½®
vim /etc/kubernetes/manifests/kube-apiserver.yaml

# æ·»åŠ å‚æ•°:
# --encryption-provider-config=/etc/kubernetes/enc/encryption-config.yaml

# æ·»åŠ å·æŒ‚è½½:
# - mountPath: /etc/kubernetes/enc
#   name: encryption-config
#   readOnly: true
# volumes:
# - hostPath:
#     path: /etc/kubernetes/enc
#     type: DirectoryOrCreate
#   name: encryption-config

# 3. API Serverä¼šè‡ªåŠ¨é‡å¯

# 4. é‡æ–°åŠ å¯†æ‰€æœ‰Secrets
kubectl get secrets --all-namespaces -o json | \
  kubectl replace -f -

# 5. éªŒè¯åŠ å¯†
ETCDCTL_API=3 etcdctl get /registry/secrets/default/my-secret | hexdump -C
# åº”è¯¥çœ‹åˆ°åŠ å¯†çš„æ•°æ®,è€Œä¸æ˜¯æ˜æ–‡
```

#### Sealed Secrets

```bash
# Sealed Secrets - åœ¨Gitä¸­å®‰å…¨å­˜å‚¨Secrets

# 1. å®‰è£…Sealed Secrets Controller
kubectl apply -f https://github.com/bitnami-labs/sealed-secrets/releases/download/v0.24.0/controller.yaml

# 2. å®‰è£…kubeseal CLI
wget https://github.com/bitnami-labs/sealed-secrets/releases/download/v0.24.0/kubeseal-0.24.0-linux-amd64.tar.gz
tar -xvzf kubeseal-0.24.0-linux-amd64.tar.gz
sudo mv kubeseal /usr/local/bin/

# 3. åˆ›å»ºæ™®é€šSecret (ä¸´æ—¶)
kubectl create secret generic my-secret \
  --from-literal=username=admin \
  --from-literal=password=changeme \
  --dry-run=client -o yaml > secret.yaml

# 4. åŠ å¯†æˆSealedSecret
kubeseal -f secret.yaml -w sealedsecret.yaml

# 5. æŸ¥çœ‹SealedSecret
cat sealedsecret.yaml
```

```yaml
# sealedsecret.yamlç¤ºä¾‹
apiVersion: bitnami.com/v1alpha1
kind: SealedSecret
metadata:
  name: my-secret
  namespace: default
spec:
  encryptedData:
    username: AgB7xK9m...  # åŠ å¯†çš„æ•°æ®
    password: AgCY3Hf2...
  template:
    metadata:
      name: my-secret
      namespace: default
```

```bash
# 6. åº”ç”¨SealedSecret (å¯æäº¤åˆ°Git)
kubectl apply -f sealedsecret.yaml

# 7. Controllerä¼šè‡ªåŠ¨è§£å¯†å¹¶åˆ›å»ºæ™®é€šSecret
kubectl get secret my-secret -o yaml
```

### External Secrets Operator

```yaml
# external-secrets.yaml
# ä»å¤–éƒ¨å¯†é’¥ç®¡ç†ç³»ç»ŸåŒæ­¥Secrets

# 1. å®‰è£…ESO
# helm install external-secrets \
#   external-secrets/external-secrets \
#   -n external-secrets-system --create-namespace

# 2. é…ç½®SecretStore (AWS Secrets Manager)
apiVersion: external-secrets.io/v1beta1
kind: SecretStore
metadata:
  name: aws-secrets-manager
  namespace: production
spec:
  provider:
    aws:
      service: SecretsManager
      region: us-west-2
      auth:
        jwt:
          serviceAccountRef:
            name: external-secrets-sa

---
# 3. åˆ›å»ºExternalSecret
apiVersion: external-secrets.io/v1beta1
kind: ExternalSecret
metadata:
  name: database-credentials
  namespace: production
spec:
  refreshInterval: 1h  # æ¯å°æ—¶åŒæ­¥ä¸€æ¬¡
  
  secretStoreRef:
    name: aws-secrets-manager
    kind: SecretStore
  
  target:
    name: database-credentials  # åˆ›å»ºçš„K8s Secretåç§°
    creationPolicy: Owner
  
  data:
  - secretKey: username
    remoteRef:
      key: prod/database/credentials
      property: username
  
  - secretKey: password
    remoteRef:
      key: prod/database/credentials
      property: password

---
# 4. é…ç½®HashiCorp Vault
apiVersion: external-secrets.io/v1beta1
kind: SecretStore
metadata:
  name: vault-backend
  namespace: production
spec:
  provider:
    vault:
      server: "https://vault.example.com"
      path: "secret"
      version: "v2"
      auth:
        kubernetes:
          mountPath: "kubernetes"
          role: "external-secrets"
          serviceAccountRef:
            name: external-secrets-sa

---
apiVersion: external-secrets.io/v1beta1
kind: ExternalSecret
metadata:
  name: api-keys
spec:
  refreshInterval: 15m
  secretStoreRef:
    name: vault-backend
    kind: SecretStore
  target:
    name: api-keys
  data:
  - secretKey: api_key
    remoteRef:
      key: /prod/api-keys
      property: stripe_api_key
```

### æ•°æ®åº“åŠ å¯†

```yaml
# TDE (Transparent Data Encryption)

PostgreSQL:
  # 1. å®‰è£…pgcryptoæ‰©å±•
  CREATE EXTENSION pgcrypto;
  
  # 2. åŠ å¯†åˆ—
  CREATE TABLE users (
    id SERIAL PRIMARY KEY,
    username VARCHAR(100),
    email VARCHAR(255),
    ssn BYTEA  -- åŠ å¯†å­˜å‚¨
  );
  
  # 3. æ’å…¥åŠ å¯†æ•°æ®
  INSERT INTO users (username, email, ssn)
  VALUES (
    'john',
    'john@example.com',
    pgp_sym_encrypt('123-45-6789', 'encryption_key')
  );
  
  # 4. æŸ¥è¯¢è§£å¯†æ•°æ®
  SELECT username, pgp_sym_decrypt(ssn, 'encryption_key') AS ssn
  FROM users;

MySQL/MariaDB:
  # 1. å¯ç”¨at-reståŠ å¯†
  [mysqld]
  early-plugin-load=keyring_file.so
  keyring_file_data=/var/lib/mysql-keyring/keyring
  
  # 2. åˆ›å»ºåŠ å¯†è¡¨ç©ºé—´
  CREATE TABLESPACE encrypted_space
  ADD DATAFILE 'encrypted_space.ibd'
  ENCRYPTION='Y';
  
  # 3. åˆ›å»ºåŠ å¯†è¡¨
  CREATE TABLE sensitive_data (
    id INT PRIMARY KEY,
    data VARCHAR(255)
  ) TABLESPACE encrypted_space
    ENCRYPTION='Y';

MongoDB:
  # å¯ç”¨at-reståŠ å¯†
  security:
    enableEncryption: true
    encryptionKeyFile: /path/to/keyfile
  
  # æˆ–ä½¿ç”¨KMIP
  security:
    enableEncryption: true
    kmip:
      serverName: kmip.example.com
      port: 5696
      clientCertificateFile: /path/to/client.pem
```

**å½“å‰è¿›åº¦**: å·²å®Œæˆçº¦2,500è¡Œ,åŒ…å«:

- é›¶ä¿¡ä»»æ¶æ„æ¦‚è¿°ä¸æ ¸å¿ƒåŸåˆ™
- èº«ä»½ä¸è®¿é—®ç®¡ç† (SPIFFE/SPIRE/OAuth2/OIDC/JWT)
- ç½‘ç»œå¾®åˆ†æ®µ (Cilium/Istio Ambient/Calico)
- æ•°æ®ä¿æŠ¤ (åŠ å¯†å­˜å‚¨/Secretsç®¡ç†/æ•°æ®åº“åŠ å¯†)

**å¾…ç»§ç»­**: è®¾å¤‡ä¿¡ä»»ã€ç›‘æ§ä¸å“åº”ã€å®æ–½è·¯çº¿å›¾ã€å®æˆ˜æ¡ˆä¾‹ã€æœ€ä½³å®è·µ

---

**Edge Security, Zero Trust!** ğŸ”’ğŸ›¡ï¸âœ¨
