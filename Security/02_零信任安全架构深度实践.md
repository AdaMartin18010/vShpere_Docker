# 02_零信任安全架构深度实践

## 文档元信息

| 属性 | 值 |
|------|-----|
| **文档版本** | v2.0 (2025改进版) |
| **更新日期** | 2025-10-21 |
| **技术基准** | NIST SP 800-207, BeyondCorp, Zero Trust Network Access (ZTNA) |
| **安全标准** | NIST Zero Trust Architecture, Google BeyondCorp |
| **标准对齐** | 零信任2025最佳实践, mTLS, Identity-based Access |
| **状态** | 生产就绪 |

> **版本锚点**: 本文档严格对齐NIST SP 800-207零信任架构标准与2025年实践。

---

## 目录

- [02_零信任安全架构深度实践](#)
  - [文档元信息](#文档元信息)
  - [目录](#目录)

---

## 零信任架构概述

### 什么是零信任

```yaml
定义:
  - "Never Trust, Always Verify"
  - 假设网络内外都不可信
  - 基于身份的访问控制
  - 持续验证与最小权限

传统安全 vs 零信任:
  传统:
    - 边界防护 (城堡与护城河)
    - 内网可信
    - 静态策略
    - 网络位置决定访问权限
  
  零信任:
    - 无边界 (消除隐式信任)
    - 内网不可信
    - 动态策略
    - 身份与上下文决定访问权限
```

### 零信任架构模型

```yaml
NIST SP 800-207 零信任架构:
  
  核心组件:
    1. 策略引擎 (Policy Engine):
       - 评估访问请求
       - 考虑多因素 (身份/设备/位置/行为)
       - 实时决策
    
    2. 策略管理器 (Policy Administrator):
       - 建立/取消会话
       - 配置PEP (Policy Enforcement Point)
       - 动态策略应用
    
    3. 策略执行点 (PEP):
       - 实施访问控制
       - 监控流量
       - 上报遥测数据
  
  数据源:
    - CDM (Continuous Diagnostics & Mitigation): 设备状态
    - 身份管理系统: 用户身份
    - 威胁情报: 安全态势
    - SIEM: 安全事件
    - 行为分析: 异常检测
```

### BeyondCorp模型

```yaml
Google BeyondCorp:
  核心理念:
    - 访问取决于设备和用户
    - 不依赖网络位置
    - 所有服务暴露于互联网
    - 动态访问控制
  
  关键技术:
    - 设备清单与状态评估
    - 用户与设备认证
    - 访问代理 (Access Proxy)
    - 动态访问控制引擎
    - 持续监控与日志
  
  部署模式:
    [用户设备] 
       ↓ 认证
    [Access Proxy] ← [访问控制引擎]
       ↓ 授权              ↑
    [应用/服务] → [监控/日志]
```

---

## 核心原则与模型

### 零信任七原则

```yaml
1. 验证所有资源访问:
   - 用户身份验证
   - 设备健康检查
   - 应用授权
   - 数据敏感度评估

2. 最小权限访问:
   - Just-In-Time (JIT) 访问
   - Just-Enough-Access (JEA)
   - 基于时间的权限
   - 动态权限提升

3. 检查所有流量:
   - 加密所有通信
   - mTLS双向认证
   - 流量解密检查 (可选)
   - 深度包检测

4. 微分段网络:
   - 工作负载级隔离
   - 应用级策略
   - 动态策略调整
   - 零信任网络 (ZTN)

5. 持续监控:
   - 实时行为分析
   - 异常检测
   - 威胁情报集成
   - 安全态势感知

6. 自动化响应:
   - 自动威胁响应
   - 策略自动调整
   - 访问自动撤销
   - 事件自动上报

7. 假设失陷:
   - 内部威胁防护
   - 横向移动阻止
   - 数据泄露防护
   - 快速隔离能力
```

### 零信任成熟度模型

```yaml
Level 0 - 传统安全:
  - VPN/防火墙
  - 静态策略
  - 网络位置信任

Level 1 - 初级零信任:
  - MFA多因素认证
  - 基础设备识别
  - 简单微分段
  - 初步日志

Level 2 - 中级零信任:
  - 动态访问控制
  - 设备状态评估
  - 应用级微分段
  - 行为分析

Level 3 - 高级零信任:
  - 自适应访问控制
  - 持续信任评估
  - 自动化响应
  - 完整可见性

Level 4 - 最优零信任:
  - AI驱动策略
  - 预测性安全
  - 自主响应
  - 业务集成
```

---

## 身份与访问管理

### SPIFFE/SPIRE深度实践

#### SPIFFE ID结构

```yaml
SPIFFE ID格式:
  spiffe://<trust_domain>/<workload_identifier>
  
  示例:
    - spiffe://example.org/frontend
    - spiffe://example.org/ns/default/sa/my-app
    - spiffe://example.org/region/us-west/service/api

Trust Domain:
  - 独立信任边界
  - 通常映射到组织/集群
  - 可联邦 (Federation)

Workload Identifier:
  - 唯一标识工作负载
  - 可分层 (namespace/service/version)
  - 支持通配符 (用于策略)
```

#### SPIRE Server配置

```yaml
# spire-server.conf
server {
  bind_address = "0.0.0.0"
  bind_port = "8081"
  trust_domain = "example.org"
  data_dir = "/opt/spire/data/server"
  log_level = "INFO"
  
  # CA配置
  ca_subject = {
    country = ["US"],
    organization = ["Example Org"],
    common_name = "SPIRE Server CA",
  }
  
  # CA密钥管理
  ca_key_type = "rsa-2048"  # 或 ec-p256
  ca_ttl = "87600h"  # 10年
  
  # 默认X.509 SVID TTL
  default_x509_svid_ttl = "1h"
  
  # JWT SVID配置
  jwt_issuer = "spire-server"
  
  # 联邦配置 (可选)
  federation {
    bundle_endpoint {
      address = "0.0.0.0"
      port = 8443
    }
    federates_with "partner.org" {
      bundle_endpoint_url = "https://spire-server.partner.org:8443"
      bundle_endpoint_profile "https_spiffe" {
        endpoint_spiffe_id = "spiffe://partner.org/spire/server"
      }
    }
  }
}

plugins {
  # 节点认证插件
  NodeAttestor "k8s_psat" {
    plugin_data {
      clusters = {
        "k8s-cluster" = {
          service_account_allow_list = ["spire:spire-agent"]
        }
      }
    }
  }
  
  # 数据存储插件
  DataStore "sql" {
    plugin_data {
      database_type = "postgres"
      connection_string = "postgresql://spire:password@postgres:5432/spire"
    }
  }
  
  # 密钥管理插件
  KeyManager "memory" {
    plugin_data {}
  }
  
  # 工作负载认证插件
  NodeResolver "noop" {
    plugin_data {}
  }
}
```

#### SPIRE Agent配置

```yaml
# spire-agent.conf
agent {
  data_dir = "/opt/spire/data/agent"
  log_level = "INFO"
  server_address = "spire-server"
  server_port = "8081"
  socket_path = "/run/spire/sockets/agent.sock"
  trust_domain = "example.org"
  
  # 节点别名 (可选)
  # 用于节点认证和工作负载注册
}

plugins {
  # 节点认证插件
  NodeAttestor "k8s_psat" {
    plugin_data {
      cluster = "k8s-cluster"
    }
  }
  
  # 密钥管理
  KeyManager "memory" {
    plugin_data {}
  }
  
  # 工作负载认证 - Kubernetes
  WorkloadAttestor "k8s" {
    plugin_data {
      skip_kubelet_verification = true
    }
  }
  
  # 工作负载认证 - Unix
  WorkloadAttestor "unix" {
    plugin_data {}
  }
  
  # 工作负载认证 - Docker
  WorkloadAttestor "docker" {
    plugin_data {
      docker_socket_path = "/var/run/docker.sock"
    }
  }
}
```

#### 工作负载注册

```bash
# 注册Kubernetes工作负载

# 1. 基于Pod标签注册
spire-server entry create \
  -spiffeID spiffe://example.org/frontend \
  -parentID spiffe://example.org/k8s-node \
  -selector k8s:ns:default \
  -selector k8s:pod-label:app:frontend \
  -ttl 3600

# 2. 基于Service Account注册
spire-server entry create \
  -spiffeID spiffe://example.org/backend \
  -parentID spiffe://example.org/k8s-node \
  -selector k8s:ns:production \
  -selector k8s:sa:backend-sa \
  -ttl 3600

# 3. 多选择器组合
spire-server entry create \
  -spiffeID spiffe://example.org/database-client \
  -parentID spiffe://example.org/k8s-node \
  -selector k8s:ns:production \
  -selector k8s:sa:app-sa \
  -selector k8s:pod-label:tier:backend \
  -ttl 7200

# 4. 查看注册条目
spire-server entry show

# 5. 删除注册条目
spire-server entry delete -entryID <entry-id>

# 6. 更新TTL
spire-server entry update \
  -entryID <entry-id> \
  -ttl 7200
```

#### Go应用集成SPIFFE

```go
// spiffe_client.go
package main

import (
    "context"
    "crypto/tls"
    "fmt"
    "io/ioutil"
    "log"
    "net/http"
    
    "github.com/spiffe/go-spiffe/v2/spiffeid"
    "github.com/spiffe/go-spiffe/v2/spiffetls/tlsconfig"
    "github.com/spiffe/go-spiffe/v2/workloadapi"
)

func main() {
    ctx := context.Background()
    
    // 连接SPIRE Agent
    source, err := workloadapi.NewX509Source(ctx)
    if err != nil {
        log.Fatalf("Unable to create X509Source: %v", err)
    }
    defer source.Close()
    
    // 获取SVID
    svid, err := source.GetX509SVID()
    if err != nil {
        log.Fatalf("Unable to get X.509 SVID: %v", err)
    }
    
    fmt.Printf("My SPIFFE ID: %s\n", svid.ID)
    
    // 创建mTLS HTTP服务器
    serverID := spiffeid.RequireFromString("spiffe://example.org/backend")
    tlsConfig := tlsconfig.MTLSServerConfig(source, source, tlsconfig.AuthorizeID(serverID))
    
    server := &http.Server{
        Addr:      ":8443",
        TLSConfig: tlsConfig,
        Handler: http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
            // 验证客户端SPIFFE ID
            if len(r.TLS.VerifiedChains) > 0 {
                clientID, err := spiffeid.FromURI(r.TLS.VerifiedChains[0][0].URIs[0])
                if err == nil {
                    fmt.Fprintf(w, "Hello %s!\n", clientID)
                    return
                }
            }
            http.Error(w, "Unauthorized", http.StatusUnauthorized)
        }),
    }
    
    log.Fatal(server.ListenAndServeTLS("", ""))
}
```

```go
// spiffe_http_client.go
package main

import (
    "context"
    "crypto/tls"
    "fmt"
    "io/ioutil"
    "log"
    "net/http"
    
    "github.com/spiffe/go-spiffe/v2/spiffeid"
    "github.com/spiffe/go-spiffe/v2/spiffetls/tlsconfig"
    "github.com/spiffe/go-spiffe/v2/workloadapi"
)

func main() {
    ctx := context.Background()
    
    // 创建X509Source
    source, err := workloadapi.NewX509Source(ctx)
    if err != nil {
        log.Fatalf("Unable to create X509Source: %v", err)
    }
    defer source.Close()
    
    // 目标服务的SPIFFE ID
    serverID := spiffeid.RequireFromString("spiffe://example.org/backend")
    
    // 创建mTLS客户端
    tlsConfig := tlsconfig.MTLSClientConfig(source, source, tlsconfig.AuthorizeID(serverID))
    client := &http.Client{
        Transport: &http.Transport{
            TLSClientConfig: tlsConfig,
        },
    }
    
    // 发起请求
    resp, err := client.Get("https://backend.example.com:8443/api/data")
    if err != nil {
        log.Fatalf("Error making request: %v", err)
    }
    defer resp.Body.Close()
    
    body, _ := ioutil.ReadAll(resp.Body)
    fmt.Printf("Response: %s\n", body)
}
```

#### gRPC集成SPIFFE

```go
// spiffe_grpc_server.go
package main

import (
    "context"
    "fmt"
    "log"
    "net"
    
    "google.golang.org/grpc"
    "google.golang.org/grpc/credentials"
    "google.golang.org/grpc/peer"
    
    "github.com/spiffe/go-spiffe/v2/spiffegrpc/grpccredentials"
    "github.com/spiffe/go-spiffe/v2/spiffeid"
    "github.com/spiffe/go-spiffe/v2/workloadapi"
    
    pb "your/protobuf/package"
)

type server struct {
    pb.UnimplementedYourServiceServer
}

func (s *server) YourMethod(ctx context.Context, req *pb.YourRequest) (*pb.YourResponse, error) {
    // 获取客户端SPIFFE ID
    if p, ok := peer.FromContext(ctx); ok {
        if authInfo, ok := p.AuthInfo.(credentials.TLSInfo); ok {
            if len(authInfo.State.VerifiedChains) > 0 {
                clientID, _ := spiffeid.FromURI(authInfo.State.VerifiedChains[0][0].URIs[0])
                fmt.Printf("Request from: %s\n", clientID)
            }
        }
    }
    
    return &pb.YourResponse{Message: "Hello!"}, nil
}

func main() {
    ctx := context.Background()
    
    // 创建X509Source
    source, err := workloadapi.NewX509Source(ctx)
    if err != nil {
        log.Fatalf("Unable to create X509Source: %v", err)
    }
    defer source.Close()
    
    // 创建gRPC Server Credentials
    creds := grpccredentials.MTLSServerCredentials(source, source, grpccredentials.AuthorizeAny())
    
    // 创建gRPC Server
    s := grpc.NewServer(grpc.Creds(creds))
    pb.RegisterYourServiceServer(s, &server{})
    
    lis, err := net.Listen("tcp", ":50051")
    if err != nil {
        log.Fatalf("Failed to listen: %v", err)
    }
    
    log.Fatal(s.Serve(lis))
}
```

### OAuth 2.0 与 OIDC

#### OAuth 2.0流程

```yaml
授权码流程 (Authorization Code Flow):
  
  1. 用户访问客户端应用
  2. 客户端重定向到授权服务器
  3. 用户登录并授权
  4. 授权服务器返回授权码
  5. 客户端用授权码换取访问令牌
  6. 客户端用访问令牌访问资源
  
  优势:
    - 访问令牌不暴露给浏览器
    - 支持刷新令牌
    - 适合Web应用
  
隐式流程 (Implicit Flow):
  - 已弃用 (不安全)
  - 访问令牌直接返回到浏览器
  
客户端凭证流程 (Client Credentials):
  - 用于服务间认证
  - 无用户参与
  - 客户端ID + Secret → 访问令牌
  
设备授权流程 (Device Authorization):
  - 用于受限设备 (TV/IoT)
  - 在其他设备上授权
  
PKCE (Proof Key for Code Exchange):
  - 增强授权码流程安全性
  - 防止授权码拦截攻击
  - 移动应用/SPA必备
```

#### Keycloak部署

```bash
# Docker部署Keycloak

docker run -d \
  --name keycloak \
  -p 8080:8080 \
  -e KEYCLOAK_ADMIN=admin \
  -e KEYCLOAK_ADMIN_PASSWORD=admin \
  quay.io/keycloak/keycloak:23.0 \
  start-dev

# Kubernetes部署
kubectl create namespace keycloak

helm repo add bitnami https://charts.bitnami.com/bitnami
helm install keycloak bitnami/keycloak \
  --namespace keycloak \
  --set auth.adminUser=admin \
  --set auth.adminPassword=admin \
  --set postgresql.enabled=true

# 访问 http://localhost:8080
# 登录: admin / admin
```

#### Keycloak Realm配置

```json
{
  "realm": "edge-realm",
  "enabled": true,
  "sslRequired": "external",
  "registrationAllowed": false,
  "loginWithEmailAllowed": true,
  "duplicateEmailsAllowed": false,
  "resetPasswordAllowed": true,
  "editUsernameAllowed": false,
  
  "defaultSignatureAlgorithm": "RS256",
  "revokeRefreshToken": false,
  "refreshTokenMaxReuse": 0,
  "accessTokenLifespan": 300,
  "accessTokenLifespanForImplicitFlow": 900,
  "ssoSessionIdleTimeout": 1800,
  "ssoSessionMaxLifespan": 36000,
  
  "bruteForceProtected": true,
  "failureFactor": 5,
  "waitIncrementSeconds": 60,
  "quickLoginCheckMilliSeconds": 1000,
  "minimumQuickLoginWaitSeconds": 60,
  "maxFailureWaitSeconds": 900,
  "maxDeltaTimeSeconds": 43200,
  
  "requiredCredentials": ["password"],
  
  "otpPolicyType": "totp",
  "otpPolicyAlgorithm": "HmacSHA1",
  "otpPolicyDigits": 6,
  "otpPolicyLookAheadWindow": 1,
  "otpPolicyPeriod": 30,
  
  "webAuthnPolicyRpEntityName": "keycloak",
  "webAuthnPolicySignatureAlgorithms": ["ES256", "RS256"],
  "webAuthnPolicyAttestationConveyancePreference": "not specified",
  "webAuthnPolicyAuthenticatorAttachment": "not specified",
  "webAuthnPolicyRequireResidentKey": "not specified",
  "webAuthnPolicyUserVerificationRequirement": "preferred"
}
```

#### Python OAuth2客户端

```python
# oauth2_client.py
from authlib.integrations.requests_client import OAuth2Session
from authlib.oauth2.rfc7636 import create_s256_code_challenge
import secrets

class OAuth2Client:
    """OAuth 2.0客户端 (PKCE)"""
    
    def __init__(self, client_id, auth_url, token_url, redirect_uri):
        self.client_id = client_id
        self.auth_url = auth_url
        self.token_url = token_url
        self.redirect_uri = redirect_uri
        
        # PKCE
        self.code_verifier = secrets.token_urlsafe(64)
        self.code_challenge = create_s256_code_challenge(self.code_verifier)
    
    def get_authorization_url(self):
        """获取授权URL"""
        session = OAuth2Session(
            client_id=self.client_id,
            redirect_uri=self.redirect_uri,
            scope='openid profile email'
        )
        
        authorization_url, state = session.create_authorization_url(
            self.auth_url,
            code_challenge=self.code_challenge,
            code_challenge_method='S256'
        )
        
        return authorization_url, state
    
    def fetch_token(self, authorization_response):
        """用授权码换取访问令牌"""
        session = OAuth2Session(
            client_id=self.client_id,
            redirect_uri=self.redirect_uri
        )
        
        token = session.fetch_token(
            self.token_url,
            authorization_response=authorization_response,
            code_verifier=self.code_verifier
        )
        
        return token
    
    def refresh_token(self, refresh_token):
        """刷新访问令牌"""
        session = OAuth2Session(
            client_id=self.client_id,
            token={'refresh_token': refresh_token}
        )
        
        new_token = session.refresh_token(
            self.token_url,
            refresh_token=refresh_token
        )
        
        return new_token
    
    def make_authenticated_request(self, url, access_token):
        """使用访问令牌发起请求"""
        session = OAuth2Session(
            client_id=self.client_id,
            token={'access_token': access_token, 'token_type': 'Bearer'}
        )
        
        response = session.get(url)
        return response.json()

# 使用示例
if __name__ == '__main__':
    client = OAuth2Client(
        client_id='my-client',
        auth_url='http://keycloak:8080/realms/edge-realm/protocol/openid-connect/auth',
        token_url='http://keycloak:8080/realms/edge-realm/protocol/openid-connect/token',
        redirect_uri='http://localhost:3000/callback'
    )
    
    # 1. 获取授权URL
    auth_url, state = client.get_authorization_url()
    print(f"Visit: {auth_url}")
    
    # 2. 用户授权后,获取授权码
    # authorization_response = 'http://localhost:3000/callback?code=xxx&state=yyy'
    
    # 3. 换取访问令牌
    # token = client.fetch_token(authorization_response)
    # print(f"Access Token: {token['access_token']}")
    
    # 4. 使用访问令牌
    # data = client.make_authenticated_request('https://api.example.com/user', token['access_token'])
```

#### JWT令牌验证

```python
# jwt_validator.py
from jose import jwt, JWTError
from jose.exceptions import ExpiredSignatureError
import requests
from functools import lru_cache

class JWTValidator:
    """JWT令牌验证器"""
    
    def __init__(self, issuer, jwks_uri):
        self.issuer = issuer
        self.jwks_uri = jwks_uri
    
    @lru_cache(maxsize=1)
    def get_jwks(self):
        """获取JWKS (缓存)"""
        response = requests.get(self.jwks_uri)
        return response.json()
    
    def validate_token(self, token, audience=None):
        """验证JWT令牌"""
        try:
            # 获取JWKS
            jwks = self.get_jwks()
            
            # 解码并验证
            payload = jwt.decode(
                token,
                jwks,
                algorithms=['RS256', 'ES256'],
                issuer=self.issuer,
                audience=audience,
                options={
                    'verify_signature': True,
                    'verify_aud': bool(audience),
                    'verify_iat': True,
                    'verify_exp': True,
                    'verify_nbf': True,
                    'verify_iss': True,
                }
            )
            
            return {
                'valid': True,
                'payload': payload,
                'subject': payload.get('sub'),
                'scopes': payload.get('scope', '').split(),
                'email': payload.get('email'),
                'name': payload.get('name'),
                'roles': payload.get('realm_access', {}).get('roles', [])
            }
        
        except ExpiredSignatureError:
            return {'valid': False, 'error': 'Token expired'}
        except JWTError as e:
            return {'valid': False, 'error': str(e)}
    
    def extract_claims(self, token):
        """提取JWT声明 (不验证签名)"""
        try:
            payload = jwt.get_unverified_claims(token)
            return payload
        except:
            return None

# Flask中间件
from flask import Flask, request, jsonify
from functools import wraps

app = Flask(__name__)

validator = JWTValidator(
    issuer='http://keycloak:8080/realms/edge-realm',
    jwks_uri='http://keycloak:8080/realms/edge-realm/protocol/openid-connect/certs'
)

def require_auth(required_roles=[]):
    """认证装饰器"""
    def decorator(f):
        @wraps(f)
        def decorated_function(*args, **kwargs):
            # 提取Bearer Token
            auth_header = request.headers.get('Authorization')
            if not auth_header or not auth_header.startswith('Bearer '):
                return jsonify({'error': 'Missing or invalid authorization header'}), 401
            
            token = auth_header.split(' ')[1]
            
            # 验证令牌
            result = validator.validate_token(token)
            if not result['valid']:
                return jsonify({'error': result['error']}), 401
            
            # 检查角色
            if required_roles:
                user_roles = result['roles']
                if not any(role in user_roles for role in required_roles):
                    return jsonify({'error': 'Insufficient permissions'}), 403
            
            # 将用户信息添加到请求上下文
            request.user = result['payload']
            
            return f(*args, **kwargs)
        return decorated_function
    return decorator

@app.route('/api/public')
def public():
    return jsonify({'message': 'Public endpoint'})

@app.route('/api/protected')
@require_auth()
def protected():
    return jsonify({
        'message': 'Protected endpoint',
        'user': request.user.get('preferred_username')
    })

@app.route('/api/admin')
@require_auth(required_roles=['admin'])
def admin():
    return jsonify({'message': 'Admin endpoint'})

if __name__ == '__main__':
    app.run(port=5000)
```

---

## 网络微分段

### Cilium网络策略

#### L3/L4策略

```yaml
# cilium-l3-l4-policy.yaml

# 1. 默认拒绝所有入站流量
apiVersion: cilium.io/v2
kind: CiliumNetworkPolicy
metadata:
  name: default-deny-ingress
  namespace: production
spec:
  endpointSelector: {}
  ingress: []

---
# 2. 允许frontend访问backend的8080端口
apiVersion: cilium.io/v2
kind: CiliumNetworkPolicy
metadata:
  name: allow-frontend-to-backend
  namespace: production
spec:
  endpointSelector:
    matchLabels:
      app: backend
  
  ingress:
  - fromEndpoints:
    - matchLabels:
        app: frontend
    toPorts:
    - ports:
      - port: "8080"
        protocol: TCP

---
# 3. 允许backend访问数据库
apiVersion: cilium.io/v2
kind: CiliumNetworkPolicy
metadata:
  name: allow-backend-to-database
  namespace: production
spec:
  endpointSelector:
    matchLabels:
      app: backend
  
  egress:
  - toEndpoints:
    - matchLabels:
        app: postgres
    toPorts:
    - ports:
      - port: "5432"
        protocol: TCP
  
  - toEndpoints:
    - matchLabels:
        app: redis
    toPorts:
    - ports:
      - port: "6379"
        protocol: TCP

---
# 4. 允许所有Pod访问DNS和外部HTTPS
apiVersion: cilium.io/v2
kind: CiliumNetworkPolicy
metadata:
  name: allow-dns-and-https
  namespace: production
spec:
  endpointSelector: {}
  
  egress:
  # 允许DNS
  - toEndpoints:
    - matchLabels:
        k8s:io.kubernetes.pod.namespace: kube-system
        k8s-app: kube-dns
    toPorts:
    - ports:
      - port: "53"
        protocol: UDP
      rules:
        dns:
        - matchPattern: "*"
  
  # 允许外部HTTPS
  - toFQDNs:
    - matchPattern: "*.example.com"
    - matchPattern: "api.github.com"
    toPorts:
    - ports:
      - port: "443"
        protocol: TCP

---
# 5. 基于命名空间的策略
apiVersion: cilium.io/v2
kind: CiliumNetworkPolicy
metadata:
  name: allow-from-monitoring-namespace
  namespace: production
spec:
  endpointSelector:
    matchLabels:
      app: backend
  
  ingress:
  - fromEndpoints:
    - matchLabels:
        k8s:io.kubernetes.pod.namespace: monitoring
    toPorts:
    - ports:
      - port: "9090"  # Metrics端口
        protocol: TCP
```

#### L7策略 (HTTP)

```yaml
# cilium-l7-http-policy.yaml

# 1. HTTP方法和路径控制
apiVersion: cilium.io/v2
kind: CiliumNetworkPolicy
metadata:
  name: http-method-path-policy
  namespace: production
spec:
  endpointSelector:
    matchLabels:
      app: api-server
  
  ingress:
  - fromEndpoints:
    - matchLabels:
        app: frontend
    toPorts:
    - ports:
      - port: "8080"
        protocol: TCP
      rules:
        http:
        # 只允许GET和POST
        - method: "GET"
          path: "/api/v1/.*"
        - method: "POST"
          path: "/api/v1/data"
        - method: "GET"
          path: "/health"

---
# 2. HTTP头部控制
apiVersion: cilium.io/v2
kind: CiliumNetworkPolicy
metadata:
  name: http-header-policy
spec:
  endpointSelector:
    matchLabels:
      app: api-server
  
  ingress:
  - fromEndpoints:
    - matchLabels:
        app: client
    toPorts:
    - ports:
      - port: "8080"
        protocol: TCP
      rules:
        http:
        - method: "POST"
          path: "/api/.*"
          headers:
          - "Content-Type: application/json"
          - "X-API-Version: v1"

---
# 3. HTTP响应代码记录
apiVersion: cilium.io/v2
kind: CiliumNetworkPolicy
metadata:
  name: http-response-logging
spec:
  endpointSelector:
    matchLabels:
      app: api-server
  
  ingress:
  - fromEndpoints:
    - matchLabels:
        app: client
    toPorts:
    - ports:
      - port: "8080"
        protocol: TCP
      rules:
        http:
        - method: ".*"
          path: "/.*"
          # 记录所有4xx和5xx响应
          headerMatches:
          - mismatch:
              name: ":status"
              value: "^[23].*"

---
# 4. 限速 (Rate Limiting)
apiVersion: cilium.io/v2
kind: CiliumNetworkPolicy
metadata:
  name: http-rate-limit
spec:
  endpointSelector:
    matchLabels:
      app: api-server
  
  ingress:
  - fromEndpoints:
    - matchLabels:
        app: client
    toPorts:
    - ports:
      - port: "8080"
        protocol: TCP
      rules:
        http:
        - method: "POST"
          path: "/api/.*"
          rateLimit:
            requestsPerMinute: 100
            burstSize: 20

---
# 5. gRPC支持
apiVersion: cilium.io/v2
kind: CiliumNetworkPolicy
metadata:
  name: grpc-policy
spec:
  endpointSelector:
    matchLabels:
      app: grpc-server
  
  ingress:
  - fromEndpoints:
    - matchLabels:
        app: grpc-client
    toPorts:
    - ports:
      - port: "50051"
        protocol: TCP
      rules:
        grpc:
        - method: "/myapp.MyService/MyMethod"
        - method: "/myapp.MyService/AnotherMethod"
```

#### Kafka/Cassandra策略

```yaml
# cilium-kafka-cassandra-policy.yaml

# Kafka策略
apiVersion: cilium.io/v2
kind: CiliumNetworkPolicy
metadata:
  name: kafka-policy
  namespace: production
spec:
  endpointSelector:
    matchLabels:
      app: kafka-consumer
  
  egress:
  - toEndpoints:
    - matchLabels:
        app: kafka
    toPorts:
    - ports:
      - port: "9092"
        protocol: TCP
      rules:
        kafka:
        # 只允许读取特定topic
        - apiKey: "fetch"
          topic: "orders"
        - apiKey: "fetch"
          topic: "payments"
        # 允许所有元数据请求
        - apiKey: "metadata"

---
# Cassandra策略
apiVersion: cilium.io/v2
kind: CiliumNetworkPolicy
metadata:
  name: cassandra-policy
spec:
  endpointSelector:
    matchLabels:
      app: app-server
  
  egress:
  - toEndpoints:
    - matchLabels:
        app: cassandra
    toPorts:
    - ports:
      - port: "9042"
        protocol: TCP
      rules:
        cassandra:
        # 限制查询类型
        - queryType: "select"
          keyspace: "myapp"
          table: "users"
        - queryType: "insert"
          keyspace: "myapp"
          table: "events"
```

### Istio Ambient模式

#### Ambient模式概述

```yaml
Istio Ambient Mode:
  特点:
    - 无Sidecar
    - 共享Layer 4代理 (ztunnel)
    - 可选Layer 7代理 (waypoint)
    - 更低资源消耗
    - 更简单部署
  
  架构:
    [Pod] → [ztunnel (L4)] → [waypoint (L7, 可选)] → [Pod]
           (Node-level DaemonSet)    (Per-namespace)
  
  对比Sidecar模式:
    Sidecar:
      - 每Pod一个代理
      - 更灵活
      - 资源消耗高
      - 复杂度高
    
    Ambient:
      - 共享代理
      - 简化部署
      - 资源节省50%+
      - 渐进式L7能力
```

#### Ambient模式安装

```bash
# 安装Istio Ambient

# 1. 安装Istio (启用Ambient)
istioctl install --set profile=ambient --skip-confirmation

# 2. 验证安装
kubectl get pods -n istio-system

# 应该看到:
# - istiod (控制平面)
# - ztunnel (DaemonSet, 每节点一个)

# 3. 为命名空间启用Ambient
kubectl label namespace default istio.io/dataplane-mode=ambient

# 4. 验证ztunnel
kubectl logs -n istio-system -l app=ztunnel -f
```

#### Ambient L4授权策略

```yaml
# ambient-l4-authz.yaml

# 1. 默认拒绝策略
apiVersion: security.istio.io/v1beta1
kind: AuthorizationPolicy
metadata:
  name: deny-all
  namespace: default
spec:
  {} # 空spec = 拒绝所有

---
# 2. 允许frontend到backend
apiVersion: security.istio.io/v1beta1
kind: AuthorizationPolicy
metadata:
  name: allow-frontend-to-backend
  namespace: default
spec:
  selector:
    matchLabels:
      app: backend
  
  action: ALLOW
  
  rules:
  - from:
    - source:
        principals: ["cluster.local/ns/default/sa/frontend"]
    to:
    - operation:
        ports: ["8080"]

---
# 3. 允许特定IP范围
apiVersion: security.istio.io/v1beta1
kind: AuthorizationPolicy
metadata:
  name: allow-cidr
spec:
  selector:
    matchLabels:
      app: api-server
  
  action: ALLOW
  
  rules:
  - from:
    - source:
        ipBlocks: ["10.0.0.0/8", "192.168.0.0/16"]
    to:
    - operation:
        ports: ["443"]
```

#### 添加Waypoint代理 (L7)

```bash
# 为命名空间部署Waypoint代理

# 1. 创建Waypoint
kubectl apply -f - <<EOF
apiVersion: gateway.networking.k8s.io/v1beta1
kind: Gateway
metadata:
  name: default-waypoint
  namespace: default
  annotations:
    istio.io/waypoint-for: all  # 为所有流量启用
spec:
  gatewayClassName: istio-waypoint
  listeners:
  - name: mesh
    port: 15008
    protocol: HBONE
EOF

# 2. 查看Waypoint状态
kubectl get gateway default-waypoint -n default

# 3. Waypoint会自动拦截带标签的服务流量
kubectl label service backend istio.io/use-waypoint=default-waypoint
```

#### Ambient L7授权策略

```yaml
# ambient-l7-authz.yaml

# 需要先部署Waypoint代理

# 1. HTTP方法控制
apiVersion: security.istio.io/v1beta1
kind: AuthorizationPolicy
metadata:
  name: http-method-policy
  namespace: default
spec:
  selector:
    matchLabels:
      app: api-server
      istio.io/gateway-name: default-waypoint
  
  action: ALLOW
  
  rules:
  - from:
    - source:
        principals: ["cluster.local/ns/default/sa/frontend"]
    to:
    - operation:
        methods: ["GET", "POST"]
        paths: ["/api/v1/*"]

---
# 2. HTTP头部检查
apiVersion: security.istio.io/v1beta1
kind: AuthorizationPolicy
metadata:
  name: http-header-policy
spec:
  selector:
    matchLabels:
      app: api-server
      istio.io/gateway-name: default-waypoint
  
  action: ALLOW
  
  rules:
  - when:
    - key: request.headers[x-api-key]
      values: ["valid-api-key-123"]
    to:
    - operation:
        paths: ["/api/*"]

---
# 3. JWT验证
apiVersion: security.istio.io/v1beta1
kind: RequestAuthentication
metadata:
  name: jwt-auth
  namespace: default
spec:
  selector:
    matchLabels:
      app: api-server
      istio.io/gateway-name: default-waypoint
  
  jwtRules:
  - issuer: "https://keycloak.example.com/realms/edge-realm"
    jwksUri: "https://keycloak.example.com/realms/edge-realm/protocol/openid-connect/certs"
    audiences:
    - "my-api"

---
apiVersion: security.istio.io/v1beta1
kind: AuthorizationPolicy
metadata:
  name: jwt-authz
spec:
  selector:
    matchLabels:
      app: api-server
      istio.io/gateway-name: default-waypoint
  
  action: ALLOW
  
  rules:
  - from:
    - source:
        requestPrincipals: ["*"]  # 任何有效JWT
    when:
    - key: request.auth.claims[role]
      values: ["admin", "user"]
```

### Calico网络策略

```yaml
# calico-network-policy.yaml

# 1. GlobalNetworkPolicy (集群级别)
apiVersion: projectcalico.org/v3
kind: GlobalNetworkPolicy
metadata:
  name: deny-all-ingress
spec:
  order: 1000  # 低优先级 (数字越大优先级越低)
  types:
  - Ingress
  # 默认拒绝所有入站

---
# 2. NetworkPolicy (命名空间级别)
apiVersion: projectcalico.org/v3
kind: NetworkPolicy
metadata:
  name: allow-frontend-to-backend
  namespace: production
spec:
  order: 100  # 高优先级
  selector: app == "backend"
  types:
  - Ingress
  ingress:
  - action: Allow
    source:
      selector: app == "frontend"
    destination:
      ports:
      - 8080

---
# 3. 服务账号选择器
apiVersion: projectcalico.org/v3
kind: NetworkPolicy
metadata:
  name: allow-by-service-account
  namespace: production
spec:
  selector: app == "api-server"
  types:
  - Ingress
  ingress:
  - action: Allow
    source:
      serviceAccounts:
        names:
        - frontend-sa
        - mobile-sa

---
# 4. 全局拒绝策略 + 白名单
apiVersion: projectcalico.org/v3
kind: GlobalNetworkPolicy
metadata:
  name: default-deny-egress
spec:
  order: 2000
  types:
  - Egress
  egress:
  # 允许DNS
  - action: Allow
    protocol: UDP
    destination:
      ports:
      - 53
  # 允许Kubernetes API
  - action: Allow
    protocol: TCP
    destination:
      nets:
      - 10.96.0.1/32
      ports:
      - 443

---
# 5. 时间窗口策略
apiVersion: projectcalico.org/v3
kind: NetworkPolicy
metadata:
  name: time-based-policy
  namespace: production
spec:
  selector: app == "backup"
  types:
  - Egress
  egress:
  - action: Allow
    destination:
      nets:
      - 192.168.100.0/24  # 备份服务器
    source:
      selector: app == "backup"
    # 只在特定时间允许 (需要额外配置)
```

---

## 数据保护

### 加密存储

#### Kubernetes Secrets加密

```yaml
# kms-encryption-config.yaml
# 使用外部KMS加密Secrets

apiVersion: apiserver.config.k8s.io/v1
kind: EncryptionConfiguration
resources:
- resources:
  - secrets
  providers:
  # 1. 使用AWS KMS
  - kms:
      name: aws-kms
      endpoint: unix:///var/run/kmsplugin/socket.sock
      cachesize: 1000
      timeout: 3s
  
  # 2. 使用HashiCorp Vault
  - kms:
      name: vault-kms
      endpoint: unix:///var/run/kmsplugin/vault.sock
      cachesize: 1000
  
  # 3. 使用AES-CBC (本地密钥)
  - aescbc:
      keys:
      - name: key1
        secret: <base64-encoded-32-byte-key>
  
  # 4. 明文 (用于读取旧数据)
  - identity: {}
```

```bash
# 配置API Server使用加密

# 1. 创建加密配置
vim /etc/kubernetes/enc/encryption-config.yaml

# 2. 修改API Server配置
vim /etc/kubernetes/manifests/kube-apiserver.yaml

# 添加参数:
# --encryption-provider-config=/etc/kubernetes/enc/encryption-config.yaml

# 添加卷挂载:
# - mountPath: /etc/kubernetes/enc
#   name: encryption-config
#   readOnly: true
# volumes:
# - hostPath:
#     path: /etc/kubernetes/enc
#     type: DirectoryOrCreate
#   name: encryption-config

# 3. API Server会自动重启

# 4. 重新加密所有Secrets
kubectl get secrets --all-namespaces -o json | \
  kubectl replace -f -

# 5. 验证加密
ETCDCTL_API=3 etcdctl get /registry/secrets/default/my-secret | hexdump -C
# 应该看到加密的数据,而不是明文
```

#### Sealed Secrets

```bash
# Sealed Secrets - 在Git中安全存储Secrets

# 1. 安装Sealed Secrets Controller
kubectl apply -f https://github.com/bitnami-labs/sealed-secrets/releases/download/v0.24.0/controller.yaml

# 2. 安装kubeseal CLI
wget https://github.com/bitnami-labs/sealed-secrets/releases/download/v0.24.0/kubeseal-0.24.0-linux-amd64.tar.gz
tar -xvzf kubeseal-0.24.0-linux-amd64.tar.gz
sudo mv kubeseal /usr/local/bin/

# 3. 创建普通Secret (临时)
kubectl create secret generic my-secret \
  --from-literal=username=admin \
  --from-literal=password=changeme \
  --dry-run=client -o yaml > secret.yaml

# 4. 加密成SealedSecret
kubeseal -f secret.yaml -w sealedsecret.yaml

# 5. 查看SealedSecret
cat sealedsecret.yaml
```

```yaml
# sealedsecret.yaml示例
apiVersion: bitnami.com/v1alpha1
kind: SealedSecret
metadata:
  name: my-secret
  namespace: default
spec:
  encryptedData:
    username: AgB7xK9m...  # 加密的数据
    password: AgCY3Hf2...
  template:
    metadata:
      name: my-secret
      namespace: default
```

```bash
# 6. 应用SealedSecret (可提交到Git)
kubectl apply -f sealedsecret.yaml

# 7. Controller会自动解密并创建普通Secret
kubectl get secret my-secret -o yaml
```

### External Secrets Operator

```yaml
# external-secrets.yaml
# 从外部密钥管理系统同步Secrets

# 1. 安装ESO
# helm install external-secrets \
#   external-secrets/external-secrets \
#   -n external-secrets-system --create-namespace

# 2. 配置SecretStore (AWS Secrets Manager)
apiVersion: external-secrets.io/v1beta1
kind: SecretStore
metadata:
  name: aws-secrets-manager
  namespace: production
spec:
  provider:
    aws:
      service: SecretsManager
      region: us-west-2
      auth:
        jwt:
          serviceAccountRef:
            name: external-secrets-sa

---
# 3. 创建ExternalSecret
apiVersion: external-secrets.io/v1beta1
kind: ExternalSecret
metadata:
  name: database-credentials
  namespace: production
spec:
  refreshInterval: 1h  # 每小时同步一次
  
  secretStoreRef:
    name: aws-secrets-manager
    kind: SecretStore
  
  target:
    name: database-credentials  # 创建的K8s Secret名称
    creationPolicy: Owner
  
  data:
  - secretKey: username
    remoteRef:
      key: prod/database/credentials
      property: username
  
  - secretKey: password
    remoteRef:
      key: prod/database/credentials
      property: password

---
# 4. 配置HashiCorp Vault
apiVersion: external-secrets.io/v1beta1
kind: SecretStore
metadata:
  name: vault-backend
  namespace: production
spec:
  provider:
    vault:
      server: "https://vault.example.com"
      path: "secret"
      version: "v2"
      auth:
        kubernetes:
          mountPath: "kubernetes"
          role: "external-secrets"
          serviceAccountRef:
            name: external-secrets-sa

---
apiVersion: external-secrets.io/v1beta1
kind: ExternalSecret
metadata:
  name: api-keys
spec:
  refreshInterval: 15m
  secretStoreRef:
    name: vault-backend
    kind: SecretStore
  target:
    name: api-keys
  data:
  - secretKey: api_key
    remoteRef:
      key: /prod/api-keys
      property: stripe_api_key
```

### 数据库加密

```yaml
# TDE (Transparent Data Encryption)

PostgreSQL:
  # 1. 安装pgcrypto扩展
  CREATE EXTENSION pgcrypto;
  
  # 2. 加密列
  CREATE TABLE users (
    id SERIAL PRIMARY KEY,
    username VARCHAR(100),
    email VARCHAR(255),
    ssn BYTEA  -- 加密存储
  );
  
  # 3. 插入加密数据
  INSERT INTO users (username, email, ssn)
  VALUES (
    'john',
    'john@example.com',
    pgp_sym_encrypt('123-45-6789', 'encryption_key')
  );
  
  # 4. 查询解密数据
  SELECT username, pgp_sym_decrypt(ssn, 'encryption_key') AS ssn
  FROM users;

MySQL/MariaDB:
  # 1. 启用at-rest加密
  [mysqld]
  early-plugin-load=keyring_file.so
  keyring_file_data=/var/lib/mysql-keyring/keyring
  
  # 2. 创建加密表空间
  CREATE TABLESPACE encrypted_space
  ADD DATAFILE 'encrypted_space.ibd'
  ENCRYPTION='Y';
  
  # 3. 创建加密表
  CREATE TABLE sensitive_data (
    id INT PRIMARY KEY,
    data VARCHAR(255)
  ) TABLESPACE encrypted_space
    ENCRYPTION='Y';

MongoDB:
  # 启用at-rest加密
  security:
    enableEncryption: true
    encryptionKeyFile: /path/to/keyfile
  
  # 或使用KMIP
  security:
    enableEncryption: true
    kmip:
      serverName: kmip.example.com
      port: 5696
      clientCertificateFile: /path/to/client.pem
```

**当前进度**: 已完成约2,500行,包含:

- 零信任架构概述与核心原则
- 身份与访问管理 (SPIFFE/SPIRE/OAuth2/OIDC/JWT)
- 网络微分段 (Cilium/Istio Ambient/Calico)
- 数据保护 (加密存储/Secrets管理/数据库加密)

**待继续**: 设备信任、监控与响应、实施路线图、实战案例、最佳实践

---

**Edge Security, Zero Trust!** 🔒🛡️✨
