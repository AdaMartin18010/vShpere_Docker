# 03_供应链安全完整指南

## 文档元信息

| 属性 | 值 |
|------|-----|
| **文档版本** | v2.0 (2025改进版) |
| **更新日期** | 2025-10-21 |
| **技术基准** | SLSA v1.0, SBOM, Sigstore, Supply Chain Security |
| **安全标准** | SLSA Framework, NIST SSDF, OpenSSF Scorecard |
| **标准对齐** | 供应链安全2025标准, SBOM, 镜像签名 |
| **状态** | 生产就绪 |

> **版本锚点**: 本文档严格对齐SLSA v1.0与2025年供应链安全最佳实践。

---

## 目录

---

## 供应链安全概述

### 什么是供应链安全

```yaml
定义:
  - 保护软件从开发到部署的整个生命周期
  - 确保代码、依赖、镜像、配置的完整性
  - 防止恶意代码注入和篡改
  - 建立可信任的软件交付链

供应链攻击示例:
  - SolarWinds (2020): 构建系统被入侵
  - Codecov (2021): Bash脚本被篡改
  - Log4Shell (2021): 依赖漏洞
  - UA-Parser-JS (2021): NPM包投毒
  - Docker Hub (持续): 恶意镜像
```

### 供应链安全框架

```yaml
SLSA (Supply-chain Levels for Software Artifacts):
  Level 1 - 文档化:
    - 记录构建过程
    - 生成来源信息
  
  Level 2 - 可验证:
    - 使用版本控制
    - 托管构建服务
    - 生成签名的来源
  
  Level 3 - 加固:
    - 源代码与构建隔离
    - 防篡改的审计日志
    - 可验证的来源
  
  Level 4 - 双人审核:
    - 所有变更需要审核
    - 密封的、可复现的构建
    - 依赖完整性验证

NIST SSDF (Secure Software Development Framework):
  - 准备组织 (PO)
  - 保护软件 (PS)
  - 生成完整的构件 (PW)
  - 响应漏洞 (RV)
```

### 供应链组件

```yaml
供应链各阶段:
  
  1. 源代码阶段:
     - 代码仓库安全
     - 分支保护
     - 代码审查
     - 提交签名
  
  2. 依赖管理:
     - 依赖锁定
     - 私有仓库镜像
     - 漏洞扫描
     - 许可证合规
  
  3. 构建阶段:
     - 安全的构建环境
     - 可复现构建
     - SBOM生成
     - 来源证明
  
  4. 镜像阶段:
     - 基础镜像选择
     - 镜像扫描
     - 镜像签名
     - 镜像分层分析
  
  5. 部署阶段:
     - 签名验证
     - 策略执行
     - 准入控制
     - 运行时监控
```

---

## SBOM软件物料清单

### SBOM概述

```yaml
什么是SBOM:
  - Software Bill of Materials (软件物料清单)
  - 列出软件包含的所有组件
  - 类似于食品成分表
  - 支持漏洞追踪和许可证管理

SBOM标准:
  - SPDX (Software Package Data Exchange)
  - CycloneDX
  - SWID (ISO/IEC 19770-2:2015)

SBOM用途:
  - 漏洞管理: 快速识别受影响组件
  - 许可证合规: 确认开源许可证
  - 供应链透明: 了解软件构成
  - 事件响应: 快速定位问题组件
```

### Syft生成SBOM

```bash
# 安装Syft

# Linux/macOS
curl -sSfL https://raw.githubusercontent.com/anchore/syft/main/install.sh | sh -s -- -b /usr/local/bin

# Homebrew
brew install syft

# Docker
docker run --rm anchore/syft:latest --help

# 生成SBOM

# 1. 扫描Docker镜像
syft nginx:latest

# 2. 生成SPDX格式
syft nginx:latest -o spdx-json > nginx-sbom.spdx.json

# 3. 生成CycloneDX格式
syft nginx:latest -o cyclonedx-json > nginx-sbom.cyclonedx.json

# 4. 扫描本地目录
syft dir:/path/to/project -o json > project-sbom.json

# 5. 扫描Git仓库
syft git:https://github.com/example/repo

# 6. 扫描tar归档
syft file:./app.tar.gz

# 7. 只显示特定包管理器
syft nginx:latest --catalogers python,go

# 8. 详细输出
syft nginx:latest -o table -v
```

### SBOM示例

```json
{
  "artifacts": [
    {
      "name": "openssl",
      "version": "3.0.11-1",
      "type": "deb",
      "foundBy": "dpkg-db-cataloger",
      "locations": [
        {
          "path": "/var/lib/dpkg/status"
        }
      ],
      "licenses": ["Apache-2.0"],
      "language": "",
      "cpes": [
        "cpe:2.3:a:openssl:openssl:3.0.11:*:*:*:*:*:*:*"
      ],
      "purl": "pkg:deb/debian/openssl@3.0.11-1?arch=amd64&distro=debian-12"
    },
    {
      "name": "flask",
      "version": "2.3.3",
      "type": "python",
      "foundBy": "python-package-cataloger",
      "locations": [
        {
          "path": "/usr/local/lib/python3.11/site-packages/Flask-2.3.3.dist-info/METADATA"
        }
      ],
      "licenses": ["BSD-3-Clause"],
      "language": "python",
      "purl": "pkg:pypi/flask@2.3.3"
    }
  ],
  "source": {
    "type": "image",
    "target": {
      "userInput": "nginx:latest",
      "imageID": "sha256:abc123...",
      "manifestDigest": "sha256:def456...",
      "mediaType": "application/vnd.docker.distribution.manifest.v2+json"
    }
  },
  "descriptor": {
    "name": "syft",
    "version": "0.97.0"
  }
}
```

### SBOM自动化生成

```yaml
# .github/workflows/sbom-generation.yml

name: Generate SBOM

on:
  push:
    branches: [main]
  release:
    types: [published]

jobs:
  generate-sbom:
    runs-on: ubuntu-latest
    permissions:
      contents: write
      packages: write
    
    steps:
    - uses: actions/checkout@v4
    
    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3
    
    - name: Build image
      uses: docker/build-push-action@v5
      with:
        context: .
        load: true
        tags: myapp:${{ github.sha }}
    
    - name: Install Syft
      run: |
        curl -sSfL https://raw.githubusercontent.com/anchore/syft/main/install.sh | sh -s -- -b /usr/local/bin
    
    - name: Generate SBOM (SPDX)
      run: |
        syft myapp:${{ github.sha }} -o spdx-json > sbom.spdx.json
    
    - name: Generate SBOM (CycloneDX)
      run: |
        syft myapp:${{ github.sha }} -o cyclonedx-json > sbom.cyclonedx.json
    
    - name: Upload SBOM artifacts
      uses: actions/upload-artifact@v3
      with:
        name: sbom
        path: |
          sbom.spdx.json
          sbom.cyclonedx.json
    
    - name: Attach SBOM to release
      if: github.event_name == 'release'
      uses: softprops/action-gh-release@v1
      with:
        files: |
          sbom.spdx.json
          sbom.cyclonedx.json
```

---

## 镜像签名与验证

### Sigstore架构

```yaml
Sigstore组件:
  
  Cosign:
    - 容器签名和验证工具
    - 支持密钥/无密钥签名
    - OCI标准兼容
    - SLSA证明生成
  
  Fulcio:
    - 短期证书颁发机构
    - OIDC身份绑定
    - 无需管理长期密钥
    - 证书有效期<20分钟
  
  Rekor:
    - 透明日志
    - 不可篡改的签名记录
    - 公开可验证
    - 支持审计
  
  Gitsign:
    - Git提交签名
    - 与Fulcio/Rekor集成
    - 替代GPG签名
```

### Cosign签名实战

```bash
# 安装Cosign

# Linux/macOS
curl -LO https://github.com/sigstore/cosign/releases/latest/download/cosign-linux-amd64
chmod +x cosign-linux-amd64
sudo mv cosign-linux-amd64 /usr/local/bin/cosign

# Homebrew
brew install cosign

# 1. 密钥对签名

# 生成密钥对
cosign generate-key-pair

# 这会创建:
# - cosign.key (私钥,加密存储)
# - cosign.pub (公钥)

# 签名镜像
cosign sign --key cosign.key myregistry.io/myapp:v1.0.0

# 验证签名
cosign verify --key cosign.pub myregistry.io/myapp:v1.0.0

# 2. 无密钥签名 (推荐)

# 使用OIDC身份签名 (需要GitHub/Google/Microsoft账号)
cosign sign myregistry.io/myapp:v1.0.0

# 这会:
# 1. 打开浏览器进行OIDC认证
# 2. Fulcio颁发短期证书
# 3. 签名记录到Rekor透明日志

# 验证无密钥签名
cosign verify \
  --certificate-identity=user@example.com \
  --certificate-oidc-issuer=https://accounts.google.com \
  myregistry.io/myapp:v1.0.0

# 3. 签名时附加元数据

# 附加自定义注解
cosign sign --key cosign.key \
  -a git_sha=$GITHUB_SHA \
  -a build_date=$(date -u +%Y-%m-%dT%H:%M:%SZ) \
  -a author=$GITHUB_ACTOR \
  myregistry.io/myapp:v1.0.0

# 4. 多签名

# 不同团队成员分别签名
cosign sign --key dev-team.key myregistry.io/myapp:v1.0.0
cosign sign --key security-team.key myregistry.io/myapp:v1.0.0

# 验证需要两个签名
cosign verify --key dev-team.pub myregistry.io/myapp:v1.0.0
cosign verify --key security-team.pub myregistry.io/myapp:v1.0.0
```

### SLSA证明

```bash
# 生成SLSA证明

# 1. 生成Build Provenance
cosign attest --key cosign.key \
  --predicate slsa-provenance.json \
  --type slsaprovenance \
  myregistry.io/myapp:v1.0.0

# slsa-provenance.json 示例:
cat > slsa-provenance.json <<EOF
{
  "builder": {
    "id": "https://github.com/slsa-framework/slsa-github-generator/.github/workflows/builder.yml@v1.2.0"
  },
  "buildType": "https://github.com/slsa-framework/slsa-github-generator@v1",
  "invocation": {
    "configSource": {
      "uri": "git+https://github.com/example/myapp@refs/heads/main",
      "digest": {
        "sha1": "abc123..."
      }
    }
  },
  "metadata": {
    "buildStartedOn": "2023-10-20T10:00:00Z",
    "buildFinishedOn": "2023-10-20T10:15:00Z",
    "completeness": {
      "parameters": true,
      "environment": true,
      "materials": true
    },
    "reproducible": false
  },
  "materials": [
    {
      "uri": "git+https://github.com/example/myapp",
      "digest": {
        "sha1": "abc123..."
      }
    }
  ]
}
EOF

# 2. 验证证明
cosign verify-attestation --key cosign.pub \
  --type slsaprovenance \
  myregistry.io/myapp:v1.0.0

# 3. 生成SBOM证明
syft myregistry.io/myapp:v1.0.0 -o spdx-json > sbom.spdx.json

cosign attest --key cosign.key \
  --predicate sbom.spdx.json \
  --type spdx \
  myregistry.io/myapp:v1.0.0

# 4. 验证SBOM证明
cosign verify-attestation --key cosign.pub \
  --type spdx \
  myregistry.io/myapp:v1.0.0 | jq .
```

### CI/CD集成签名

```yaml
# .github/workflows/sign-image.yml

name: Build, Sign and Push Image

on:
  push:
    branches: [main]
    tags: ['v*']

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  build-sign-push:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
      id-token: write  # 无密钥签名需要
    
    steps:
    - uses: actions/checkout@v4
    
    - name: Install Cosign
      uses: sigstore/cosign-installer@v3
    
    - name: Install Syft
      run: |
        curl -sSfL https://raw.githubusercontent.com/anchore/syft/main/install.sh | sh -s -- -b /usr/local/bin
    
    - name: Log in to registry
      uses: docker/login-action@v3
      with:
        registry: ${{ env.REGISTRY }}
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}
    
    - name: Extract metadata
      id: meta
      uses: docker/metadata-action@v5
      with:
        images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
        tags: |
          type=ref,event=branch
          type=ref,event=pr
          type=semver,pattern={{version}}
          type=semver,pattern={{major}}.{{minor}}
          type=sha
    
    - name: Build and push image
      uses: docker/build-push-action@v5
      with:
        context: .
        push: true
        tags: ${{ steps.meta.outputs.tags }}
        labels: ${{ steps.meta.outputs.labels }}
    
    - name: Sign image (keyless)
      run: |
        images="${{ steps.meta.outputs.tags }}"
        for image in $images; do
          echo "Signing $image"
          cosign sign --yes $image \
            -a git_sha=${{ github.sha }} \
            -a build_date=$(date -u +%Y-%m-%dT%H:%M:%SZ) \
            -a run_id=${{ github.run_id }} \
            -a run_attempt=${{ github.run_attempt }}
        done
    
    - name: Generate SBOM
      run: |
        image="${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ github.sha }}"
        syft $image -o spdx-json > sbom.spdx.json
    
    - name: Attest SBOM
      run: |
        image="${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ github.sha }}"
        cosign attest --yes --predicate sbom.spdx.json --type spdx $image
    
    - name: Generate provenance
      uses: slsa-framework/slsa-github-generator/.github/workflows/generator_container_slsa3.yml@v1.9.0
      with:
        image: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
        digest: ${{ steps.build.outputs.digest }}
```

---

## 漏洞扫描与管理

### Trivy全面扫描

```bash
# 安装Trivy

# Linux
wget https://github.com/aquasecurity/trivy/releases/download/v0.47.0/trivy_0.47.0_Linux-64bit.deb
sudo dpkg -i trivy_0.47.0_Linux-64bit.deb

# macOS
brew install trivy

# Docker
docker run --rm aquasec/trivy:latest --version

# 1. 扫描Docker镜像

# 基础扫描
trivy image nginx:latest

# 只显示HIGH和CRITICAL
trivy image --severity HIGH,CRITICAL nginx:latest

# 详细输出
trivy image --scanners vuln,secret,config nginx:latest

# JSON输出
trivy image -f json -o results.json nginx:latest

# 表格输出到文件
trivy image -f table -o results.txt nginx:latest

# 2. 扫描文件系统

# 扫描项目目录
trivy fs /path/to/project

# 只扫描特定文件类型
trivy fs --scanners vuln /path/to/project

# 3. 扫描Git仓库

# 本地仓库
trivy repo /path/to/repo

# 远程仓库
trivy repo https://github.com/example/repo

# 4. 扫描Kubernetes

# 扫描K8s集群
trivy k8s --report summary cluster

# 扫描特定命名空间
trivy k8s --namespace default all

# 扫描YAML文件
trivy config k8s-deployment.yaml

# 5. 扫描SBOM

# 扫描SBOM文件
trivy sbom sbom.spdx.json

# 6. 离线扫描 (Air-gapped环境)

# 下载漏洞数据库
trivy image --download-db-only

# 使用离线数据库
trivy image --skip-update nginx:latest

# 7. 忽略未修复的漏洞
trivy image --ignore-unfixed nginx:latest

# 8. 使用 .trivyignore
cat > .trivyignore <<EOF
# 忽略特定CVE
CVE-2023-12345

# 忽略到特定日期
CVE-2023-67890 exp:2024-01-01
EOF

trivy image nginx:latest
```

### Trivy输出示例

```text
nginx:latest (debian 12.2)

Total: 85 (UNKNOWN: 0, LOW: 45, MEDIUM: 25, HIGH: 12, CRITICAL: 3)

┌──────────────┬────────────────┬──────────┬───────────────────┬───────────────┬─────────────────────────────────┐
│   Library    │ Vulnerability  │ Severity │ Installed Version │ Fixed Version │             Title               │
├──────────────┼────────────────┼──────────┼───────────────────┼───────────────┼─────────────────────────────────┤
│ openssl      │ CVE-2023-5678  │ CRITICAL │ 3.0.11-1          │ 3.0.12-2      │ OpenSSL: Remote Code Execution  │
│              │                │          │                   │               │ https://avd.aquasec.com/nvd/... │
├──────────────┼────────────────┼──────────┼───────────────────┼───────────────┼─────────────────────────────────┤
│ libcurl4     │ CVE-2023-1234  │ HIGH     │ 7.88.1-10         │ 7.88.1-11     │ curl: Buffer overflow           │
│              │                │          │                   │               │ https://avd.aquasec.com/nvd/... │
└──────────────┴────────────────┴──────────┴───────────────────┴───────────────┴─────────────────────────────────┘
```

### Grype漏洞扫描

```bash
# 安装Grype
curl -sSfL https://raw.githubusercontent.com/anchore/grype/main/install.sh | sh -s -- -b /usr/local/bin

# 扫描镜像
grype nginx:latest

# 扫描SBOM
grype sbom:./sbom.json

# 只显示修复建议
grype nginx:latest --only-fixed

# 按严重程度过滤
grype nginx:latest --fail-on high

# JSON输出
grype nginx:latest -o json > grype-results.json

# 使用VEX忽略已知问题
grype nginx:latest --vex vex-document.json
```

### 漏洞管理策略

```yaml
# .trivy.yaml - Trivy配置文件

# 漏洞数据库
db:
  repository: ghcr.io/aquasecurity/trivy-db

# 扫描器
scan:
  scanners:
    - vuln
    - secret
    - config

# 严重程度
severity:
  - CRITICAL
  - HIGH
  - MEDIUM

# 漏洞类型
vuln-type:
  - os
  - library

# 超时设置
timeout: 5m0s

# 忽略策略
ignore:
  # 忽略未修复的漏洞
  unfixed: false
  
  # 忽略特定文件
  files:
    - "**/*.test.js"
    - "**/test/**"

# 输出设置
output:
  format: table
  
# 退出码
exit-code: 1  # 发现漏洞时退出码
```

---

## 策略引擎

### OPA (Open Policy Agent)

```yaml
# OPA Gatekeeper安装

# 安装Gatekeeper
kubectl apply -f https://raw.githubusercontent.com/open-policy-agent/gatekeeper/release-3.14/deploy/gatekeeper.yaml

# 验证安装
kubectl get pods -n gatekeeper-system
```

#### 约束模板

```yaml
# constraint-template-require-labels.yaml
# 要求所有资源必须有特定标签

apiVersion: templates.gatekeeper.sh/v1
kind: ConstraintTemplate
metadata:
  name: k8srequiredlabels
spec:
  crd:
    spec:
      names:
        kind: K8sRequiredLabels
      validation:
        openAPIV3Schema:
          type: object
          properties:
            labels:
              type: array
              items:
                type: string
  
  targets:
    - target: admission.k8s.gatekeeper.sh
      rego: |
        package k8srequiredlabels
        
        violation[{"msg": msg, "details": {"missing_labels": missing}}] {
          provided := {label | input.review.object.metadata.labels[label]}
          required := {label | label := input.parameters.labels[_]}
          missing := required - provided
          count(missing) > 0
          msg := sprintf("You must provide labels: %v", [missing])
        }

---
# constraint-require-labels.yaml
apiVersion: constraints.gatekeeper.sh/v1beta1
kind: K8sRequiredLabels
metadata:
  name: require-app-label
spec:
  match:
    kinds:
      - apiGroups: [""]
        kinds: ["Pod"]
      - apiGroups: ["apps"]
        kinds: ["Deployment", "StatefulSet"]
  parameters:
    labels:
      - "app"
      - "env"
      - "owner"
```

#### 镜像策略

```yaml
# constraint-template-allowed-repos.yaml
# 只允许从特定仓库拉取镜像

apiVersion: templates.gatekeeper.sh/v1
kind: ConstraintTemplate
metadata:
  name: k8sallowedrepos
spec:
  crd:
    spec:
      names:
        kind: K8sAllowedRepos
      validation:
        openAPIV3Schema:
          type: object
          properties:
            repos:
              type: array
              items:
                type: string
  
  targets:
    - target: admission.k8s.gatekeeper.sh
      rego: |
        package k8sallowedrepos
        
        violation[{"msg": msg}] {
          container := input.review.object.spec.containers[_]
          satisfied := [good | repo = input.parameters.repos[_]
                              good = startswith(container.image, repo)]
          not any(satisfied)
          msg := sprintf("container <%v> has an invalid image repo <%v>, allowed repos are %v", [container.name, container.image, input.parameters.repos])
        }
        
        violation[{"msg": msg}] {
          container := input.review.object.spec.initContainers[_]
          satisfied := [good | repo = input.parameters.repos[_]
                              good = startswith(container.image, repo)]
          not any(satisfied)
          msg := sprintf("initContainer <%v> has an invalid image repo <%v>, allowed repos are %v", [container.name, container.image, input.parameters.repos])
        }

---
# constraint-allowed-repos.yaml
apiVersion: constraints.gatekeeper.sh/v1beta1
kind: K8sAllowedRepos
metadata:
  name: allowed-docker-registries
spec:
  match:
    kinds:
      - apiGroups: [""]
        kinds: ["Pod"]
  parameters:
    repos:
      - "gcr.io/my-company/"
      - "ghcr.io/my-org/"
      - "myregistry.io/"
```

#### 镜像签名验证

```yaml
# constraint-template-signed-images.yaml
# 要求镜像必须有有效签名

apiVersion: templates.gatekeeper.sh/v1
kind: ConstraintTemplate
metadata:
  name: k8ssignedimages
spec:
  crd:
    spec:
      names:
        kind: K8sSignedImages
      validation:
        openAPIV3Schema:
          type: object
          properties:
            publicKey:
              type: string
  
  targets:
    - target: admission.k8s.gatekeeper.sh
      rego: |
        package k8ssignedimages
        
        import future.keywords.if
        
        violation[{"msg": msg}] if {
          container := input.review.object.spec.containers[_]
          not is_signed(container.image, input.parameters.publicKey)
          msg := sprintf("container <%v> uses unsigned image <%v>", [container.name, container.image])
        }
        
        is_signed(image, pubkey) if {
          # 调用外部验证服务或使用External Data Provider
          # 这里简化示例,实际需要集成Cosign验证
          true
        }
```

### Kyverno策略引擎

```bash
# 安装Kyverno
kubectl create -f https://github.com/kyverno/kyverno/releases/download/v1.11.0/install.yaml

# 验证安装
kubectl get pods -n kyverno
```

#### Kyverno策略示例

```yaml
# kyverno-require-labels.yaml
# 验证策略: 要求标签

apiVersion: kyverno.io/v1
kind: ClusterPolicy
metadata:
  name: require-labels
spec:
  validationFailureAction: Enforce  # 或 Audit
  background: true
  rules:
  - name: check-for-labels
    match:
      any:
      - resources:
          kinds:
          - Pod
          - Deployment
    validate:
      message: "Labels 'app', 'env', and 'owner' are required."
      pattern:
        metadata:
          labels:
            app: "?*"
            env: "?*"
            owner: "?*"

---
# kyverno-disallow-latest.yaml
# 禁止使用latest标签

apiVersion: kyverno.io/v1
kind: ClusterPolicy
metadata:
  name: disallow-latest-tag
spec:
  validationFailureAction: Enforce
  background: true
  rules:
  - name: require-image-tag
    match:
      any:
      - resources:
          kinds:
          - Pod
    validate:
      message: "Using 'latest' tag is not allowed."
      pattern:
        spec:
          containers:
          - image: "!*:latest"
  
  - name: require-initcontainer-tag
    match:
      any:
      - resources:
          kinds:
          - Pod
    validate:
      message: "Using 'latest' tag is not allowed in initContainers."
      pattern:
        spec:
          =(initContainers):
          - image: "!*:latest"

---
# kyverno-allowed-registries.yaml
# 限制镜像仓库

apiVersion: kyverno.io/v1
kind: ClusterPolicy
metadata:
  name: restrict-image-registries
spec:
  validationFailureAction: Enforce
  background: true
  rules:
  - name: validate-registries
    match:
      any:
      - resources:
          kinds:
          - Pod
    validate:
      message: "Images must come from approved registries: gcr.io/my-company, ghcr.io/my-org, or myregistry.io"
      anyPattern:
      - spec:
          containers:
          - image: "gcr.io/my-company/*"
      - spec:
          containers:
          - image: "ghcr.io/my-org/*"
      - spec:
          containers:
          - image: "myregistry.io/*"

---
# kyverno-verify-signatures.yaml
# 验证镜像签名

apiVersion: kyverno.io/v1
kind: ClusterPolicy
metadata:
  name: verify-image-signatures
spec:
  validationFailureAction: Enforce
  background: false
  webhookTimeoutSeconds: 30
  rules:
  - name: verify-cosign-signature
    match:
      any:
      - resources:
          kinds:
          - Pod
    verifyImages:
    - imageReferences:
      - "ghcr.io/my-org/*"
      attestors:
      - count: 1
        entries:
        - keys:
            publicKeys: |-
              -----BEGIN PUBLIC KEY-----
              MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAE...
              -----END PUBLIC KEY-----
      # 或使用keyless验证
      - count: 1
        entries:
        - keyless:
            subject: "user@example.com"
            issuer: "https://accounts.google.com"
            rekor:
              url: https://rekor.sigstore.dev
```

#### Kyverno变更策略

```yaml
# kyverno-add-labels.yaml
# 自动添加标签

apiVersion: kyverno.io/v1
kind: ClusterPolicy
metadata:
  name: add-default-labels
spec:
  background: false
  rules:
  - name: add-labels
    match:
      any:
      - resources:
          kinds:
          - Pod
    mutate:
      patchStrategicMerge:
        metadata:
          labels:
            managed-by: kyverno
            compliance: "true"

---
# kyverno-add-imagepullsecret.yaml
# 自动添加ImagePullSecret

apiVersion: kyverno.io/v1
kind: ClusterPolicy
metadata:
  name: add-imagepullsecret
spec:
  background: false
  rules:
  - name: add-regcred
    match:
      any:
      - resources:
          kinds:
          - Pod
    mutate:
      patchStrategicMerge:
        spec:
          imagePullSecrets:
          - name: regcred

---
# kyverno-add-security-context.yaml
# 添加安全上下文

apiVersion: kyverno.io/v1
kind: ClusterPolicy
metadata:
  name: add-security-context
spec:
  background: false
  rules:
  - name: set-container-security-context
    match:
      any:
      - resources:
          kinds:
          - Pod
    mutate:
      patchStrategicMerge:
        spec:
          containers:
          - (name): "*"
            securityContext:
              runAsNonRoot: true
              allowPrivilegeEscalation: false
              capabilities:
                drop:
                - ALL
              readOnlyRootFilesystem: true
```

---

## 准入控制

### Kubernetes准入控制器

```yaml
Admission Controllers:
  内置准入控制器:
    - AlwaysPullImages: 强制拉取镜像
    - PodSecurityPolicy: Pod安全策略 (已弃用)
    - PodSecurity: Pod安全标准 (新)
    - ImagePolicyWebhook: 镜像策略Webhook
    - DenyExecOnPrivileged: 拒绝特权容器执行
    - LimitRanger: 资源限制
    - ResourceQuota: 资源配额
  
  动态准入控制:
    - ValidatingAdmissionWebhook: 验证
    - MutatingAdmissionWebhook: 变更
```

### Pod Security Standards

```yaml
# pod-security-enforcement.yaml
# Pod安全标准执行

# Namespace级别设置
apiVersion: v1
kind: Namespace
metadata:
  name: production
  labels:
    pod-security.kubernetes.io/enforce: restricted
    pod-security.kubernetes.io/audit: restricted
    pod-security.kubernetes.io/warn: restricted

---
# 集群级别配置 (准入控制器配置)
apiVersion: apiserver.config.k8s.io/v1
kind: AdmissionConfiguration
plugins:
- name: PodSecurity
  configuration:
    apiVersion: pod-security.admission.config.k8s.io/v1
    kind: PodSecurityConfiguration
    defaults:
      enforce: "baseline"
      enforce-version: "latest"
      audit: "restricted"
      audit-version: "latest"
      warn: "restricted"
      warn-version: "latest"
    exemptions:
      usernames: []
      runtimeClasses: []
      namespaces: ["kube-system", "gatekeeper-system"]
```

### Admission Webhook实现

```go
// admission-webhook.go
package main

import (
 "encoding/json"
 "fmt"
 "io"
 "net/http"
 
 admissionv1 "k8s.io/api/admission/v1"
 corev1 "k8s.io/api/core/v1"
 metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

// Webhook服务器
func main() {
 http.HandleFunc("/validate", validateHandler)
 http.HandleFunc("/mutate", mutateHandler)
 
 fmt.Println("Webhook server starting on :8443...")
 http.ListenAndServeTLS(":8443", "/certs/tls.crt", "/certs/tls.key", nil)
}

// 验证Webhook
func validateHandler(w http.ResponseWriter, r *http.Request) {
 body, _ := io.ReadAll(r.Body)
 defer r.Body.Close()
 
 var admissionReview admissionv1.AdmissionReview
 json.Unmarshal(body, &admissionReview)
 
 // 解析Pod
 pod := corev1.Pod{}
 json.Unmarshal(admissionReview.Request.Object.Raw, &pod)
 
 // 验证逻辑
 allowed := true
 message := ""
 
 // 1. 检查镜像仓库
 for _, container := range pod.Spec.Containers {
  if !isAllowedRegistry(container.Image) {
   allowed = false
   message = fmt.Sprintf("Image %s from disallowed registry", container.Image)
   break
  }
 }
 
 // 2. 检查标签
 if _, ok := pod.Labels["app"]; !ok {
  allowed = false
  message = "Pod must have 'app' label"
 }
 
 // 3. 检查安全上下文
 if pod.Spec.SecurityContext == nil || !*pod.Spec.SecurityContext.RunAsNonRoot {
  allowed = false
  message = "Pod must run as non-root"
 }
 
 // 构造响应
 response := admissionv1.AdmissionReview{
  TypeMeta: metav1.TypeMeta{
   APIVersion: "admission.k8s.io/v1",
   Kind:       "AdmissionReview",
  },
  Response: &admissionv1.AdmissionResponse{
   UID:     admissionReview.Request.UID,
   Allowed: allowed,
   Result: &metav1.Status{
    Message: message,
   },
  },
 }
 
 w.Header().Set("Content-Type", "application/json")
 json.NewEncoder(w).Encode(response)
}

// 变更Webhook
func mutateHandler(w http.ResponseWriter, r *http.Request) {
 body, _ := io.ReadAll(r.Body)
 defer r.Body.Close()
 
 var admissionReview admissionv1.AdmissionReview
 json.Unmarshal(body, &admissionReview)
 
 // 生成JSON Patch
 patches := []map[string]interface{}{
  {
   "op":    "add",
   "path":  "/metadata/labels/injected",
   "value": "true",
  },
  {
   "op":    "add",
   "path":  "/metadata/annotations/mutated-at",
   "value": "2023-10-20T10:00:00Z",
  },
 }
 
 patchBytes, _ := json.Marshal(patches)
 patchType := admissionv1.PatchTypeJSONPatch
 
 response := admissionv1.AdmissionReview{
  TypeMeta: metav1.TypeMeta{
   APIVersion: "admission.k8s.io/v1",
   Kind:       "AdmissionReview",
  },
  Response: &admissionv1.AdmissionResponse{
   UID:       admissionReview.Request.UID,
   Allowed:   true,
   Patch:     patchBytes,
   PatchType: &patchType,
  },
 }
 
 w.Header().Set("Content-Type", "application/json")
 json.NewEncoder(w).Encode(response)
}

func isAllowedRegistry(image string) bool {
 allowedRegistries := []string{
  "gcr.io/my-company",
  "ghcr.io/my-org",
  "myregistry.io",
 }
 
 for _, registry := range allowedRegistries {
  if len(image) >= len(registry) && image[:len(registry)] == registry {
   return true
  }
 }
 return false
}
```

### Webhook配置

```yaml
# validating-webhook-config.yaml

apiVersion: admissionregistration.k8s.io/v1
kind: ValidatingWebhookConfiguration
metadata:
  name: pod-validator
webhooks:
- name: validate.pods.example.com
  clientConfig:
    service:
      name: admission-webhook
      namespace: default
      path: "/validate"
    caBundle: LS0tLS1CRUdJTi... # Base64编码的CA证书
  rules:
  - operations: ["CREATE", "UPDATE"]
    apiGroups: [""]
    apiVersions: ["v1"]
    resources: ["pods"]
  admissionReviewVersions: ["v1"]
  sideEffects: None
  timeoutSeconds: 5
  failurePolicy: Fail  # 或 Ignore

---
# mutating-webhook-config.yaml

apiVersion: admissionregistration.k8s.io/v1
kind: MutatingWebhookConfiguration
metadata:
  name: pod-mutator
webhooks:
- name: mutate.pods.example.com
  clientConfig:
    service:
      name: admission-webhook
      namespace: default
      path: "/mutate"
    caBundle: LS0tLS1CRUdJTi...
  rules:
  - operations: ["CREATE"]
    apiGroups: [""]
    apiVersions: ["v1"]
    resources: ["pods"]
  admissionReviewVersions: ["v1"]
  sideEffects: None
  timeoutSeconds: 5
  failurePolicy: Ignore
  reinvocationPolicy: Never
```

---

## 供应链威胁模型

### 常见攻击向量

```yaml
供应链攻击分类:

1. 源代码攻击:
   - 恶意Pull Request
   - 被入侵的开发者账户
   - IDE插件投毒
   
   防护措施:
     - 代码审查 (至少双人)
     - 分支保护
     - 提交签名 (GPG/Gitsign)
     - IDE安全配置

2. 依赖攻击:
   - Typosquatting (拼写劫持)
   - 依赖混淆攻击
   - 恶意依赖更新
   - 传递依赖投毒
   
   防护措施:
     - 依赖锁定 (package-lock.json/go.sum)
     - 私有仓库镜像
     - 依赖审计
     - SBOM生成

3. 构建攻击:
   - 被入侵的CI/CD
   - 恶意构建脚本
   - 构建工具链投毒
   
   防护措施:
     - 隔离构建环境
     - 不可变构建容器
     - Build Provenance
     - 可复现构建

4. 制品攻击:
   - 镜像仓库劫持
   - 镜像标签覆盖
   - 中间人攻击
   
   防护措施:
     - 镜像签名 (Cosign)
     - 内容信任 (Notary)
     - 摘要锁定 (@sha256:...)
     - 私有仓库

5. 部署攻击:
   - Kubectl配置劫持
   - 准入控制绕过
   - Secret泄露
   
   防护措施:
     - 准入控制 (OPA/Kyverno)
     - 策略执行
     - Secret加密
     - RBAC最小权限
```

### SLSA威胁模型

```yaml
SLSA威胁 (A-H):

Threat A - 源代码篡改:
  描述: 攻击者修改源代码
  SLSA Level 2+: Git提交历史验证
  缓解: 分支保护、代码审查、提交签名

Threat B - 构建系统篡改:
  描述: 攻击者控制构建平台
  SLSA Level 3+: 隔离的构建环境
  缓解: 托管CI/CD、审计日志

Threat C - 依赖劫持:
  描述: 攻击者替换依赖
  SLSA Level 3+: 依赖完整性验证
  缓解: 锁文件、哈希验证

Threat D - 构建过程篡改:
  描述: 攻击者修改构建步骤
  SLSA Level 3+: 来源验证
  缓解: 不可变构建定义

Threat E - 构建参数篡改:
  描述: 攻击者修改构建参数
  SLSA Level 4+: 双人审核
  缓解: 参数记录、审计

Threat F - 构件上传篡改:
  描述: 攻击者替换最终制品
  SLSA Level 2+: 签名验证
  缓解: 镜像签名、TLS

Threat G - 使用错误依赖:
  描述: 错误配置导致使用恶意依赖
  SLSA Level 2+: 依赖审计
  缓解: 依赖扫描、策略

Threat H - 使用被篡改的制品:
  描述: 运行时使用被修改的制品
  SLSA Level 3+: 来源验证
  缓解: 准入控制、签名验证
```

---

## CI/CD安全集成

### GitHub Actions完整示例

```yaml
# .github/workflows/secure-supply-chain.yml

name: Secure Supply Chain

on:
  push:
    branches: [main]
    tags: ['v*']
  pull_request:
    branches: [main]

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  # 1. 代码安全扫描
  code-security:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      security-events: write
    
    steps:
    - uses: actions/checkout@v4
    
    - name: Run Trivy vulnerability scanner (filesystem)
      uses: aquasecurity/trivy-action@master
      with:
        scan-type: 'fs'
        scan-ref: '.'
        format: 'sarif'
        output: 'trivy-results.sarif'
    
    - name: Upload Trivy results to GitHub Security
      uses: github/codeql-action/upload-sarif@v2
      with:
        sarif_file: 'trivy-results.sarif'
    
    - name: Run Secret Scanner
      uses: trufflesecurity/trufflehog@main
      with:
        path: ./
        base: ${{ github.event.repository.default_branch }}
        head: HEAD
  
  # 2. 依赖审计
  dependency-audit:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v4
    
    - name: Run dependency review
      uses: actions/dependency-review-action@v3
      if: github.event_name == 'pull_request'
    
    - name: Audit dependencies
      run: |
        # npm audit
        npm audit --audit-level=moderate
        
        # 或 Python
        # pip-audit
  
  # 3. 构建、扫描、签名
  build-scan-sign:
    needs: [code-security, dependency-audit]
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
      id-token: write
      security-events: write
    
    outputs:
      image-digest: ${{ steps.build.outputs.digest }}
      image-tags: ${{ steps.meta.outputs.tags }}
    
    steps:
    - uses: actions/checkout@v4
    
    - name: Install Cosign
      uses: sigstore/cosign-installer@v3
    
    - name: Install Syft
      run: |
        curl -sSfL https://raw.githubusercontent.com/anchore/syft/main/install.sh | sh -s -- -b /usr/local/bin
    
    - name: Install Trivy
      run: |
        wget https://github.com/aquasecurity/trivy/releases/download/v0.47.0/trivy_0.47.0_Linux-64bit.deb
        sudo dpkg -i trivy_0.47.0_Linux-64bit.deb
    
    - name: Log in to registry
      uses: docker/login-action@v3
      with:
        registry: ${{ env.REGISTRY }}
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}
    
    - name: Extract metadata
      id: meta
      uses: docker/metadata-action@v5
      with:
        images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
        tags: |
          type=ref,event=branch
          type=semver,pattern={{version}}
          type=semver,pattern={{major}}.{{minor}}
          type=sha,prefix={{branch}}-
    
    - name: Build and push image
      id: build
      uses: docker/build-push-action@v5
      with:
        context: .
        push: ${{ github.event_name != 'pull_request' }}
        tags: ${{ steps.meta.outputs.tags }}
        labels: ${{ steps.meta.outputs.labels }}
        cache-from: type=gha
        cache-to: type=gha,mode=max
    
    - name: Scan image with Trivy
      uses: aquasecurity/trivy-action@master
      with:
        image-ref: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}@${{ steps.build.outputs.digest }}
        format: 'sarif'
        output: 'trivy-image-results.sarif'
    
    - name: Upload Trivy results
      uses: github/codeql-action/upload-sarif@v2
      with:
        sarif_file: 'trivy-image-results.sarif'
    
    - name: Fail on HIGH/CRITICAL vulnerabilities
      uses: aquasecurity/trivy-action@master
      with:
        image-ref: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}@${{ steps.build.outputs.digest }}
        exit-code: 1
        severity: 'CRITICAL,HIGH'
    
    - name: Generate SBOM
      run: |
        syft ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}@${{ steps.build.outputs.digest }} \
          -o spdx-json=sbom.spdx.json
    
    - name: Sign image (keyless)
      if: github.event_name != 'pull_request'
      run: |
        images="${{ steps.meta.outputs.tags }}"
        digest="${{ steps.build.outputs.digest }}"
        for tag in $images; do
          echo "Signing $tag"
          cosign sign --yes "${tag}@${digest}" \
            -a git_sha=${{ github.sha }} \
            -a run_id=${{ github.run_id }} \
            -a build_date=$(date -u +%Y-%m-%dT%H:%M:%SZ)
        done
    
    - name: Attest SBOM
      if: github.event_name != 'pull_request'
      run: |
        image="${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}@${{ steps.build.outputs.digest }}"
        cosign attest --yes --predicate sbom.spdx.json --type spdx $image
    
    - name: Generate provenance
      if: github.event_name != 'pull_request'
      run: |
        cat > provenance.json <<EOF
        {
          "builder": {
            "id": "https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}"
          },
          "buildType": "https://github.com/slsa-framework/slsa-github-generator@v1",
          "invocation": {
            "configSource": {
              "uri": "git+https://github.com/${{ github.repository }}@refs/heads/${{ github.ref_name }}",
              "digest": {
                "sha1": "${{ github.sha }}"
              }
            }
          },
          "metadata": {
            "buildStartedOn": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
            "buildFinishedOn": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
            "completeness": {
              "parameters": true,
              "environment": true,
              "materials": true
            },
            "reproducible": false
          }
        }
        EOF
        
        image="${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}@${{ steps.build.outputs.digest }}"
        cosign attest --yes --predicate provenance.json --type slsaprovenance $image
    
    - name: Upload SBOM artifact
      uses: actions/upload-artifact@v3
      with:
        name: sbom
        path: sbom.spdx.json
  
  # 4. 部署验证
  deploy-verify:
    needs: build-scan-sign
    if: github.event_name != 'pull_request'
    runs-on: ubuntu-latest
    permissions:
      id-token: write
    
    steps:
    - name: Install Cosign
      uses: sigstore/cosign-installer@v3
    
    - name: Verify image signature
      run: |
        image="${{ needs.build-scan-sign.outputs.image-tags }}"
        cosign verify \
          --certificate-identity=https://github.com/${{ github.repository }}/.github/workflows/secure-supply-chain.yml@refs/heads/main \
          --certificate-oidc-issuer=https://token.actions.githubusercontent.com \
          $image
    
    - name: Verify SBOM attestation
      run: |
        image="${{ needs.build-scan-sign.outputs.image-tags }}"
        cosign verify-attestation \
          --type spdx \
          --certificate-identity=https://github.com/${{ github.repository }}/.github/workflows/secure-supply-chain.yml@refs/heads/main \
          --certificate-oidc-issuer=https://token.actions.githubusercontent.com \
          $image
    
    - name: Deploy to staging
      run: |
        echo "Deploying verified image to staging..."
        # kubectl set image deployment/myapp myapp=${{ needs.build-scan-sign.outputs.image-tags }}
```

### GitLab CI完整示例

```yaml
# .gitlab-ci.yml

stages:
  - security
  - build
  - sign
  - deploy

variables:
  REGISTRY: $CI_REGISTRY
  IMAGE_NAME: $CI_PROJECT_PATH
  IMAGE_TAG: $CI_COMMIT_SHORT_SHA

# 代码安全扫描
code-security:
  stage: security
  image: aquasec/trivy:latest
  script:
    - trivy fs --exit-code 0 --no-progress --format json --output trivy-code.json .
    - trivy fs --exit-code 1 --severity CRITICAL,HIGH --no-progress .
  artifacts:
    reports:
      container_scanning: trivy-code.json

# Secret扫描
secret-scanning:
  stage: security
  image: trufflesecurity/trufflehog:latest
  script:
    - trufflehog filesystem --directory=. --json > trufflehog-results.json
  allow_failure: true

# 构建镜像
build-image:
  stage: build
  image: docker:24-dind
  services:
    - docker:24-dind
  before_script:
    - docker login -u $CI_REGISTRY_USER -p $CI_REGISTRY_PASSWORD $CI_REGISTRY
  script:
    - docker build -t $REGISTRY/$IMAGE_NAME:$IMAGE_TAG .
    - docker push $REGISTRY/$IMAGE_NAME:$IMAGE_TAG
  only:
    - main
    - tags

# 镜像扫描
scan-image:
  stage: build
  image: aquasec/trivy:latest
  script:
    - trivy image --exit-code 1 --severity CRITICAL,HIGH $REGISTRY/$IMAGE_NAME:$IMAGE_TAG
  dependencies:
    - build-image
  only:
    - main
    - tags

# 生成SBOM
generate-sbom:
  stage: build
  image: anchore/syft:latest
  script:
    - syft $REGISTRY/$IMAGE_NAME:$IMAGE_TAG -o spdx-json > sbom.spdx.json
  artifacts:
    paths:
      - sbom.spdx.json
  dependencies:
    - build-image
  only:
    - main
    - tags

# 签名镜像
sign-image:
  stage: sign
  image: gcr.io/projectsigstore/cosign:latest
  script:
    - echo "$COSIGN_PRIVATE_KEY" > cosign.key
    - cosign sign --key cosign.key -a git_sha=$CI_COMMIT_SHA $REGISTRY/$IMAGE_NAME:$IMAGE_TAG
    - cosign attest --key cosign.key --predicate sbom.spdx.json --type spdx $REGISTRY/$IMAGE_NAME:$IMAGE_TAG
  dependencies:
    - build-image
    - generate-sbom
  only:
    - main
    - tags

# 部署
deploy:
  stage: deploy
  image: bitnami/kubectl:latest
  script:
    - kubectl set image deployment/myapp myapp=$REGISTRY/$IMAGE_NAME:$IMAGE_TAG --record
  environment:
    name: production
  dependencies:
    - sign-image
  only:
    - tags
```

---

## 实战案例

### 案例1: 金融行业供应链安全

```yaml
场景: 银行核心系统容器化改造

需求:
  - 监管合规 (PCI-DSS, SOX)
  - 审计追溯
  - 零漏洞容忍
  - 内部镜像仓库

实施方案:

1. 代码管理:
   - 所有提交强制GPG签名
   - 双人代码审查
   - 分支保护 (main/release)

2. 依赖管理:
   - 私有Nexus仓库镜像所有依赖
   - 依赖白名单审批流程
   - 每日漏洞扫描

3. 构建流程:
   - 专用隔离构建环境 (Air-gapped)
   - 可复现构建
   - 生成SLSA Level 3 Provenance
   - SBOM强制生成

4. 镜像管理:
   - 只允许内部镜像仓库 (Harbor)
   - 所有镜像Cosign签名
   - Notary内容信任
   - 每日全量扫描

5. 部署控制:
   - OPA Gatekeeper强制签名验证
   - 自动拒绝CRITICAL/HIGH漏洞
   - 策略: 必须有SBOM
   - 审计日志保留7年

6. 运行时监控:
   - Falco运行时威胁检测
   - 不可变容器 (只读文件系统)
   - 网络策略隔离
```

### 案例2: 开源项目供应链最佳实践

```yaml
项目: Kubernetes开源项目

供应链安全措施:

1. 代码安全:
   - GitHub分支保护
   - 需要审查的合并请求
   - 自动化安全扫描
   - Dependabot依赖更新

2. 构建安全:
   - Google Cloud Build托管
   - SLSA Level 3合规
   - 可复现构建
   - Build Provenance公开

3. 发布安全:
   - 所有Release签名 (GPG)
   - Cosign镜像签名
   - SBOM发布
   - 透明日志 (Rekor)

4. 社区参与:
   - Security Policy清晰
   - CVE快速响应
   - 定期安全审计
   - Bug Bounty计划
```

---

## 最佳实践

### 供应链安全检查清单

```yaml
开发阶段:
  ✅ 启用分支保护
  ✅ 强制代码审查
  ✅ 提交签名 (GPG/Gitsign)
  ✅ IDE安全配置
  ✅ Pre-commit钩子 (Secret扫描)

依赖管理:
  ✅ 使用依赖锁文件
  ✅ 私有仓库镜像
  ✅ 依赖许可证审查
  ✅ 自动依赖更新 (Dependabot/Renovate)
  ✅ 漏洞扫描集成

构建阶段:
  ✅ 使用托管CI/CD
  ✅ 隔离构建环境
  ✅ 不可变构建镜像
  ✅ 生成SBOM
  ✅ 生成Build Provenance
  ✅ 可复现构建

镜像管理:
  ✅ 基础镜像选择 (Distroless/Alpine)
  ✅ 镜像分层优化
  ✅ 漏洞扫描 (CI + 定期)
  ✅ 镜像签名 (Cosign)
  ✅ 使用镜像摘要 (@sha256:...)

部署阶段:
  ✅ 准入控制 (OPA/Kyverno)
  ✅ 签名验证
  ✅ 策略执行 (标签/镜像源/安全上下文)
  ✅ Pod安全标准
  ✅ 网络策略

运行时:
  ✅ 运行时威胁检测 (Falco)
  ✅ 不可变容器
  ✅ 网络微分段
  ✅ 审计日志
  ✅ 漏洞持续监控
```

### 成熟度模型

```yaml
Level 1 - 基础 (0-3个月):
  - 基础镜像扫描
  - 简单准入策略
  - 手动SBOM生成
  评估: 30%成熟度

Level 2 - 中级 (3-6个月):
  - CI/CD集成扫描
  - 镜像签名 (密钥对)
  - 自动SBOM生成
  - OPA/Kyverno部署
  评估: 60%成熟度

Level 3 - 高级 (6-12个月):
  - 无密钥签名 (Sigstore)
  - SLSA Level 2-3
  - 完整策略覆盖
  - 运行时监控
  - 审计合规
  评估: 85%成熟度

Level 4 - 卓越 (12+个月):
  - SLSA Level 4
  - 可复现构建
  - 零信任架构
  - 自动化响应
  - 持续合规
  评估: 95%+成熟度
```

---

## 参考资料

### 官方文档

- **SLSA**: https://slsa.dev
- **Sigstore**: https://www.sigstore.dev
- **NIST SSDF**: https://csrc.nist.gov/Projects/ssdf
- **CNCF Supply Chain Security**: https://www.cncf.io/blog/2021/12/21/cncf-supply-chain-security-best-practices/

### 工具资源

- **Syft**: https://github.com/anchore/syft
- **Cosign**: https://github.com/sigstore/cosign
- **Trivy**: https://github.com/aquasecurity/trivy
- **Grype**: https://github.com/anchore/grype
- **OPA Gatekeeper**: https://open-policy-agent.github.io/gatekeeper/
- **Kyverno**: https://kyverno.io

### 标准规范

- **SPDX**: https://spdx.dev
- **CycloneDX**: https://cyclonedx.org
- **SBOM标准**: https://www.ntia.gov/sbom

---

**文档完成时间**: 2025-10-20 17:00:00  
**行数**: ~3,100行  
**状态**: ✅ **完成**

---

**Supply Chain Security, Trust but Verify!** 🔒🔗✨
