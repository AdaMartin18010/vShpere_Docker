# CI/CD流水线 (2025)

**更新日期**: 2025-10-20  
**版本**: v2.0  
**状态**: ✅ **2025标准对齐完成**

---

## 目录

- [CI/CD流水线 (2025)](#cicd流水线-2025)
  - [目录](#目录)
  - [云原生CI/CD概述](#云原生cicd概述)
    - [传统 vs 云原生 CI/CD](#传统-vs-云原生-cicd)
    - [2025 CI/CD趋势](#2025-cicd趋势)
  - [GitHub Actions (2025)](#github-actions-2025)
    - [GitHub Actions概述](#github-actions概述)
    - [工作流基础](#工作流基础)
    - [容器镜像构建与推送](#容器镜像构建与推送)
    - [GitHub Actions 2025新特性](#github-actions-2025新特性)
      - [1. Larger Runners (更大的Runner)](#1-larger-runners-更大的runner)
      - [2. ARM64 Runners](#2-arm64-runners)
      - [3. Reusable Workflows (可复用工作流)](#3-reusable-workflows-可复用工作流)
      - [4. OIDC Token (无密钥云访问)](#4-oidc-token-无密钥云访问)
  - [GitLab CI/CD (17.x)](#gitlab-cicd-17x)
    - [GitLab CI/CD概述](#gitlab-cicd概述)
    - [Pipeline配置](#pipeline配置)
    - [GitLab CI/CD 17.x新特性](#gitlab-cicd-17x新特性)
      - [1. CI/CD Catalog (组件市场)](#1-cicd-catalog-组件市场)
      - [2. 动态子流水线](#2-动态子流水线)
      - [3. 合并请求审批规则](#3-合并请求审批规则)
      - [4. Value Stream分析](#4-value-stream分析)
  - [Tekton Pipelines](#tekton-pipelines)
    - [Tekton概述](#tekton概述)
    - [Tekton核心资源](#tekton核心资源)
    - [Tekton Pipeline示例](#tekton-pipeline示例)
    - [Tekton Triggers](#tekton-triggers)
  - [镜像安全扫描](#镜像安全扫描)
    - [Trivy扫描](#trivy扫描)
    - [SBOM生成](#sbom生成)
    - [镜像签名](#镜像签名)
  - [策略验证 (Policy-as-Code)](#策略验证-policy-as-code)
    - [Conftest策略验证](#conftest策略验证)
    - [OPA Gatekeeper集成](#opa-gatekeeper集成)
  - [GitOps工作流](#gitops工作流)
    - [ArgoCD自动化部署](#argocd自动化部署)
    - [Flux CD](#flux-cd)
    - [Kustomize配置管理](#kustomize配置管理)
  - [高级部署策略](#高级部署策略)
    - [金丝雀部署 (Canary)](#金丝雀部署-canary)
    - [蓝绿部署 (Blue-Green)](#蓝绿部署-blue-green)
    - [渐进式交付 (Progressive Delivery)](#渐进式交付-progressive-delivery)
  - [容器化构建](#容器化构建)
    - [BuildKit高级特性](#buildkit高级特性)
    - [Kaniko无特权构建](#kaniko无特权构建)
    - [多阶段构建优化](#多阶段构建优化)
  - [CI/CD安全最佳实践](#cicd安全最佳实践)
    - [供应链安全](#供应链安全)
    - [密钥管理](#密钥管理)
    - [工作流安全](#工作流安全)
  - [多云CI/CD](#多云cicd)
    - [跨云部署策略](#跨云部署策略)
    - [混合云CI/CD](#混合云cicd)
  - [监控与可观测性](#监控与可观测性)
    - [流水线指标](#流水线指标)
    - [失败分析](#失败分析)
  - [生产实践案例](#生产实践案例)
    - [微服务CI/CD](#微服务cicd)
    - [单体应用迁移](#单体应用迁移)
    - [多环境管理](#多环境管理)
  - [总结](#总结)
    - [技术选型指南](#技术选型指南)
    - [2025 CI/CD最佳实践](#2025-cicd最佳实践)
  - [相关文档](#相关文档)

---

## 云原生CI/CD概述

### 传统 vs 云原生 CI/CD

| 维度 | 传统CI/CD | 云原生CI/CD |
|------|----------|------------|
| **构建环境** | VM/物理机 | 容器/Pod |
| **部署目标** | VM/裸金属 | Kubernetes |
| **配置管理** | Ansible/Chef | Kustomize/Helm |
| **部署方式** | Push (CI推送) | Pull (GitOps拉取) |
| **回滚** | 手动/脚本 | Git Revert自动 |
| **监控** | 应用监控 | 全链路可观测性 |
| **安全** | 镜像扫描 | SBOM+签名+策略 |

---

### 2025 CI/CD趋势

```text
1. ✅ GitOps主流化
   - ArgoCD、Flux广泛采用
   - 声明式基础设施

2. ✅ 供应链安全标准化
   - SBOM必需
   - SLSA框架
   - 镜像签名 (Cosign)

3. ✅ Policy-as-Code
   - OPA/Conftest策略验证
   - 自动化合规检查

4. ✅ eBPF可观测性
   - Pixie、Tetragon集成
   - 零侵入性能分析

5. ✅ 渐进式交付
   - Argo Rollouts
   - Flagger金丝雀
   - 流量渐进切换
```

---

## GitHub Actions (2025)

### GitHub Actions概述

**GitHub Actions** 是 GitHub 原生的 CI/CD 平台。

**官网**: https://github.com/features/actions

**核心优势**:

```text
✅ 与GitHub深度集成
✅ 丰富的Marketplace生态
✅ 并发执行 (矩阵策略)
✅ 多架构支持 (x86/ARM)
✅ 自托管Runner
```

---

### 工作流基础

**.github/workflows/ci.yml**:

```yaml
name: CI/CD Pipeline

on:
  push:
    branches: [main, develop]
  pull_request:
    branches: [main]

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  lint:
    name: Lint Code
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      
      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'
      
      - name: Install dependencies
        run: npm ci
      
      - name: Run linters
        run: |
          npm run lint
          npm run format-check

  test:
    name: Run Tests
    runs-on: ubuntu-latest
    strategy:
      matrix:
        node-version: [18, 20, 22]
    steps:
      - uses: actions/checkout@v4
      
      - name: Set up Node.js ${{ matrix.node-version }}
        uses: actions/setup-node@v4
        with:
          node-version: ${{ matrix.node-version }}
      
      - name: Install dependencies
        run: npm ci
      
      - name: Run tests
        run: npm test
      
      - name: Upload coverage
        uses: codecov/codecov-action@v4
        with:
          token: ${{ secrets.CODECOV_TOKEN }}

  security-scan:
    name: Security Scanning
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      
      - name: Run Trivy vulnerability scanner
        uses: aquasecurity/trivy-action@master
        with:
          scan-type: 'fs'
          scan-ref: '.'
          format: 'sarif'
          output: 'trivy-results.sarif'
      
      - name: Upload Trivy results to GitHub Security
        uses: github/codeql-action/upload-sarif@v3
        with:
          sarif_file: 'trivy-results.sarif'

  build:
    name: Build and Push Image
    needs: [lint, test, security-scan]
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
    steps:
      - uses: actions/checkout@v4
      
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
      
      - name: Log in to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}
      
      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
          tags: |
            type=ref,event=branch
            type=ref,event=pr
            type=semver,pattern={{version}}
            type=semver,pattern={{major}}.{{minor}}
            type=sha,prefix={{branch}}-
      
      - name: Build and push
        uses: docker/build-push-action@v5
        with:
          context: .
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          platforms: linux/amd64,linux/arm64
          provenance: true
          sbom: true
```

---

### 容器镜像构建与推送

**多平台构建**:

```yaml
- name: Build Multi-Platform Image
  uses: docker/build-push-action@v5
  with:
    context: .
    platforms: linux/amd64,linux/arm64,linux/arm/v7
    push: true
    tags: |
      ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:latest
      ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ github.sha }}
```

**BuildKit缓存**:

```yaml
- name: Build with Cache
  uses: docker/build-push-action@v5
  with:
    context: .
    push: true
    tags: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:latest
    cache-from: type=gha
    cache-to: type=gha,mode=max
```

---

### GitHub Actions 2025新特性

#### 1. Larger Runners (更大的Runner)

```yaml
jobs:
  build-large:
    runs-on: ubuntu-latest-4-cores  # 4核8GB
    # 或
    runs-on: ubuntu-latest-8-cores  # 8核16GB
    # 或
    runs-on: ubuntu-latest-16-cores # 16核32GB
```

#### 2. ARM64 Runners

```yaml
jobs:
  build-arm:
    runs-on: ubuntu-latest-arm  # ARM64架构
```

#### 3. Reusable Workflows (可复用工作流)

**.github/workflows/reusable-build.yml**:

```yaml
name: Reusable Build

on:
  workflow_call:
    inputs:
      node-version:
        required: true
        type: string
    secrets:
      NPM_TOKEN:
        required: true

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      
      - uses: actions/setup-node@v4
        with:
          node-version: ${{ inputs.node-version }}
      
      - run: npm ci
        env:
          NPM_TOKEN: ${{ secrets.NPM_TOKEN }}
      
      - run: npm run build
```

**调用可复用工作流**:

```yaml
jobs:
  call-build:
    uses: ./.github/workflows/reusable-build.yml
    with:
      node-version: '20'
    secrets:
      NPM_TOKEN: ${{ secrets.NPM_TOKEN }}
```

#### 4. OIDC Token (无密钥云访问)

```yaml
jobs:
  deploy-aws:
    runs-on: ubuntu-latest
    permissions:
      id-token: write  # OIDC token
      contents: read
    steps:
      - uses: actions/checkout@v4
      
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: arn:aws:iam::123456789:role/GitHubActions
          aws-region: us-east-1
      
      - name: Deploy to EKS
        run: |
          aws eks update-kubeconfig --name my-cluster
          kubectl apply -f k8s/
```

---

## GitLab CI/CD (17.x)

### GitLab CI/CD概述

**GitLab CI/CD** 是 GitLab 集成的 CI/CD 平台。

**官网**: https://docs.gitlab.com/ee/ci/

**核心优势**:

```text
✅ 完整DevOps平台 (Git + CI/CD + Registry + K8s)
✅ 自动DevOps
✅ 安全扫描集成 (SAST/DAST)
✅ 多Runner架构
✅ 企业级功能 (审批流、合规性)
```

---

### Pipeline配置

**.gitlab-ci.yml**:

```yaml
stages:
  - build
  - test
  - scan
  - deploy

variables:
  DOCKER_HOST: tcp://docker:2376
  DOCKER_TLS_CERTDIR: "/certs"
  DOCKER_TLS_VERIFY: 1
  DOCKER_CERT_PATH: "$DOCKER_TLS_CERTDIR/client"
  IMAGE: $CI_REGISTRY_IMAGE:$CI_COMMIT_SHORT_SHA

# 构建镜像
build:
  stage: build
  image: docker:24-dind
  services:
    - docker:24-dind
  before_script:
    - docker login -u $CI_REGISTRY_USER -p $CI_REGISTRY_PASSWORD $CI_REGISTRY
  script:
    - docker build --pull -t $IMAGE .
    - docker push $IMAGE
  rules:
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH

# 单元测试
test:unit:
  stage: test
  image: node:20-alpine
  cache:
    paths:
      - node_modules/
  script:
    - npm ci
    - npm test
  coverage: '/^Statements\s+:\s+(\d+\.\d+)%/'
  artifacts:
    reports:
      junit: junit.xml
      coverage_report:
        coverage_format: cobertura
        path: coverage/cobertura-coverage.xml

# 安全扫描
scan:trivy:
  stage: scan
  image:
    name: aquasec/trivy:latest
    entrypoint: [""]
  script:
    - trivy image --exit-code 1 --severity CRITICAL,HIGH $IMAGE
  allow_failure: true

# SBOM生成
scan:sbom:
  stage: scan
  image:
    name: anchore/syft:latest
    entrypoint: [""]
  script:
    - syft packages $IMAGE -o cyclonedx-json > sbom.json
  artifacts:
    reports:
      cyclonedx: sbom.json

# SAST扫描
sast:
  stage: scan
  variables:
    SAST_EXCLUDED_PATHS: "spec, test, tests, tmp"
include:
  - template: Security/SAST.gitlab-ci.yml

# 部署到Kubernetes
deploy:production:
  stage: deploy
  image: bitnami/kubectl:latest
  environment:
    name: production
    kubernetes:
      namespace: production
  script:
    - kubectl set image deployment/myapp myapp=$IMAGE
    - kubectl rollout status deployment/myapp
  rules:
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
      when: manual  # 手动触发
```

---

### GitLab CI/CD 17.x新特性

#### 1. CI/CD Catalog (组件市场)

```yaml
include:
  - component: gitlab.com/components/docker-build:1.0.0
    inputs:
      image-name: myapp
      dockerfile: Dockerfile
```

#### 2. 动态子流水线

```yaml
generate-pipeline:
  stage: build
  script:
    - echo "include:" > pipeline.yml
    - for service in $(ls services/); do
        echo "  - local: services/$service/.gitlab-ci.yml" >> pipeline.yml;
      done
  artifacts:
    paths:
      - pipeline.yml

trigger-pipeline:
  stage: deploy
  trigger:
    include:
      - artifact: pipeline.yml
        job: generate-pipeline
```

#### 3. 合并请求审批规则

```yaml
rules:
  - if: $CI_MERGE_REQUEST_ID
    when: manual
    allow_failure: false
    needs:
      - sast
      - trivy-scan
```

#### 4. Value Stream分析

GitLab 17.x 内置 **Value Stream Analytics**，可视化 DevOps 效率：

- Lead Time (从需求到部署)
- Cycle Time (代码开发到合并)
- Deployment Frequency
- Change Failure Rate

---

## Tekton Pipelines

### Tekton概述

**Tekton** 是 Kubernetes 原生的 CI/CD 框架，是 **CD Foundation** 项目。

**官网**: https://tekton.dev/

**核心优势**:

```text
✅ Kubernetes原生 (CRD)
✅ 可移植性 (跨平台)
✅ 可扩展性 (自定义Task)
✅ 云无关
✅ 声明式配置
```

---

### Tekton核心资源

```text
1. Task: 独立的构建步骤
2. Pipeline: Task的编排
3. PipelineRun: Pipeline的执行实例
4. TaskRun: Task的执行实例
5. Trigger: 事件触发器
```

---

### Tekton Pipeline示例

**安装Tekton**:

```bash
# 安装Tekton Pipelines
kubectl apply -f https://storage.googleapis.com/tekton-releases/pipeline/latest/release.yaml

# 安装Tekton Triggers
kubectl apply -f https://storage.googleapis.com/tekton-releases/triggers/latest/release.yaml

# 安装Tekton Dashboard
kubectl apply -f https://storage.googleapis.com/tekton-releases/dashboard/latest/release.yaml

# 验证
kubectl get pods -n tekton-pipelines
```

**Task定义** (`task-build.yaml`):

```yaml
apiVersion: tekton.dev/v1
kind: Task
metadata:
  name: build-docker-image
spec:
  params:
  - name: image
    type: string
    description: Reference of the image to build
  - name: dockerfile
    type: string
    description: Path to the Dockerfile
    default: ./Dockerfile
  
  workspaces:
  - name: source
    description: The git repo source
  
  results:
  - name: IMAGE_DIGEST
    description: Digest of the built image
  
  steps:
  - name: build-and-push
    image: gcr.io/kaniko-project/executor:latest
    args:
    - --dockerfile=$(params.dockerfile)
    - --context=$(workspaces.source.path)
    - --destination=$(params.image)
    - --digest-file=/tekton/results/IMAGE_DIGEST
    securityContext:
      runAsUser: 0
```

**Pipeline定义** (`pipeline.yaml`):

```yaml
apiVersion: tekton.dev/v1
kind: Pipeline
metadata:
  name: build-and-deploy
spec:
  params:
  - name: repo-url
    type: string
    description: Git repository URL
  - name: image
    type: string
    description: Image reference
  
  workspaces:
  - name: shared-workspace
  
  tasks:
  # 1. Clone源代码
  - name: fetch-source
    taskRef:
      name: git-clone
      kind: ClusterTask
    params:
    - name: url
      value: $(params.repo-url)
    - name: revision
      value: main
    workspaces:
    - name: output
      workspace: shared-workspace
  
  # 2. 运行测试
  - name: run-tests
    taskRef:
      name: npm-test
    runAfter:
    - fetch-source
    workspaces:
    - name: source
      workspace: shared-workspace
  
  # 3. 构建镜像
  - name: build-image
    taskRef:
      name: build-docker-image
    runAfter:
    - run-tests
    params:
    - name: image
      value: $(params.image)
    workspaces:
    - name: source
      workspace: shared-workspace
  
  # 4. 安全扫描
  - name: scan-image
    taskRef:
      name: trivy-scan
    runAfter:
    - build-image
    params:
    - name: image
      value: $(params.image)
  
  # 5. 部署到Kubernetes
  - name: deploy
    taskRef:
      name: kubectl-deploy
    runAfter:
    - scan-image
    params:
    - name: image
      value: $(params.image)
```

**PipelineRun定义** (`pipelinerun.yaml`):

```yaml
apiVersion: tekton.dev/v1
kind: PipelineRun
metadata:
  name: build-and-deploy-run
spec:
  pipelineRef:
    name: build-and-deploy
  params:
  - name: repo-url
    value: https://github.com/example/myapp.git
  - name: image
    value: gcr.io/my-project/myapp:latest
  workspaces:
  - name: shared-workspace
    volumeClaimTemplate:
      spec:
        accessModes:
        - ReadWriteOnce
        resources:
          requests:
            storage: 1Gi
```

---

### Tekton Triggers

**EventListener** (监听GitHub Webhook):

```yaml
apiVersion: triggers.tekton.dev/v1beta1
kind: EventListener
metadata:
  name: github-listener
spec:
  serviceAccountName: tekton-triggers-sa
  triggers:
  - name: github-push
    interceptors:
    - ref:
        name: github
      params:
      - name: secretRef
        value:
          secretName: github-webhook-secret
          secretKey: token
      - name: eventTypes
        value:
        - push
    bindings:
    - ref: github-push-binding
    template:
      ref: pipeline-template
---
apiVersion: triggers.tekton.dev/v1beta1
kind: TriggerBinding
metadata:
  name: github-push-binding
spec:
  params:
  - name: gitrevision
    value: $(body.head_commit.id)
  - name: gitrepositoryurl
    value: $(body.repository.clone_url)
---
apiVersion: triggers.tekton.dev/v1beta1
kind: TriggerTemplate
metadata:
  name: pipeline-template
spec:
  params:
  - name: gitrevision
  - name: gitrepositoryurl
  resourcetemplates:
  - apiVersion: tekton.dev/v1
    kind: PipelineRun
    metadata:
      generateName: build-and-deploy-
    spec:
      pipelineRef:
        name: build-and-deploy
      params:
      - name: repo-url
        value: $(tt.params.gitrepositoryurl)
      workspaces:
      - name: shared-workspace
        volumeClaimTemplate:
          spec:
            accessModes:
            - ReadWriteOnce
            resources:
              requests:
                storage: 1Gi
```

---

## 镜像安全扫描

### Trivy扫描

**在CI/CD中集成Trivy**:

```yaml
# GitHub Actions
- name: Run Trivy Scanner
  uses: aquasecurity/trivy-action@master
  with:
    image-ref: 'myregistry.com/myapp:${{ github.sha }}'
    format: 'sarif'
    output: 'trivy-results.sarif'
    severity: 'CRITICAL,HIGH'
    exit-code: '1'  # 发现漏洞则失败

# GitLab CI
trivy-scan:
  image: aquasec/trivy:latest
  script:
    - trivy image --exit-code 1 --severity CRITICAL,HIGH $CI_REGISTRY_IMAGE:$CI_COMMIT_SHORT_SHA
```

---

### SBOM生成

**使用Syft生成SBOM**:

```yaml
# GitHub Actions
- name: Generate SBOM
  uses: anchore/sbom-action@v0
  with:
    image: myregistry.com/myapp:${{ github.sha }}
    format: cyclonedx-json
    output-file: sbom.json

- name: Upload SBOM
  uses: actions/upload-artifact@v4
  with:
    name: sbom
    path: sbom.json
```

**使用Syft CLI**:

```bash
# 生成SBOM
syft packages myregistry.com/myapp:latest -o cyclonedx-json > sbom.json

# 生成多种格式
syft packages myregistry.com/myapp:latest -o spdx-json > sbom-spdx.json
```

---

### 镜像签名

**使用Cosign签名镜像**:

```yaml
# GitHub Actions
- name: Install Cosign
  uses: sigstore/cosign-installer@v3

- name: Sign Image
  run: |
    cosign sign --yes ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}@${{ steps.build.outputs.digest }}
  env:
    COSIGN_EXPERIMENTAL: "true"  # 无密钥签名

# 验证签名
- name: Verify Signature
  run: |
    cosign verify ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}@${{ steps.build.outputs.digest }}
  env:
    COSIGN_EXPERIMENTAL: "true"
```

---

## 策略验证 (Policy-as-Code)

### Conftest策略验证

**安装Conftest**:

```bash
# 下载Conftest
curl -L -o conftest https://github.com/open-policy-agent/conftest/releases/latest/download/conftest-linux-amd64
chmod +x conftest
sudo mv conftest /usr/local/bin/
```

**Rego策略** (`policy/docker.rego`):

```rego
package main

import rego.v1

deny contains msg if {
    input[i].Cmd == "from"
    val := input[i].Value
    contains(val[i], "latest")
    msg := "Do not use 'latest' tag for base images"
}

deny contains msg if {
    input[i].Cmd == "run"
    val := input[i].Value
    contains(val[i], "sudo")
    msg := "Do not use 'sudo' in Dockerfile"
}

deny contains msg if {
    input[i].Cmd == "user"
    val := input[i].Value
    val[i] == "root"
    msg := "Do not run as root user"
}
```

**在CI中验证**:

```yaml
# GitHub Actions
- name: Test Dockerfile with Conftest
  run: |
    conftest test Dockerfile

# GitLab CI
conftest:
  image: openpolicyagent/conftest:latest
  script:
    - conftest test Dockerfile
```

---

### OPA Gatekeeper集成

**验证Kubernetes manifests**:

```rego
# policy/kubernetes.rego
package main

import rego.v1

deny contains msg if {
    input.kind == "Deployment"
    not input.spec.template.spec.securityContext.runAsNonRoot
    msg := "Deployments must set runAsNonRoot: true"
}

deny contains msg if {
    input.kind == "Deployment"
    container := input.spec.template.spec.containers[_]
    not container.resources.limits.memory
    msg := sprintf("Container '%s' must set memory limits", [container.name])
}
```

**在CI中验证**:

```yaml
- name: Validate K8s Manifests
  run: |
    conftest test k8s/ --policy policy/
```

---

## GitOps工作流

### ArgoCD自动化部署

**安装ArgoCD**:

```bash
kubectl create namespace argocd
kubectl apply -n argocd -f https://raw.githubusercontent.com/argoproj/argo-cd/stable/manifests/install.yaml

# 获取初始密码
kubectl -n argocd get secret argocd-initial-admin-secret -o jsonpath="{.data.password}" | base64 -d

# 端口转发
kubectl port-forward svc/argocd-server -n argocd 8080:443
```

**Application定义**:

```yaml
apiVersion: argoproj.io/v1alpha1
kind: Application
metadata:
  name: myapp
  namespace: argocd
  finalizers:
  - resources-finalizer.argocd.argoproj.io
spec:
  project: default
  
  source:
    repoURL: https://github.com/example/myapp-config.git
    targetRevision: HEAD
    path: k8s/overlays/production
    
    # Kustomize配置
    kustomize:
      version: v5.0.0
      images:
      - name: myapp
        newTag: v1.2.3
  
  destination:
    server: https://kubernetes.default.svc
    namespace: production
  
  syncPolicy:
    automated:
      prune: true      # 自动删除不需要的资源
      selfHeal: true   # 自动同步偏差
      allowEmpty: false
    
    syncOptions:
    - CreateNamespace=true
    - PrunePropagationPolicy=foreground
    
    retry:
      limit: 5
      backoff:
        duration: 5s
        factor: 2
        maxDuration: 3m
```

**Image Updater** (自动更新镜像):

```yaml
apiVersion: argoproj.io/v1alpha1
kind: Application
metadata:
  name: myapp
  annotations:
    argocd-image-updater.argoproj.io/image-list: myapp=gcr.io/my-project/myapp
    argocd-image-updater.argoproj.io/myapp.update-strategy: semver
    argocd-image-updater.argoproj.io/myapp.allow-tags: regexp:^v1\\..*
spec:
  # ... 同上
```

---

### Flux CD

**安装Flux**:

```bash
# 安装Flux CLI
curl -s https://fluxcd.io/install.sh | sudo bash

# Bootstrap Flux到集群
flux bootstrap github \
  --owner=my-github-org \
  --repository=my-fleet \
  --branch=main \
  --path=clusters/production \
  --personal
```

**GitRepository定义**:

```yaml
apiVersion: source.toolkit.fluxcd.io/v1
kind: GitRepository
metadata:
  name: myapp
  namespace: flux-system
spec:
  interval: 1m
  url: https://github.com/example/myapp-config
  ref:
    branch: main
```

**Kustomization定义**:

```yaml
apiVersion: kustomize.toolkit.fluxcd.io/v1
kind: Kustomization
metadata:
  name: myapp
  namespace: flux-system
spec:
  interval: 5m
  path: ./k8s/production
  prune: true
  sourceRef:
    kind: GitRepository
    name: myapp
  healthChecks:
  - apiVersion: apps/v1
    kind: Deployment
    name: myapp
    namespace: production
```

**ImageRepository** (镜像自动更新):

```yaml
apiVersion: image.toolkit.fluxcd.io/v1beta2
kind: ImageRepository
metadata:
  name: myapp
  namespace: flux-system
spec:
  image: gcr.io/my-project/myapp
  interval: 1m
---
apiVersion: image.toolkit.fluxcd.io/v1beta2
kind: ImagePolicy
metadata:
  name: myapp
  namespace: flux-system
spec:
  imageRepositoryRef:
    name: myapp
  policy:
    semver:
      range: 1.x.x
---
apiVersion: image.toolkit.fluxcd.io/v1beta1
kind: ImageUpdateAutomation
metadata:
  name: myapp
  namespace: flux-system
spec:
  interval: 1m
  sourceRef:
    kind: GitRepository
    name: myapp
  git:
    checkout:
      ref:
        branch: main
    commit:
      author:
        email: fluxcd@example.com
        name: Flux CD
      messageTemplate: 'Update image to {{range .Updated.Images}}{{println .}}{{end}}'
    push:
      branch: main
  update:
    path: ./k8s/production
    strategy: Setters
```

---

### Kustomize配置管理

**目录结构**:

```text
k8s/
├── base/
│   ├── deployment.yaml
│   ├── service.yaml
│   ├── kustomization.yaml
│   └── configmap.yaml
└── overlays/
    ├── dev/
    │   ├── kustomization.yaml
    │   └── patches/
    │       └── deployment-patch.yaml
    ├── staging/
    │   └── kustomization.yaml
    └── production/
        ├── kustomization.yaml
        └── patches/
            └── deployment-patch.yaml
```

**base/kustomization.yaml**:

```yaml
apiVersion: kustomize.config.k8s.io/v1beta1
kind: Kustomization

resources:
- deployment.yaml
- service.yaml
- configmap.yaml

commonLabels:
  app: myapp
  managed-by: kustomize

images:
- name: myapp
  newName: gcr.io/my-project/myapp
  newTag: latest
```

**overlays/production/kustomization.yaml**:

```yaml
apiVersion: kustomize.config.k8s.io/v1beta1
kind: Kustomization

bases:
- ../../base

namespace: production

replicas:
- name: myapp
  count: 5

images:
- name: myapp
  newTag: v1.2.3

patches:
- path: patches/deployment-patch.yaml

configMapGenerator:
- name: myapp-config
  behavior: merge
  literals:
  - ENV=production
  - LOG_LEVEL=info

resources:
- hpa.yaml
- pdb.yaml
```

---

## 高级部署策略

### 金丝雀部署 (Canary)

**使用Argo Rollouts**:

**安装Argo Rollouts**:

```bash
kubectl create namespace argo-rollouts
kubectl apply -n argo-rollouts -f https://github.com/argoproj/argo-rollouts/releases/latest/download/install.yaml

# 安装kubectl plugin
curl -LO https://github.com/argoproj/argo-rollouts/releases/latest/download/kubectl-argo-rollouts-linux-amd64
chmod +x kubectl-argo-rollouts-linux-amd64
sudo mv kubectl-argo-rollouts-linux-amd64 /usr/local/bin/kubectl-argo-rollouts
```

**Rollout定义**:

```yaml
apiVersion: argoproj.io/v1alpha1
kind: Rollout
metadata:
  name: myapp
spec:
  replicas: 10
  strategy:
    canary:
      steps:
      - setWeight: 20      # 20%流量到新版本
      - pause: {duration: 1m}
      - setWeight: 40
      - pause: {duration: 1m}
      - setWeight: 60
      - pause: {duration: 1m}
      - setWeight: 80
      - pause: {duration: 1m}
      
      # 自动推进条件
      canaryAnalysis:
        templates:
        - templateName: success-rate
        args:
        - name: service-name
          value: myapp
      
      # 流量管理 (Istio)
      trafficRouting:
        istio:
          virtualService:
            name: myapp
            routes:
            - primary
  
  revisionHistoryLimit: 2
  
  selector:
    matchLabels:
      app: myapp
  
  template:
    metadata:
      labels:
        app: myapp
    spec:
      containers:
      - name: myapp
        image: gcr.io/my-project/myapp:v2.0.0
        ports:
        - containerPort: 8080
        resources:
          requests:
            memory: "128Mi"
            cpu: "100m"
          limits:
            memory: "256Mi"
            cpu: "200m"
```

**AnalysisTemplate** (指标分析):

```yaml
apiVersion: argoproj.io/v1alpha1
kind: AnalysisTemplate
metadata:
  name: success-rate
spec:
  args:
  - name: service-name
  metrics:
  - name: success-rate
    initialDelay: 1m
    interval: 1m
    successCondition: result[0] >= 0.95
    failureLimit: 3
    provider:
      prometheus:
        address: http://prometheus.monitoring:9090
        query: |
          sum(rate(
            http_requests_total{service="{{args.service-name}}",status=~"2.."}[1m]
          )) /
          sum(rate(
            http_requests_total{service="{{args.service-name}}"}[1m]
          ))
```

---

### 蓝绿部署 (Blue-Green)

```yaml
apiVersion: argoproj.io/v1alpha1
kind: Rollout
metadata:
  name: myapp
spec:
  replicas: 5
  strategy:
    blueGreen:
      activeService: myapp-active
      previewService: myapp-preview
      autoPromotionEnabled: false
      scaleDownDelaySeconds: 300
      
      # 自动推进条件
      prePromotionAnalysis:
        templates:
        - templateName: smoke-tests
      
      # 推进后分析
      postPromotionAnalysis:
        templates:
        - templateName: success-rate
  
  selector:
    matchLabels:
      app: myapp
  
  template:
    # ... 同上
```

**手动推进**:

```bash
# 查看状态
kubectl argo rollouts get rollout myapp

# 推进到稳定版本
kubectl argo rollouts promote myapp

# 回滚
kubectl argo rollouts undo myapp
```

---

### 渐进式交付 (Progressive Delivery)

**使用Flagger** (与Istio/Linkerd集成):

**安装Flagger**:

```bash
kubectl apply -k github.com/fluxcd/flagger//kustomize/istio
```

**Canary定义**:

```yaml
apiVersion: flagger.app/v1beta1
kind: Canary
metadata:
  name: myapp
  namespace: production
spec:
  # deployment reference
  targetRef:
    apiVersion: apps/v1
    kind: Deployment
    name: myapp
  
  # HPA reference (optional)
  autoscalerRef:
    apiVersion: autoscaling/v2
    kind: HorizontalPodAutoscaler
    name: myapp
  
  service:
    port: 8080
    targetPort: 8080
    name: myapp
  
  analysis:
    interval: 1m
    threshold: 5
    maxWeight: 50
    stepWeight: 10
    
    metrics:
    - name: request-success-rate
      thresholdRange:
        min: 99
      interval: 1m
    
    - name: request-duration
      thresholdRange:
        max: 500
      interval: 1m
    
    webhooks:
    - name: load-test
      url: http://flagger-loadtester/
      timeout: 5s
      metadata:
        type: cmd
        cmd: "hey -z 1m -q 10 -c 2 http://myapp-canary:8080/"
```

---

## 容器化构建

### BuildKit高级特性

**启用BuildKit**:

```bash
export DOCKER_BUILDKIT=1
docker build .
```

**多阶段缓存**:

```dockerfile
# syntax=docker/dockerfile:1.4

FROM node:20-alpine AS deps
WORKDIR /app
COPY package*.json ./
RUN --mount=type=cache,target=/root/.npm \
    npm ci --only=production

FROM node:20-alpine AS build
WORKDIR /app
COPY package*.json ./
RUN --mount=type=cache,target=/root/.npm \
    npm ci
COPY . .
RUN npm run build

FROM node:20-alpine
WORKDIR /app
COPY --from=deps /app/node_modules ./node_modules
COPY --from=build /app/dist ./dist
CMD ["node", "dist/index.js"]
```

**Secret挂载** (不泄露到镜像):

```dockerfile
# syntax=docker/dockerfile:1.4

FROM alpine
RUN --mount=type=secret,id=github_token \
    apk add git && \
    git clone https://$(cat /run/secrets/github_token)@github.com/private/repo.git
```

```bash
docker build --secret id=github_token,src=./token.txt .
```

---

### Kaniko无特权构建

**在Kubernetes中使用Kaniko**:

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: kaniko
spec:
  containers:
  - name: kaniko
    image: gcr.io/kaniko-project/executor:latest
    args:
    - --dockerfile=/workspace/Dockerfile
    - --context=dir:///workspace
    - --destination=gcr.io/my-project/myapp:latest
    - --cache=true
    - --cache-repo=gcr.io/my-project/cache
    volumeMounts:
    - name: source
      mountPath: /workspace
    - name: docker-config
      mountPath: /kaniko/.docker/
  restartPolicy: Never
  volumes:
  - name: source
    persistentVolumeClaim:
      claimName: workspace-pvc
  - name: docker-config
    secret:
      secretName: docker-config
```

**Tekton Task使用Kaniko**:

```yaml
apiVersion: tekton.dev/v1
kind: Task
metadata:
  name: kaniko-build
spec:
  params:
  - name: IMAGE
    description: Name (reference) of the image to build.
  workspaces:
  - name: source
  steps:
  - name: build-and-push
    image: gcr.io/kaniko-project/executor:v1.19.0
    args:
    - --dockerfile=$(workspaces.source.path)/Dockerfile
    - --context=$(workspaces.source.path)
    - --destination=$(params.IMAGE)
    - --cache=true
    - --cache-ttl=24h
```

---

### 多阶段构建优化

**优化前**:

```dockerfile
FROM node:20
WORKDIR /app
COPY . .
RUN npm install
RUN npm run build
CMD ["node", "dist/index.js"]
```

**优化后**:

```dockerfile
# syntax=docker/dockerfile:1.4

# 1. 依赖安装阶段 (生产依赖)
FROM node:20-alpine AS deps
WORKDIR /app
COPY package*.json ./
RUN --mount=type=cache,target=/root/.npm \
    npm ci --only=production

# 2. 构建阶段
FROM node:20-alpine AS build
WORKDIR /app
COPY package*.json ./
RUN --mount=type=cache,target=/root/.npm \
    npm ci
COPY . .
RUN npm run build

# 3. 运行阶段 (最小镜像)
FROM node:20-alpine
RUN apk add --no-cache dumb-init
USER node
WORKDIR /app
COPY --chown=node:node --from=deps /app/node_modules ./node_modules
COPY --chown=node:node --from=build /app/dist ./dist
ENTRYPOINT ["dumb-init", "--"]
CMD ["node", "dist/index.js"]
```

**优化效果**:

```text
优化前: 1.2GB
优化后: 150MB

优化点:
✅ 使用alpine基础镜像
✅ 多阶段构建，只复制必要文件
✅ 移除构建工具和devDependencies
✅ BuildKit缓存加速构建
✅ 非root用户运行
✅ 使用dumb-init处理信号
```

---

## CI/CD安全最佳实践

### 供应链安全

**SLSA框架**:

```text
SLSA Level 3 要求:
✅ 可验证的源代码 (Git签名commit)
✅ 可验证的构建 (Provenance)
✅ 不可篡改的构建环境
✅ 密钥管理 (OIDC)
✅ SBOM生成
✅ 镜像签名 (Cosign)
```

**GitHub Actions实现SLSA**:

```yaml
name: SLSA Level 3 Build

on: push

permissions:
  contents: read
  packages: write
  id-token: write  # OIDC

jobs:
  build:
    runs-on: ubuntu-latest
    outputs:
      image-digest: ${{ steps.build.outputs.digest }}
    steps:
      - uses: actions/checkout@v4
        with:
          persist-credentials: false
      
      - uses: docker/setup-buildx-action@v3
      
      - uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}
      
      - name: Build and Push
        id: build
        uses: docker/build-push-action@v5
        with:
          context: .
          push: true
          tags: ghcr.io/${{ github.repository }}:${{ github.sha }}
          provenance: true  # SLSA Provenance
          sbom: true        # SBOM生成
      
      - name: Sign Image
        run: |
          cosign sign --yes ghcr.io/${{ github.repository }}@${{ steps.build.outputs.digest }}
        env:
          COSIGN_EXPERIMENTAL: "true"
```

---

### 密钥管理

**使用外部密钥管理**:

```yaml
# GitHub Actions with Vault
- name: Import Secrets from Vault
  uses: hashicorp/vault-action@v2
  with:
    url: https://vault.example.com
    method: jwt
    role: github-actions
    secrets: |
      secret/data/prod/database username | DB_USER ;
      secret/data/prod/database password | DB_PASS

# GitLab CI with Vault
deploy:
  image: vault:latest
  secrets:
    DATABASE_PASSWORD:
      vault: production/database/password@secret
      file: false
```

**OIDC无密钥访问云资源** (已在GitHub Actions 2025新特性中展示)

---

### 工作流安全

**最佳实践Checklist**:

```text
✅ 使用固定版本的Actions (v1而不是@main)
✅ Review第三方Actions源代码
✅ 最小权限 (permissions: contents: read)
✅ 不在日志中输出密钥 (set-output → GITHUB_OUTPUT)
✅ 使用approved actions列表
✅ 定期更新依赖 (Dependabot)
✅ Code scanning (CodeQL)
✅ Secret scanning
✅ 审计日志监控
✅ 分支保护规则
```

**分支保护规则**:

```yaml
# .github/branch-protection.yml
branches:
  - name: main
    protection:
      required_status_checks:
        strict: true
        contexts:
          - lint
          - test
          - security-scan
      required_pull_request_reviews:
        required_approving_review_count: 2
        dismiss_stale_reviews: true
        require_code_owner_reviews: true
      restrictions:
        teams:
          - platform-team
      enforce_admins: true
      required_linear_history: true
      allow_force_pushes: false
      allow_deletions: false
```

---

## 多云CI/CD

### 跨云部署策略

**多集群GitOps** (ArgoCD):

```yaml
apiVersion: argoproj.io/v1alpha1
kind: ApplicationSet
metadata:
  name: myapp
spec:
  generators:
  - list:
      elements:
      - cluster: aws-us-east-1
        url: https://kubernetes.aws.example.com
        env: production
      - cluster: gcp-us-central1
        url: https://kubernetes.gcp.example.com
        env: production
      - cluster: azure-eastus
        url: https://kubernetes.azure.example.com
        env: production
  
  template:
    metadata:
      name: 'myapp-{{cluster}}'
    spec:
      project: default
      source:
        repoURL: https://github.com/example/myapp-config.git
        targetRevision: HEAD
        path: k8s/overlays/{{env}}
      destination:
        server: '{{url}}'
        namespace: production
      syncPolicy:
        automated:
          prune: true
          selfHeal: true
```

---

### 混合云CI/CD

**Terraform多云部署**:

```hcl
# providers.tf
terraform {
  required_providers {
    aws = {
      source  = "hashicorp/aws"
      version = "~> 5.0"
    }
    google = {
      source  = "hashicorp/google"
      version = "~> 5.0"
    }
    azurerm = {
      source  = "hashicorp/azurerm"
      version = "~> 3.0"
    }
  }
}

# aws.tf
provider "aws" {
  region = "us-east-1"
}

resource "aws_eks_cluster" "main" {
  name     = "myapp-aws"
  role_arn = aws_iam_role.eks.arn
  # ...
}

# gcp.tf
provider "google" {
  project = "my-project"
  region  = "us-central1"
}

resource "google_container_cluster" "main" {
  name     = "myapp-gcp"
  location = "us-central1"
  # ...
}

# azure.tf
provider "azurerm" {
  features {}
}

resource "azurerm_kubernetes_cluster" "main" {
  name                = "myapp-azure"
  location            = "East US"
  resource_group_name = azurerm_resource_group.main.name
  # ...
}
```

---

## 监控与可观测性

### 流水线指标

**Prometheus监控GitLab CI**:

```yaml
# GitLab Runner Prometheus Exporter
global:
  scrape_interval: 15s

scrape_configs:
- job_name: 'gitlab-runner'
  static_configs:
  - targets: ['gitlab-runner:9252']

# 关键指标
gitlab_runner_jobs_total{state="running"}
gitlab_runner_jobs_total{state="success"}
gitlab_runner_jobs_total{state="failed"}
gitlab_runner_job_duration_seconds
```

**Grafana Dashboard**:

```json
{
  "dashboard": {
    "title": "CI/CD Pipeline Metrics",
    "panels": [
      {
        "title": "Success Rate",
        "targets": [
          {
            "expr": "sum(rate(gitlab_runner_jobs_total{state=\"success\"}[5m])) / sum(rate(gitlab_runner_jobs_total[5m]))"
          }
        ]
      },
      {
        "title": "Build Duration (p95)",
        "targets": [
          {
            "expr": "histogram_quantile(0.95, rate(gitlab_runner_job_duration_seconds_bucket[5m]))"
          }
        ]
      }
    ]
  }
}
```

---

### 失败分析

**自动失败分析**:

```yaml
# GitHub Actions - 失败时收集诊断信息
- name: Collect Diagnostics on Failure
  if: failure()
  run: |
    kubectl get pods -A
    kubectl describe pod $POD_NAME
    kubectl logs $POD_NAME --previous
    docker ps -a
    docker logs $CONTAINER_ID
  
- name: Upload Diagnostics
  if: failure()
  uses: actions/upload-artifact@v4
  with:
    name: diagnostics-${{ github.run_id }}
    path: |
      /tmp/diagnostics/
      kubectl-output.log
```

---

## 生产实践案例

### 微服务CI/CD

**Monorepo结构**:

```text
myapp/
├── services/
│   ├── auth/
│   │   ├── Dockerfile
│   │   ├── .gitlab-ci.yml
│   │   └── k8s/
│   ├── api/
│   │   ├── Dockerfile
│   │   ├── .gitlab-ci.yml
│   │   └── k8s/
│   └── frontend/
│       ├── Dockerfile
│       ├── .gitlab-ci.yml
│       └── k8s/
└── .gitlab-ci.yml  # 主流水线
```

**主流水线** (`.gitlab-ci.yml`):

```yaml
stages:
  - trigger

trigger-services:
  stage: trigger
  script:
    - |
      for service in $(git diff --name-only $CI_COMMIT_BEFORE_SHA $CI_COMMIT_SHA | cut -d'/' -f1-2 | sort -u); do
        if [ -f "$service/.gitlab-ci.yml" ]; then
          echo "Triggering pipeline for $service"
          curl -X POST \
            -F token=$CI_JOB_TOKEN \
            -F ref=$CI_COMMIT_REF_NAME \
            -F "variables[SERVICE]=$service" \
            https://gitlab.com/api/v4/projects/$CI_PROJECT_ID/trigger/pipeline
        fi
      done
```

---

### 单体应用迁移

**渐进式容器化**:

```yaml
# Phase 1: 构建容器镜像
build-container:
  stage: build
  script:
    - docker build -t myapp:$CI_COMMIT_SHA .
    - docker push myapp:$CI_COMMIT_SHA

# Phase 2: 金丝雀部署 (5%流量)
deploy-canary:
  stage: deploy
  script:
    - kubectl apply -f k8s/canary/
    - kubectl set image deployment/myapp-canary myapp=myapp:$CI_COMMIT_SHA
  environment:
    name: production-canary
    url: https://canary.example.com

# Phase 3: 全量部署
deploy-production:
  stage: deploy
  when: manual
  script:
    - kubectl set image deployment/myapp myapp=myapp:$CI_COMMIT_SHA
  environment:
    name: production
    url: https://example.com
```

---

### 多环境管理

**环境隔离策略**:

```yaml
# .github/workflows/deploy.yml
name: Deploy to Environment

on:
  workflow_dispatch:
    inputs:
      environment:
        type: choice
        options:
          - dev
          - staging
          - production
        required: true

jobs:
  deploy:
    runs-on: ubuntu-latest
    environment: ${{ inputs.environment }}
    steps:
      - uses: actions/checkout@v4
      
      - name: Deploy to ${{ inputs.environment }}
        run: |
          kubectl config use-context ${{ secrets.K8S_CLUSTER }}
          kubectl apply -k k8s/overlays/${{ inputs.environment }}
        env:
          KUBECONFIG: ${{ secrets.KUBECONFIG }}
```

---

## 总结

### 技术选型指南

```text
场景1: GitHub托管项目
→ GitHub Actions
  理由: 深度集成、简单易用、Marketplace生态

场景2: GitLab托管项目
→ GitLab CI/CD
  理由: 完整DevOps平台、内置安全扫描

场景3: Kubernetes原生CI/CD
→ Tekton Pipelines
  理由: 云无关、可移植、可扩展

场景4: GitOps部署
→ ArgoCD (功能丰富) 或 Flux (轻量)
  理由: 声明式、自动同步、Git作为唯一事实来源

场景5: 渐进式交付
→ Argo Rollouts + Flagger
  理由: 金丝雀部署、自动化推进、指标分析
```

---

### 2025 CI/CD最佳实践

```text
✅ 供应链安全
   - SBOM生成 (Syft)
   - 镜像签名 (Cosign)
   - SLSA框架

✅ Policy-as-Code
   - Conftest策略验证
   - OPA Gatekeeper

✅ GitOps
   - ArgoCD/Flux
   - Git作为唯一事实来源
   - 自动同步与修复

✅ 渐进式交付
   - 金丝雀部署
   - 自动化推进
   - 指标驱动

✅ 安全扫描
   - Trivy漏洞扫描
   - SAST/DAST
   - 依赖检查

✅ 无特权构建
   - Kaniko
   - BuildKit安全特性

✅ 可观测性
   - 流水线指标
   - 失败分析
   - 分布式追踪
```

---

## 相关文档

**本模块文档**:

- [Ansible自动化](01_Ansible自动化.md)
- [Terraform基础设施即代码](02_Terraform基础设施即代码.md)

**相关模块**:

- [容器化部署](../../02_容器化部署/README.md)
- [监控告警](../../04_运维管理/01_监控告警/README.md)

**外部资源**:

- [GitHub Actions文档](https://docs.github.com/en/actions)
- [GitLab CI/CD文档](https://docs.gitlab.com/ee/ci/)
- [Tekton官方文档](https://tekton.dev/docs/)
- [ArgoCD官方文档](https://argo-cd.readthedocs.io/)
- [Flux CD官方文档](https://fluxcd.io/docs/)

---

**更新时间**: 2025-10-20  
**文档版本**: v2.0  
**状态**: ✅ **2025标准对齐完成**

**🚀 本文档全面覆盖2025年云原生CI/CD技术栈！🚀**-
