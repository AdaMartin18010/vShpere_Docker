# 权限管理与策略控制 (2025)

**更新日期**: 2025-10-20  
**版本**: v1.0  
**状态**: ✅ **已完成**

---

## 目录

- [权限管理与策略控制 (2025)](#权限管理与策略控制-2025)
  - [目录](#目录)
  - [云原生权限管理概述](#云原生权限管理概述)
    - [传统 vs 云原生权限管理](#传统-vs-云原生权限管理)
    - [2025权限管理趋势](#2025权限管理趋势)
  - [Kubernetes RBAC](#kubernetes-rbac)
    - [RBAC概述](#rbac概述)
    - [RBAC核心资源](#rbac核心资源)
      - [1. Role / ClusterRole](#1-role--clusterrole)
      - [2. RoleBinding / ClusterRoleBinding](#2-rolebinding--clusterrolebinding)
      - [3. ServiceAccount](#3-serviceaccount)
    - [RBAC最佳实践](#rbac最佳实践)
      - [1. 最小权限原则](#1-最小权限原则)
      - [2. 使用命名空间隔离](#2-使用命名空间隔离)
      - [3. 聚合 ClusterRole](#3-聚合-clusterrole)
    - [RBAC常见场景](#rbac常见场景)
      - [场景1: 开发者只读访问](#场景1-开发者只读访问)
      - [场景2: CI/CD部署权限](#场景2-cicd部署权限)
      - [场景3: 监控系统权限](#场景3-监控系统权限)
  - [OPA (Open Policy Agent)](#opa-open-policy-agent)
    - [OPA概述](#opa概述)
    - [OPA架构](#opa架构)
    - [OPA与Kubernetes集成](#opa与kubernetes集成)
      - [部署方式1: Sidecar模式](#部署方式1-sidecar模式)
      - [部署方式2: Gatekeeper (推荐)](#部署方式2-gatekeeper-推荐)
    - [Rego策略语言](#rego策略语言)
      - [基本语法](#基本语法)
      - [Rego示例1: 镜像仓库白名单](#rego示例1-镜像仓库白名单)
      - [Rego示例2: 资源限制检查](#rego示例2-资源限制检查)
      - [Rego示例3: Ingress TLS强制](#rego示例3-ingress-tls强制)
    - [Gatekeeper (OPA for K8s)](#gatekeeper-opa-for-k8s)
      - [Gatekeeper核心概念](#gatekeeper核心概念)
      - [ConstraintTemplate示例](#constrainttemplate示例)
      - [Gatekeeper Mutation (变更器)](#gatekeeper-mutation-变更器)
    - [OPA 2025新特性](#opa-2025新特性)
      - [1. OPA v1.0稳定API](#1-opa-v10稳定api)
      - [2. WASM编译策略](#2-wasm编译策略)
      - [3. Type Checking (类型检查)](#3-type-checking-类型检查)
      - [4. 增强的决策日志](#4-增强的决策日志)
  - [Kyverno策略引擎](#kyverno策略引擎)
    - [Kyverno概述](#kyverno概述)
    - [Kyverno策略类型](#kyverno策略类型)
      - [1. Validate (验证)](#1-validate-验证)
      - [2. Mutate (变更)](#2-mutate-变更)
      - [3. Generate (生成)](#3-generate-生成)
    - [Kyverno vs OPA](#kyverno-vs-opa)
    - [Kyverno 2025新特性](#kyverno-2025新特性)
      - [1. ValidatingAdmissionPolicy支持](#1-validatingadmissionpolicy支持)
      - [2. 增强的CEL支持](#2-增强的cel支持)
      - [3. Policy Exceptions (策略例外)](#3-policy-exceptions-策略例外)
      - [4. Cleanup Policies (清理策略)](#4-cleanup-policies-清理策略)
  - [外部授权 (External Authorization)](#外部授权-external-authorization)
    - [ext-authz概述](#ext-authz概述)
    - [Envoy External Authorization](#envoy-external-authorization)
    - [Istio Authorization](#istio-authorization)
      - [方式1: Istio AuthorizationPolicy](#方式1-istio-authorizationpolicy)
      - [方式2: Istio + OPA (ext-authz)](#方式2-istio--opa-ext-authz)
  - [Policy-as-Code最佳实践](#policy-as-code最佳实践)
    - [策略即代码概念](#策略即代码概念)
    - [策略CI/CD](#策略cicd)
    - [策略测试](#策略测试)
      - [OPA测试示例](#opa测试示例)
      - [Kyverno测试示例](#kyverno测试示例)
  - [属性访问控制 (ABAC)](#属性访问控制-abac)
    - [RBAC vs ABAC](#rbac-vs-abac)
    - [Kubernetes ABAC实现](#kubernetes-abac实现)
  - [AWS Cedar策略语言](#aws-cedar策略语言)
    - [Cedar概述](#cedar概述)
    - [Cedar vs Rego](#cedar-vs-rego)
  - [多租户权限隔离](#多租户权限隔离)
    - [Namespace隔离](#namespace隔离)
    - [网络策略隔离](#网络策略隔离)
    - [Virtual Cluster](#virtual-cluster)
  - [审计与合规](#审计与合规)
    - [Kubernetes Audit](#kubernetes-audit)
    - [Falco运行时审计](#falco运行时审计)
    - [合规性检查](#合规性检查)
  - [生产实践案例](#生产实践案例)
    - [企业RBAC方案](#企业rbac方案)
    - [多租户SaaS平台](#多租户saas平台)
    - [金融行业合规](#金融行业合规)
  - [总结](#总结)
    - [技术选型指南](#技术选型指南)
    - [2025年趋势](#2025年趋势)
    - [最佳实践Checklist](#最佳实践checklist)
  - [相关文档](#相关文档)

---

## 云原生权限管理概述

### 传统 vs 云原生权限管理

| 维度 | 传统权限管理 | 云原生权限管理 |
|------|------------|---------------|
| **粒度** | 粗粒度 (服务器/应用级别) | 细粒度 (API/资源级别) |
| **动态性** | 静态配置，变更缓慢 | 动态配置，实时生效 |
| **规模** | 数百用户 | 数千服务/Pod |
| **策略表达** | 硬编码/配置文件 | Policy-as-Code |
| **审计** | 日志文件 | 结构化审计日志 |
| **分布式** | 集中式认证 | 分布式认证/授权 |

### 2025权限管理趋势

```text
1. ✅ Policy-as-Code主流化
   - Rego、Cedar、Kyverno YAML
   - 策略版本控制 (Git)
   - 策略CI/CD

2. ✅ 零信任架构 (Zero Trust)
   - 永不信任，始终验证
   - 最小权限原则
   - 动态访问控制

3. ✅ eBPF运行时策略
   - Tetragon、Falco
   - 内核级策略执行

4. ✅ 多云统一策略
   - 跨K8s集群
   - 跨云服务商

5. ✅ AI辅助策略生成
   - 策略推荐
   - 异常检测
```

---

## Kubernetes RBAC

### RBAC概述

**RBAC** (Role-Based Access Control，基于角色的访问控制) 是 **Kubernetes** 的默认授权机制。

**核心概念**:

```text
User/ServiceAccount  →  Role/ClusterRole  →  RoleBinding/ClusterRoleBinding
      (主体)                  (角色)                      (绑定)
```

**授权流程**:

```text
1. 认证 (Authentication)
   ↓
2. RBAC授权 (Authorization)
   ↓
3. 准入控制 (Admission Control)
   ↓
4. 执行操作
```

---

### RBAC核心资源

#### 1. Role / ClusterRole

**Role** (命名空间级别):

```yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  namespace: default
  name: pod-reader
rules:
- apiGroups: [""]  # "" 表示核心API组
  resources: ["pods"]
  verbs: ["get", "list", "watch"]
```

**ClusterRole** (集群级别):

```yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: secret-reader
rules:
- apiGroups: [""]
  resources: ["secrets"]
  verbs: ["get", "list"]
```

**常用动词 (verbs)**:

```yaml
verbs:
- get      # 读取单个资源
- list     # 列出资源集合
- watch    # 监听资源变化
- create   # 创建资源
- update   # 更新资源
- patch    # 部分更新
- delete   # 删除资源
- deletecollection  # 批量删除
```

---

#### 2. RoleBinding / ClusterRoleBinding

**RoleBinding** (命名空间级别):

```yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: read-pods
  namespace: default
subjects:
- kind: User
  name: jane@example.com
  apiGroup: rbac.authorization.k8s.io
roleRef:
  kind: Role
  name: pod-reader
  apiGroup: rbac.authorization.k8s.io
```

**ClusterRoleBinding** (集群级别):

```yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: read-secrets-global
subjects:
- kind: ServiceAccount
  name: my-service-account
  namespace: default
roleRef:
  kind: ClusterRole
  name: secret-reader
  apiGroup: rbac.authorization.k8s.io
```

---

#### 3. ServiceAccount

**ServiceAccount** 是 **Pod** 的身份标识。

```yaml
apiVersion: v1
kind: ServiceAccount
metadata:
  name: my-service-account
  namespace: default
```

**在Pod中使用**:

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: my-pod
spec:
  serviceAccountName: my-service-account
  containers:
  - name: app
    image: nginx:1.27
```

---

### RBAC最佳实践

#### 1. 最小权限原则

```yaml
# ❌ 错误: 过度授权
rules:
- apiGroups: ["*"]
  resources: ["*"]
  verbs: ["*"]

# ✅ 正确: 精确授权
rules:
- apiGroups: ["apps"]
  resources: ["deployments"]
  verbs: ["get", "list"]
  resourceNames: ["my-deployment"]  # 限制特定资源
```

---

#### 2. 使用命名空间隔离

```yaml
# 开发环境 Role
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  name: dev-full-access
  namespace: dev
rules:
- apiGroups: ["*"]
  resources: ["*"]
  verbs: ["*"]
---
# 生产环境 Role (只读)
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  name: prod-read-only
  namespace: prod
rules:
- apiGroups: [""]
  resources: ["pods", "services"]
  verbs: ["get", "list"]
```

---

#### 3. 聚合 ClusterRole

```yaml
# 基础角色
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: aggregate-pod-reader
  labels:
    rbac.example.com/aggregate-to-monitoring: "true"
rules:
- apiGroups: [""]
  resources: ["pods"]
  verbs: ["get", "list"]
---
# 聚合角色
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: monitoring
aggregationRule:
  clusterRoleSelectors:
  - matchLabels:
      rbac.example.com/aggregate-to-monitoring: "true"
rules: []  # 自动填充
```

---

### RBAC常见场景

#### 场景1: 开发者只读访问

```yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: developer-read-only
rules:
# 查看Pods
- apiGroups: [""]
  resources: ["pods", "pods/log"]
  verbs: ["get", "list", "watch"]
# 查看Deployments
- apiGroups: ["apps"]
  resources: ["deployments", "replicasets"]
  verbs: ["get", "list"]
# 查看Services
- apiGroups: [""]
  resources: ["services"]
  verbs: ["get", "list"]
---
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: dev-read-binding
  namespace: development
subjects:
- kind: User
  name: dev-user@example.com
  apiGroup: rbac.authorization.k8s.io
roleRef:
  kind: ClusterRole
  name: developer-read-only
  apiGroup: rbac.authorization.k8s.io
```

---

#### 场景2: CI/CD部署权限

```yaml
apiVersion: v1
kind: ServiceAccount
metadata:
  name: ci-deployer
  namespace: production
---
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  name: deployer
  namespace: production
rules:
# 管理Deployments
- apiGroups: ["apps"]
  resources: ["deployments"]
  verbs: ["get", "list", "create", "update", "patch"]
# 管理Services
- apiGroups: [""]
  resources: ["services"]
  verbs: ["get", "list", "create", "update"]
# 管理ConfigMaps
- apiGroups: [""]
  resources: ["configmaps"]
  verbs: ["get", "list", "create", "update"]
# 管理Secrets
- apiGroups: [""]
  resources: ["secrets"]
  verbs: ["get", "list", "create"]
---
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: ci-deployer-binding
  namespace: production
subjects:
- kind: ServiceAccount
  name: ci-deployer
  namespace: production
roleRef:
  kind: Role
  name: deployer
  apiGroup: rbac.authorization.k8s.io
```

---

#### 场景3: 监控系统权限

```yaml
apiVersion: v1
kind: ServiceAccount
metadata:
  name: prometheus
  namespace: monitoring
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: prometheus
rules:
# 发现所有Pods
- apiGroups: [""]
  resources: ["pods", "nodes", "services", "endpoints"]
  verbs: ["get", "list", "watch"]
# 读取指标
- apiGroups: [""]
  resources: ["pods/metrics", "nodes/metrics"]
  verbs: ["get"]
# 访问非资源URL
- nonResourceURLs: ["/metrics"]
  verbs: ["get"]
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: prometheus
subjects:
- kind: ServiceAccount
  name: prometheus
  namespace: monitoring
roleRef:
  kind: ClusterRole
  name: prometheus
  apiGroup: rbac.authorization.k8s.io
```

---

## OPA (Open Policy Agent)

### OPA概述

**OPA** (Open Policy Agent) 是 **CNCF毕业项目**，是一个**通用策略引擎**。

**官网**: https://www.openpolicyagent.org/

**核心特性**:

```text
✅ 策略即代码 (Policy-as-Code)
✅ 统一策略模型 (Rego语言)
✅ 与平台无关 (K8s、微服务、CI/CD)
✅ 实时策略评估
✅ 高性能 (编译策略)
```

**应用场景**:

```text
1. Kubernetes准入控制 (Admission Control)
2. 微服务API授权
3. Terraform基础设施策略
4. CI/CD流水线控制
5. 数据访问控制
```

---

### OPA架构

```text
┌─────────────────────────────────────────┐
│          应用/平台 (Kubernetes)          │
│                                         │
│  ┌─────────────────────────────────┐   │
│  │      决策请求 (JSON)             │   │
│  └──────────────┬──────────────────┘   │
│                 │                       │
│                 ▼                       │
│  ┌─────────────────────────────────┐   │
│  │           OPA引擎                │   │
│  │  ┌──────────────────────────┐   │   │
│  │  │   策略 (Rego)             │   │   │
│  │  ├──────────────────────────┤   │   │
│  │  │   数据 (JSON)             │   │   │
│  │  └──────────────────────────┘   │   │
│  │          ↓                      │   │
│  │  ┌──────────────────────────┐   │   │
│  │  │  决策结果 (Allow/Deny)    │   │   │
│  │  └──────────────────────────┘   │   │
│  └─────────────────────────────────┘   │
└─────────────────────────────────────────┘
```

**核心组件**:

```text
1. OPA Server
   - REST API
   - 策略评估引擎

2. Bundle (策略包)
   - 策略文件 (.rego)
   - 数据文件 (.json)

3. Decision Logs
   - 决策审计日志
```

---

### OPA与Kubernetes集成

#### 部署方式1: Sidecar模式

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: my-app
spec:
  replicas: 3
  selector:
    matchLabels:
      app: my-app
  template:
    metadata:
      labels:
        app: my-app
    spec:
      containers:
      # 应用容器
      - name: app
        image: my-app:1.0
        ports:
        - containerPort: 8080
      # OPA Sidecar
      - name: opa
        image: openpolicyagent/opa:0.68.0  # 2025最新版本
        args:
        - "run"
        - "--server"
        - "--addr=localhost:8181"
        - "/policies/policy.rego"
        volumeMounts:
        - name: policy
          mountPath: /policies
      volumes:
      - name: policy
        configMap:
          name: opa-policy
```

---

#### 部署方式2: Gatekeeper (推荐)

**Gatekeeper** 是 **OPA for Kubernetes** 的标准实现。

**安装 Gatekeeper**:

```bash
# Helm安装 (推荐)
helm repo add gatekeeper https://open-policy-agent.github.io/gatekeeper/charts
helm repo update

helm install gatekeeper gatekeeper/gatekeeper \
  --namespace gatekeeper-system \
  --create-namespace \
  --version 3.16.0  # 2025最新版本

# 验证
kubectl get pods -n gatekeeper-system
```

---

### Rego策略语言

**Rego** 是 OPA 的策略语言，是一种**声明式逻辑编程语言**。

#### 基本语法

```rego
# 包声明
package example

# 导入
import rego.v1

# 规则
allow if {
    input.method == "GET"
    input.path[0] == "public"
}

# 带输出的规则
message := "Access denied" if {
    not allow
}

# 函数
is_admin(user) if {
    user.role == "admin"
}
```

---

#### Rego示例1: 镜像仓库白名单

```rego
package kubernetes.admission

import rego.v1

# 允许的镜像仓库
allowed_registries := [
    "docker.io",
    "gcr.io",
    "ghcr.io",
    "quay.io"
]

# 拒绝策略
deny contains msg if {
    # 遍历所有容器
    some container in input.request.object.spec.containers
    # 提取镜像仓库
    image := container.image
    not image_from_allowed_registry(image)
    
    msg := sprintf("Image '%s' not from allowed registry. Allowed: %v", 
                   [image, allowed_registries])
}

# 辅助函数: 检查镜像仓库
image_from_allowed_registry(image) if {
    some registry in allowed_registries
    startswith(image, registry)
}
```

---

#### Rego示例2: 资源限制检查

```rego
package kubernetes.admission

import rego.v1

# 拒绝没有设置资源限制的Pod
deny contains msg if {
    some container in input.request.object.spec.containers
    not container.resources.limits.cpu
    not container.resources.limits.memory
    
    msg := sprintf("Container '%s' must have CPU and memory limits", 
                   [container.name])
}

# 拒绝资源请求过大的Pod
deny contains msg if {
    some container in input.request.object.spec.containers
    cpu_limit := container.resources.limits.cpu
    cpu_value := parse_cpu(cpu_limit)
    cpu_value > 8  # 最多8核
    
    msg := sprintf("Container '%s' CPU limit %s exceeds maximum (8 cores)", 
                   [container.name, cpu_limit])
}

# 解析CPU值
parse_cpu(cpu) := result if {
    endswith(cpu, "m")
    result := to_number(trim_suffix(cpu, "m")) / 1000
} else := to_number(cpu)
```

---

#### Rego示例3: Ingress TLS强制

```rego
package kubernetes.admission

import rego.v1

# 拒绝没有TLS的Ingress
deny contains msg if {
    input.request.kind.kind == "Ingress"
    not input.request.object.spec.tls
    
    msg := "Ingress must have TLS configured"
}

# 拒绝使用自签名证书的Ingress
deny contains msg if {
    input.request.kind.kind == "Ingress"
    some tls in input.request.object.spec.tls
    some secret in tls.secretName
    contains(secret, "self-signed")
    
    msg := sprintf("Ingress cannot use self-signed certificate: %s", [secret])
}
```

---

### Gatekeeper (OPA for K8s)

#### Gatekeeper核心概念

```text
1. ConstraintTemplate (约束模板)
   - 定义策略逻辑 (Rego)
   - 可复用

2. Constraint (约束)
   - 策略实例
   - 配置参数

3. Audit (审计)
   - 定期扫描现有资源
   - 报告违规

4. Mutation (变更)
   - 自动修改资源
   - 如添加labels、设置默认值
```

---

#### ConstraintTemplate示例

```yaml
apiVersion: templates.gatekeeper.sh/v1
kind: ConstraintTemplate
metadata:
  name: k8srequiredlabels
spec:
  crd:
    spec:
      names:
        kind: K8sRequiredLabels
      validation:
        # 参数定义
        openAPIV3Schema:
          type: object
          properties:
            labels:
              type: array
              items:
                type: string
  targets:
  - target: admission.k8s.gatekeeper.sh
    rego: |
      package k8srequiredlabels
      
      import rego.v1
      
      violation contains {"msg": msg} if {
        provided := {label | input.review.object.metadata.labels[label]}
        required := {label | label := input.parameters.labels[_]}
        missing := required - provided
        count(missing) > 0
        msg := sprintf("Missing required labels: %v", [missing])
      }
```

**使用约束**:

```yaml
apiVersion: constraints.gatekeeper.sh/v1beta1
kind: K8sRequiredLabels
metadata:
  name: must-have-owner
spec:
  match:
    kinds:
    - apiGroups: [""]
      kinds: ["Pod"]
  parameters:
    labels:
    - "owner"
    - "team"
    - "env"
```

---

#### Gatekeeper Mutation (变更器)

**Assign (赋值器)** - 添加/修改字段:

```yaml
apiVersion: mutations.gatekeeper.sh/v1beta1
kind: Assign
metadata:
  name: add-default-securitycontext
spec:
  applyTo:
  - groups: [""]
    kinds: ["Pod"]
    versions: ["v1"]
  match:
    scope: Namespaced
    namespaces: ["production"]
  location: "spec.securityContext"
  parameters:
    assign:
      value:
        runAsNonRoot: true
        seccompProfile:
          type: RuntimeDefault
```

**ModifySet (修改集合)** - 添加数组元素:

```yaml
apiVersion: mutations.gatekeeper.sh/v1beta1
kind: ModifySet
metadata:
  name: add-imagepullsecrets
spec:
  applyTo:
  - groups: [""]
    kinds: ["Pod"]
    versions: ["v1"]
  match:
    scope: Namespaced
    namespaces: ["production"]
  location: "spec.imagePullSecrets"
  parameters:
    operation: merge
    values:
      fromList:
      - name: regcred
```

---

### OPA 2025新特性

#### 1. OPA v1.0稳定API

```text
✅ Rego v1标准化
   - 新关键字: contains, in, if
   - 更清晰的语法

✅ 向后兼容
   - 支持legacy Rego
```

**示例 (Rego v1)**:

```rego
package example

import rego.v1  # 显式启用v1

# 新语法: if关键字
allow if {
    input.user == "admin"
}

# 新语法: contains关键字
deny contains msg if {
    not allow
    msg := "Access denied"
}

# 新语法: in关键字
is_valid if {
    input.method in ["GET", "POST"]
}
```

---

#### 2. WASM编译策略

```bash
# 编译策略为WASM
opa build -t wasm -e 'example/allow' policy.rego

# 输出: bundle.tar.gz
# 包含: policy.wasm

# 在应用中加载WASM策略
# 性能提升 2-5x
```

---

#### 3. Type Checking (类型检查)

```rego
package example

import rego.v1

# 类型注解
input_schema := {
    "type": "object",
    "properties": {
        "user": {"type": "string"},
        "age": {"type": "integer"}
    },
    "required": ["user"]
}

# OPA会在编译时检查input类型
allow if {
    input.user == "admin"
    input.age >= 18  # 类型安全: age必须是整数
}
```

---

#### 4. 增强的决策日志

```yaml
# OPA配置: decision_logs.yaml
decision_logs:
  console: true
  service: decision_logger
  reporting:
    min_delay_seconds: 1
    max_delay_seconds: 10
  # 新增: 脱敏配置
  mask_decision:
    # 脱敏敏感字段
    - path: /input/request/object/data/password
    - path: /input/request/object/data/secretKey
```

---

## Kyverno策略引擎

### Kyverno概述

**Kyverno** 是 **CNCF孵化项目**，专为Kubernetes设计的**策略引擎**。

**官网**: https://kyverno.io/

**核心特性**:

```text
✅ Kubernetes原生 (YAML策略)
✅ 无需学习新语言 (vs OPA Rego)
✅ 验证、变更、生成资源
✅ CLI工具 (测试策略)
✅ Policy Reports (违规报告)
```

**Kyverno vs OPA**:

| 特性 | Kyverno | OPA/Gatekeeper |
|------|---------|---------------|
| **策略语言** | YAML | Rego |
| **学习曲线** | 低 (Kubernetes用户) | 中 (需学习Rego) |
| **适用范围** | Kubernetes专用 | 通用 (K8s+其他) |
| **变更能力** | ✅ 强大 (Mutate) | ✅ 有限 (Mutation) |
| **生成能力** | ✅ 可生成资源 | ❌ 不支持 |
| **报告** | ✅ Policy Reports | ✅ Audit |
| **性能** | 中 | 高 (WASM编译) |

---

### Kyverno策略类型

#### 1. Validate (验证)

**拒绝没有label的Pod**:

```yaml
apiVersion: kyverno.io/v1
kind: ClusterPolicy
metadata:
  name: require-labels
spec:
  validationFailureAction: Enforce  # Enforce/Audit
  background: true  # 审计现有资源
  rules:
  - name: check-for-labels
    match:
      any:
      - resources:
          kinds:
          - Pod
    validate:
      message: "Pods must have 'team' and 'owner' labels"
      pattern:
        metadata:
          labels:
            team: "?*"   # ?* 表示任意非空值
            owner: "?*"
```

---

**拒绝privileged容器**:

```yaml
apiVersion: kyverno.io/v1
kind: ClusterPolicy
metadata:
  name: disallow-privileged
spec:
  validationFailureAction: Enforce
  rules:
  - name: check-privileged
    match:
      any:
      - resources:
          kinds:
          - Pod
    validate:
      message: "Privileged containers are not allowed"
      pattern:
        spec:
          containers:
          - =(securityContext):
              =(privileged): false
```

---

#### 2. Mutate (变更)

**添加默认资源限制**:

```yaml
apiVersion: kyverno.io/v1
kind: ClusterPolicy
metadata:
  name: add-default-resources
spec:
  background: false
  rules:
  - name: add-default-resources
    match:
      any:
      - resources:
          kinds:
          - Pod
    mutate:
      patchStrategicMerge:
        spec:
          containers:
          - (name): "*"  # 所有容器
            resources:
              limits:
                +(memory): "512Mi"  # + 表示如果不存在则添加
                +(cpu): "500m"
              requests:
                +(memory): "256Mi"
                +(cpu): "250m"
```

---

**添加imagePullSecrets**:

```yaml
apiVersion: kyverno.io/v1
kind: ClusterPolicy
metadata:
  name: add-imagepullsecrets
spec:
  background: false
  rules:
  - name: add-imagepullsecrets
    match:
      any:
      - resources:
          kinds:
          - Pod
    mutate:
      patchStrategicMerge:
        spec:
          +(imagePullSecrets):
          - name: regcred
```

---

#### 3. Generate (生成)

**自动为Namespace生成NetworkPolicy**:

```yaml
apiVersion: kyverno.io/v1
kind: ClusterPolicy
metadata:
  name: add-networkpolicy
spec:
  rules:
  - name: default-deny-ingress
    match:
      any:
      - resources:
          kinds:
          - Namespace
    generate:
      apiVersion: networking.k8s.io/v1
      kind: NetworkPolicy
      name: default-deny-ingress
      namespace: "{{request.object.metadata.name}}"
      synchronize: true
      data:
        spec:
          podSelector: {}
          policyTypes:
          - Ingress
```

---

**自动为Namespace生成ResourceQuota**:

```yaml
apiVersion: kyverno.io/v1
kind: ClusterPolicy
metadata:
  name: add-resourcequota
spec:
  rules:
  - name: generate-resourcequota
    match:
      any:
      - resources:
          kinds:
          - Namespace
    exclude:
      any:
      - resources:
          namespaces:
          - kube-system
          - kube-public
    generate:
      apiVersion: v1
      kind: ResourceQuota
      name: default-resourcequota
      namespace: "{{request.object.metadata.name}}"
      synchronize: true
      data:
        spec:
          hard:
            requests.cpu: "10"
            requests.memory: "20Gi"
            limits.cpu: "20"
            limits.memory: "40Gi"
```

---

### Kyverno vs OPA

**何时选择 Kyverno**:

```text
✅ Kubernetes专用场景
✅ 团队不熟悉Rego
✅ 需要频繁生成资源 (NetworkPolicy、ResourceQuota)
✅ 快速上手
```

**何时选择 OPA**:

```text
✅ 需要跨平台策略 (K8s + 微服务 + Terraform)
✅ 复杂的策略逻辑 (递归、复杂运算)
✅ 高性能要求 (WASM编译)
✅ 企业标准化策略语言
```

---

### Kyverno 2025新特性

#### 1. ValidatingAdmissionPolicy支持

```yaml
# Kubernetes 1.30+ ValidatingAdmissionPolicy
# Kyverno可生成对应的策略
apiVersion: kyverno.io/v1
kind: ClusterPolicy
metadata:
  name: require-labels
  annotations:
    kyverno.io/generate-validating-admission-policy: "true"
spec:
  # ... Kyverno策略
```

---

#### 2. 增强的CEL支持

**CEL** (Common Expression Language) 是 Kubernetes 1.25+ 的策略语言。

```yaml
apiVersion: kyverno.io/v1
kind: ClusterPolicy
metadata:
  name: restrict-image-registries
spec:
  validationFailureAction: Enforce
  rules:
  - name: check-registry
    match:
      any:
      - resources:
          kinds:
          - Pod
    validate:
      cel:
        expressions:
        - expression: >
            object.spec.containers.all(c,
              c.image.startsWith('gcr.io/') ||
              c.image.startsWith('docker.io/')
            )
          message: "Images must be from gcr.io or docker.io"
```

---

#### 3. Policy Exceptions (策略例外)

```yaml
apiVersion: kyverno.io/v2alpha1
kind: PolicyException
metadata:
  name: allow-privileged-for-monitoring
spec:
  exceptions:
  - policyName: disallow-privileged
    ruleNames:
    - check-privileged
  match:
    any:
    - resources:
        kinds:
        - Pod
        namespaces:
        - monitoring
        names:
        - prometheus-*
```

---

#### 4. Cleanup Policies (清理策略)

**自动清理旧Job**:

```yaml
apiVersion: kyverno.io/v2alpha1
kind: ClusterCleanupPolicy
metadata:
  name: cleanjobs
spec:
  match:
    any:
    - resources:
        kinds:
        - Job
  conditions:
    all:
    - key: "{{ time_since('', '{{request.object.status.completionTime}}', '') }}"
      operator: GreaterThan
      value: 7d  # 7天后清理
```

---

## 外部授权 (External Authorization)

### ext-authz概述

**ext-authz** 是一种标准，允许外部服务执行**授权决策**。

**架构**:

```text
┌─────────────┐         ┌───────────────┐         ┌─────────────┐
│   客户端    │ ──①──→  │  Envoy/Istio  │ ──②──→  │  OPA/自定义  │
└─────────────┘         │     Proxy     │         │  授权服务    │
                        └───────────────┘         └─────────────┘
                              │     ▲                     │
                              │     │                     │
                              └─ ③──┴──────④─────────────┘
                           Allow/Deny       决策日志
```

**流程**:

```text
① 客户端发送请求
② Proxy转发授权请求到外部服务
③ 外部服务返回Allow/Deny
④ Proxy执行决策 (放行/拒绝)
```

---

### Envoy External Authorization

**Envoy配置**:

```yaml
static_resources:
  listeners:
  - address:
      socket_address:
        address: 0.0.0.0
        port_value: 8080
    filter_chains:
    - filters:
      - name: envoy.filters.network.http_connection_manager
        typed_config:
          "@type": type.googleapis.com/envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager
          http_filters:
          # External Authorization Filter
          - name: envoy.filters.http.ext_authz
            typed_config:
              "@type": type.googleapis.com/envoy.extensions.filters.http.ext_authz.v3.ExtAuthz
              transport_api_version: V3
              grpc_service:
                envoy_grpc:
                  cluster_name: ext_authz
                timeout: 0.5s
          # Router Filter
          - name: envoy.filters.http.router
            typed_config:
              "@type": type.googleapis.com/envoy.extensions.filters.http.router.v3.Router
  clusters:
  - name: ext_authz
    type: STRICT_DNS
    lb_policy: ROUND_ROBIN
    typed_extension_protocol_options:
      envoy.extensions.upstreams.http.v3.HttpProtocolOptions:
        "@type": type.googleapis.com/envoy.extensions.upstreams.http.v3.HttpProtocolOptions
        explicit_http_config:
          http2_protocol_options: {}
    load_assignment:
      cluster_name: ext_authz
      endpoints:
      - lb_endpoints:
        - endpoint:
            address:
              socket_address:
                address: opa
                port_value: 9191  # OPA gRPC端口
```

---

### Istio Authorization

**Istio 支持三种授权模式**:

```text
1. 内置Authorization Policy (推荐)
2. ext-authz (OPA/自定义)
3. Custom Authorization Provider
```

---

#### 方式1: Istio AuthorizationPolicy

```yaml
apiVersion: security.istio.io/v1
kind: AuthorizationPolicy
metadata:
  name: allow-read
  namespace: default
spec:
  selector:
    matchLabels:
      app: my-app
  action: ALLOW
  rules:
  - from:
    - source:
        principals: ["cluster.local/ns/default/sa/frontend"]
    to:
    - operation:
        methods: ["GET"]
        paths: ["/api/*"]
```

---

#### 方式2: Istio + OPA (ext-authz)

**安装OPA**:

```yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: opa-policy
  namespace: istio-system
data:
  policy.rego: |
    package istio.authz
    
    import rego.v1
    
    default allow := false
    
    # 允许GET请求
    allow if {
        input.attributes.request.http.method == "GET"
    }
    
    # 允许admin角色
    allow if {
        input.attributes.request.http.headers["x-user-role"] == "admin"
    }
---
apiVersion: v1
kind: Service
metadata:
  name: opa
  namespace: istio-system
spec:
  selector:
    app: opa
  ports:
  - name: grpc
    port: 9191
    targetPort: 9191
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: opa
  namespace: istio-system
spec:
  replicas: 2
  selector:
    matchLabels:
      app: opa
  template:
    metadata:
      labels:
        app: opa
    spec:
      containers:
      - name: opa
        image: openpolicyagent/opa:0.68.0-istio
        args:
        - "run"
        - "--server"
        - "--addr=0.0.0.0:8181"
        - "--diagnostic-addr=0.0.0.0:8282"
        - "--set=plugins.envoy_ext_authz_grpc.addr=:9191"
        - "--set=plugins.envoy_ext_authz_grpc.path=istio/authz/allow"
        - "--set=decision_logs.console=true"
        - "/policies/policy.rego"
        ports:
        - containerPort: 9191
          name: grpc
        - containerPort: 8181
          name: http
        volumeMounts:
        - name: policy
          mountPath: /policies
      volumes:
      - name: policy
        configMap:
          name: opa-policy
```

**配置Istio使用OPA**:

```yaml
apiVersion: networking.istio.io/v1beta1
kind: EnvoyFilter
metadata:
  name: ext-authz-opa
  namespace: istio-system
spec:
  configPatches:
  - applyTo: HTTP_FILTER
    match:
      context: SIDECAR_INBOUND
      listener:
        filterChain:
          filter:
            name: "envoy.filters.network.http_connection_manager"
            subFilter:
              name: "envoy.filters.http.router"
    patch:
      operation: INSERT_BEFORE
      value:
        name: envoy.filters.http.ext_authz
        typed_config:
          "@type": type.googleapis.com/envoy.extensions.filters.http.ext_authz.v3.ExtAuthz
          transport_api_version: V3
          grpc_service:
            envoy_grpc:
              cluster_name: outbound|9191||opa.istio-system.svc.cluster.local
            timeout: 0.5s
```

---

## Policy-as-Code最佳实践

### 策略即代码概念

**Policy-as-Code** 是将策略以代码形式管理的实践。

**核心原则**:

```text
✅ 版本控制 (Git)
✅ Code Review
✅ CI/CD自动化
✅ 测试驱动 (TDD)
✅ 文档化
```

---

### 策略CI/CD

**GitOps工作流**:

```text
1. 开发策略 (policy.rego / kyverno-policy.yaml)
   ↓
2. 单元测试 (opa test / kyverno test)
   ↓
3. 提交PR (Git)
   ↓
4. CI检查 (Lint + Test)
   ↓
5. Code Review
   ↓
6. 合并到main
   ↓
7. CD部署到集群 (ArgoCD / Flux)
   ↓
8. 审计模式验证 (Audit)
   ↓
9. 强制模式上线 (Enforce)
```

---

### 策略测试

#### OPA测试示例

**策略文件** (`policy.rego`):

```rego
package kubernetes.admission

import rego.v1

deny contains msg if {
    input.request.kind.kind == "Pod"
    some container in input.request.object.spec.containers
    not startswith(container.image, "gcr.io/")
    msg := sprintf("Image '%s' not from gcr.io", [container.image])
}
```

**测试文件** (`policy_test.rego`):

```rego
package kubernetes.admission

import rego.v1

# 测试: 允许gcr.io镜像
test_allowed_image if {
    input := {
        "request": {
            "kind": {"kind": "Pod"},
            "object": {
                "spec": {
                    "containers": [
                        {"image": "gcr.io/my-project/my-app:v1.0"}
                    ]
                }
            }
        }
    }
    count(deny) == 0
}

# 测试: 拒绝其他镜像
test_denied_image if {
    input := {
        "request": {
            "kind": {"kind": "Pod"},
            "object": {
                "spec": {
                    "containers": [
                        {"image": "docker.io/nginx:latest"}
                    ]
                }
            }
        }
    }
    count(deny) == 1
}
```

**运行测试**:

```bash
# OPA测试
opa test policy.rego policy_test.rego -v

# 输出:
# policy_test.rego:
#   test_allowed_image: PASS (0.5ms)
#   test_denied_image: PASS (0.3ms)
# ──────────────────────────────────
# PASS: 2/2
```

---

#### Kyverno测试示例

**策略文件** (`policy.yaml`):

```yaml
apiVersion: kyverno.io/v1
kind: ClusterPolicy
metadata:
  name: require-labels
spec:
  validationFailureAction: Enforce
  rules:
  - name: check-team-label
    match:
      any:
      - resources:
          kinds:
          - Pod
    validate:
      message: "Pod must have 'team' label"
      pattern:
        metadata:
          labels:
            team: "?*"
```

**测试用例** (`test.yaml`):

```yaml
apiVersion: cli.kyverno.io/v1alpha1
kind: Test
metadata:
  name: require-labels-test
policies:
- policy.yaml
resources:
- resources/good-pod.yaml
- resources/bad-pod.yaml
results:
- policy: require-labels
  rule: check-team-label
  resource: good-pod
  kind: Pod
  result: pass
- policy: require-labels
  rule: check-team-label
  resource: bad-pod
  kind: Pod
  result: fail
```

**测试资源** (`resources/good-pod.yaml`):

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: good-pod
  labels:
    team: platform
spec:
  containers:
  - name: nginx
    image: nginx:1.27
```

**测试资源** (`resources/bad-pod.yaml`):

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: bad-pod
spec:
  containers:
  - name: nginx
    image: nginx:1.27
```

**运行测试**:

```bash
# Kyverno CLI测试
kyverno test .

# 输出:
# Executing require-labels-test...
# 
# │ Policy         │ Rule           │ Resource │ Result │
# ├────────────────┼────────────────┼──────────┼────────┤
# │ require-labels │ check-team-label │ good-pod │ Pass   │
# │ require-labels │ check-team-label │ bad-pod  │ Fail   │
# 
# Test Summary: 2 tests passed, 0 tests failed
```

---

## 属性访问控制 (ABAC)

### RBAC vs ABAC

| 维度 | RBAC | ABAC |
|------|------|------|
| **控制粒度** | 角色 | 属性 (用户、资源、环境) |
| **灵活性** | 低 | 高 |
| **复杂度** | 低 | 高 |
| **性能** | 高 | 中 |
| **适用场景** | 大多数企业 | 复杂权限逻辑 |

**ABAC示例场景**:

```text
场景: 文档访问控制

RBAC: 
- Editor角色可以编辑所有文档
- Viewer角色可以查看所有文档

ABAC:
- 用户可以编辑自己创建的文档
- 用户可以查看部门内的文档
- 用户可以查看标记为"public"的文档
- 在工作时间内，用户可以访问敏感文档
```

---

### Kubernetes ABAC实现

**Kubernetes原生ABAC** (已废弃，不推荐):

```json
{
  "apiVersion": "abac.authorization.kubernetes.io/v1beta1",
  "kind": "Policy",
  "spec": {
    "user": "alice",
    "namespace": "project-a",
    "resource": "pods",
    "readonly": true
  }
}
```

**推荐方式: OPA实现ABAC**:

```rego
package kubernetes.admission

import rego.v1

# ABAC规则: 用户只能访问自己namespace的资源
allow if {
    # 用户属性
    user := input.user.name
    user_team := user_attributes[user].team
    
    # 资源属性
    resource_namespace := input.request.namespace
    namespace_team := namespace_attributes[resource_namespace].team
    
    # 环境属性
    current_hour := time.clock(time.now_ns())[0]
    is_work_hours := current_hour >= 9
    is_work_hours := current_hour < 18
    
    # ABAC决策
    user_team == namespace_team
    is_work_hours
}

# 用户属性数据
user_attributes := {
    "alice": {"team": "platform"},
    "bob": {"team": "product"}
}

# Namespace属性数据
namespace_attributes := {
    "platform-ns": {"team": "platform"},
    "product-ns": {"team": "product"}
}
```

---

## AWS Cedar策略语言

### Cedar概述

**Cedar** 是 **AWS** 开源的策略语言，用于**细粒度授权**。

**官网**: https://cedarpolicy.com/

**核心特性**:

```text
✅ 简单易读 (比Rego更接近自然语言)
✅ 类型安全
✅ 高性能
✅ 形式化验证
```

---

### Cedar vs Rego

**Cedar示例**:

```cedar
// 允许platform团队成员访问platform-ns
permit (
  principal in Team::"platform",
  action == Action::"get",
  resource in Namespace::"platform-ns"
);

// 拒绝在非工作时间访问敏感资源
forbid (
  principal,
  action,
  resource has sensitivity && resource.sensitivity == "high"
)
when {
  context.time.hour < 9 || context.time.hour >= 18
};
```

**等效的Rego**:

```rego
package example

import rego.v1

allow if {
    input.principal.team == "platform"
    input.action == "get"
    input.resource.namespace == "platform-ns"
}

deny if {
    input.resource.sensitivity == "high"
    hour := time.clock(input.context.time)[0]
    hour < 9
} else if {
    input.resource.sensitivity == "high"
    hour := time.clock(input.context.time)[0]
    hour >= 18
}
```

**对比**:

| 特性 | Cedar | Rego |
|------|-------|------|
| **可读性** | ✅ 高 (permit/forbid) | 中 (需理解逻辑编程) |
| **类型安全** | ✅ 强类型 | 弱类型 |
| **性能** | ✅ 高 | ✅ 高 (WASM编译) |
| **生态** | 新 (AWS支持) | 成熟 (CNCF) |
| **适用范围** | 通用 | 通用 |

---

## 多租户权限隔离

### Namespace隔离

**为每个租户创建Namespace**:

```yaml
apiVersion: v1
kind: Namespace
metadata:
  name: tenant-acme
  labels:
    tenant: acme
    tier: enterprise
---
apiVersion: v1
kind: ServiceAccount
metadata:
  name: acme-admin
  namespace: tenant-acme
---
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: acme-admin-binding
  namespace: tenant-acme
subjects:
- kind: ServiceAccount
  name: acme-admin
roleRef:
  kind: ClusterRole
  name: admin
  apiGroup: rbac.authorization.k8s.io
```

---

### 网络策略隔离

**租户间网络隔离**:

```yaml
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: deny-from-other-namespaces
  namespace: tenant-acme
spec:
  podSelector: {}
  policyTypes:
  - Ingress
  ingress:
  # 只允许同namespace的流量
  - from:
    - podSelector: {}
  # 允许Ingress Controller
  - from:
    - namespaceSelector:
        matchLabels:
          name: ingress-nginx
```

---

### Virtual Cluster

**vcluster** (虚拟集群) 是更强的隔离方案。

**安装vcluster**:

```bash
# 安装vcluster CLI
curl -L -o vcluster "https://github.com/loft-sh/vcluster/releases/latest/download/vcluster-linux-amd64"
chmod +x vcluster
sudo mv vcluster /usr/local/bin

# 创建虚拟集群
vcluster create tenant-acme \
  --namespace tenant-acme \
  --expose

# 连接到虚拟集群
vcluster connect tenant-acme --namespace tenant-acme
```

**优势**:

```text
✅ 完全隔离 (独立API Server + etcd)
✅ 租户有完整的K8s API访问
✅ 资源在宿主集群中共享 (高效)
✅ 无需多集群管理
```

---

## 审计与合规

### Kubernetes Audit

**启用审计日志**:

```yaml
# /etc/kubernetes/audit-policy.yaml
apiVersion: audit.k8s.io/v1
kind: Policy
rules:
# 记录Secrets读取
- level: RequestResponse
  resources:
  - group: ""
    resources: ["secrets"]
  verbs: ["get", "list"]

# 记录RBAC变更
- level: RequestResponse
  resources:
  - group: "rbac.authorization.k8s.io"
    resources: ["roles", "rolebindings", "clusterroles", "clusterrolebindings"]
  verbs: ["create", "update", "delete"]

# 记录Pod删除
- level: Metadata
  resources:
  - group: ""
    resources: ["pods"]
  verbs: ["delete"]

# 其他请求只记录元数据
- level: Metadata
```

**kube-apiserver配置**:

```yaml
# /etc/kubernetes/manifests/kube-apiserver.yaml
apiVersion: v1
kind: Pod
metadata:
  name: kube-apiserver
spec:
  containers:
  - name: kube-apiserver
    command:
    - kube-apiserver
    - --audit-policy-file=/etc/kubernetes/audit-policy.yaml
    - --audit-log-path=/var/log/kubernetes/audit.log
    - --audit-log-maxage=30
    - --audit-log-maxbackup=10
    - --audit-log-maxsize=100
```

---

### Falco运行时审计

**Falco规则: 检测权限提升**:

```yaml
- rule: Privilege Escalation Detected
  desc: Detect attempts to escalate privileges
  condition: >
    spawned_process and
    proc.name in (sudo, su) and
    not proc.pname in (sshd, login)
  output: >
    Privilege escalation detected
    (user=%user.name command=%proc.cmdline container=%container.name)
  priority: WARNING
  tags: [process, privilege_escalation]
```

**Falco规则: 检测敏感文件访问**:

```yaml
- rule: Sensitive File Access
  desc: Detect access to sensitive files
  condition: >
    open_read and
    fd.name in (/etc/shadow, /etc/passwd, /root/.ssh/id_rsa) and
    not proc.name in (sshd, systemd)
  output: >
    Sensitive file accessed
    (file=%fd.name user=%user.name command=%proc.cmdline)
  priority: CRITICAL
  tags: [filesystem, sensitive_data]
```

---

### 合规性检查

**CIS Kubernetes Benchmark (使用kube-bench)**:

```bash
# 运行kube-bench
kubectl apply -f https://raw.githubusercontent.com/aquasecurity/kube-bench/main/job.yaml

# 查看结果
kubectl logs -f job/kube-bench

# 输出示例:
# [INFO] 5 Kubernetes Policies
# [INFO] 5.1 RBAC and Service Accounts
# [PASS] 5.1.1 Ensure that the cluster-admin role is only used where required
# [FAIL] 5.1.3 Minimize wildcard use in Roles and ClusterRoles
# [PASS] 5.1.4 Minimize access to create pods
```

---

## 生产实践案例

### 企业RBAC方案

**角色层次结构**:

```text
┌─────────────────────────────────────────┐
│        Platform Admin (平台管理员)       │  → 集群级别
│  - 管理节点                              │
│  - 管理Namespace                         │
│  - 管理RBAC                              │
└─────────────────────────────────────────┘
                ↓
┌─────────────────────────────────────────┐
│       Namespace Admin (命名空间管理员)   │  → Namespace级别
│  - 管理Deployment/Service               │
│  - 管理ConfigMap/Secret                 │
│  - 查看日志/指标                         │
└─────────────────────────────────────────┘
                ↓
┌─────────────────────────────────────────┐
│         Developer (开发者)               │  → Namespace级别(受限)
│  - 查看资源                              │
│  - 查看日志                              │
│  - 不能删除                              │
└─────────────────────────────────────────┘
                ↓
┌─────────────────────────────────────────┐
│         Viewer (只读用户)                │  → Namespace级别(只读)
│  - 查看资源                              │
└─────────────────────────────────────────┘
```

**实现**:

```yaml
# Platform Admin (ClusterRole)
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: platform-admin
rules:
- apiGroups: ["*"]
  resources: ["*"]
  verbs: ["*"]
---
# Namespace Admin (ClusterRole)
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: namespace-admin
rules:
- apiGroups: ["", "apps", "batch"]
  resources: ["*"]
  verbs: ["*"]
- apiGroups: ["networking.k8s.io"]
  resources: ["networkpolicies"]
  verbs: ["*"]
---
# Developer (ClusterRole)
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: developer
rules:
- apiGroups: ["", "apps"]
  resources: ["pods", "pods/log", "deployments", "services"]
  verbs: ["get", "list", "watch"]
---
# Viewer (ClusterRole)
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: viewer
rules:
- apiGroups: [""]
  resources: ["*"]
  verbs: ["get", "list", "watch"]
```

---

### 多租户SaaS平台

**租户隔离架构**:

```yaml
# 租户Namespace模板
apiVersion: v1
kind: Namespace
metadata:
  name: tenant-${TENANT_ID}
  labels:
    tenant-id: ${TENANT_ID}
    tier: ${TIER}  # free/pro/enterprise
---
# 租户ResourceQuota (根据tier设置)
apiVersion: v1
kind: ResourceQuota
metadata:
  name: tenant-quota
  namespace: tenant-${TENANT_ID}
spec:
  hard:
    requests.cpu: ${CPU_QUOTA}
    requests.memory: ${MEMORY_QUOTA}
    persistentvolumeclaims: ${PVC_QUOTA}
    services.loadbalancers: ${LB_QUOTA}
---
# 租户NetworkPolicy (隔离)
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: tenant-isolation
  namespace: tenant-${TENANT_ID}
spec:
  podSelector: {}
  policyTypes:
  - Ingress
  - Egress
  ingress:
  # 只允许Ingress Controller
  - from:
    - namespaceSelector:
        matchLabels:
          name: ingress-nginx
  egress:
  # 允许DNS
  - to:
    - namespaceSelector:
        matchLabels:
          name: kube-system
    ports:
    - protocol: UDP
      port: 53
  # 允许外部API
  - to:
    - namespaceSelector: {}
    ports:
    - protocol: TCP
      port: 443
---
# OPA策略: 租户只能访问自己的资源
apiVersion: v1
kind: ConfigMap
metadata:
  name: tenant-policy
data:
  policy.rego: |
    package kubernetes.admission
    
    import rego.v1
    
    deny contains msg if {
        # 获取租户ID
        tenant_id := input.request.userInfo.extra["tenant-id"][0]
        # 获取请求的Namespace
        request_ns := input.request.namespace
        # 验证租户只能访问自己的Namespace
        not startswith(request_ns, sprintf("tenant-%s", [tenant_id]))
        msg := "Access denied: cannot access other tenant's resources"
    }
```

---

### 金融行业合规

**PCI DSS要求**:

```text
1. 网络隔离 (Requirement 1)
   → NetworkPolicy

2. 访问控制 (Requirement 7)
   → RBAC + 最小权限

3. 审计日志 (Requirement 10)
   → Kubernetes Audit + Falco

4. 数据加密 (Requirement 3)
   → etcd加密 + Secret管理
```

**实现**:

```yaml
# 1. 严格的NetworkPolicy
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: pci-scope-isolation
  namespace: payment-processing
spec:
  podSelector:
    matchLabels:
      pci-scope: "true"
  policyTypes:
  - Ingress
  - Egress
  ingress:
  # 只允许来自API网关的流量
  - from:
    - podSelector:
        matchLabels:
          app: api-gateway
  egress:
  # 只允许访问数据库和外部支付网关
  - to:
    - podSelector:
        matchLabels:
          app: postgres
  - to:
    - namespaceSelector:
        matchLabels:
          name: external
    podSelector:
      matchLabels:
        service: payment-gateway
---
# 2. OPA策略: 强制TLS + 镜像扫描
apiVersion: v1
kind: ConfigMap
metadata:
  name: pci-policy
data:
  policy.rego: |
    package kubernetes.admission
    
    import rego.v1
    
    # 强制PCI范围内的Pod使用TLS
    deny contains msg if {
        input.request.namespace == "payment-processing"
        some container in input.request.object.spec.containers
        not has_tls_volume(container)
        msg := "PCI-scoped pods must mount TLS certificates"
    }
    
    # 强制镜像扫描
    deny contains msg if {
        input.request.namespace == "payment-processing"
        some container in input.request.object.spec.containers
        not container.image_scanned  # 需自定义逻辑检查
        msg := "Images must be scanned before deployment"
    }
    
    has_tls_volume(container) if {
        some mount in container.volumeMounts
        mount.name == "tls-certs"
    }
---
# 3. Falco规则: 检测未授权访问
apiVersion: v1
kind: ConfigMap
metadata:
  name: falco-pci-rules
data:
  rules.yaml: |
    - rule: Unauthorized Access to PCI Data
      desc: Detect unauthorized access to cardholder data
      condition: >
        open_read and
        fd.name startswith "/var/data/cardholder" and
        not proc.name in (payment-app, backup-agent)
      output: >
        Unauthorized access to PCI data
        (file=%fd.name user=%user.name command=%proc.cmdline)
      priority: CRITICAL
      tags: [pci, data_access]
```

---

## 总结

### 技术选型指南

```text
场景1: Kubernetes基础授权
→ Kubernetes RBAC
  理由: 简单、高效、原生支持

场景2: Kubernetes策略管理 (入门)
→ Kyverno
  理由: Kubernetes原生、易上手

场景3: Kubernetes策略管理 (复杂逻辑)
→ OPA/Gatekeeper
  理由: 强大的Rego语言、跨平台

场景4: 微服务API授权
→ OPA + ext-authz
  理由: 与Envoy/Istio集成、统一策略

场景5: 多租户SaaS
→ Namespace + RBAC + OPA + NetworkPolicy
  理由: 多层隔离、灵活策略

场景6: 金融/医疗合规
→ RBAC + OPA + Falco + Audit
  理由: 完整的审计链、合规性证明
```

---

### 2025年趋势

```text
1. ✅ Policy-as-Code主流化
   - 策略Git管理 + CI/CD
   - 策略测试自动化

2. ✅ 零信任架构普及
   - 动态授权 (ext-authz)
   - 持续验证

3. ✅ eBPF运行时策略
   - Tetragon、Falco
   - 内核级策略执行

4. ✅ 多云统一策略
   - OPA/Cedar跨平台
   - 统一策略语言

5. ✅ AI辅助策略生成
   - 策略推荐
   - 异常检测
```

---

### 最佳实践Checklist

```text
✅ 实施最小权限原则
✅ 使用ServiceAccount而非User证书
✅ 定期审计RBAC绑定 (rbac-tool)
✅ 策略代码化管理 (Git)
✅ 策略单元测试 (opa test / kyverno test)
✅ 先Audit模式，再Enforce
✅ 启用Kubernetes Audit日志
✅ 部署Falco运行时检测
✅ 多租户网络隔离 (NetworkPolicy)
✅ 定期扫描合规性 (kube-bench)
```

---

## 相关文档

**本模块文档**:

- [2025安全新标准](05_2025安全新标准.md)
- [服务网格](../05_服务网格/README.md)

**外部资源**:

- [OPA官方文档](https://www.openpolicyagent.org/docs/latest/)
- [Gatekeeper GitHub](https://github.com/open-policy-agent/gatekeeper)
- [Kyverno官方文档](https://kyverno.io/)
- [Cedar官方文档](https://www.cedarpolicy.com/)
- [Kubernetes RBAC文档](https://kubernetes.io/docs/reference/access-authn-authz/rbac/)
- [Istio Authorization](https://istio.io/latest/docs/reference/config/security/authorization-policy/)

---

**更新时间**: 2025-10-20  
**文档版本**: v1.0  
**状态**: ✅ **已完成**

**🔐 本文档全面覆盖2025年云原生权限管理与策略控制技术！🔐**-
