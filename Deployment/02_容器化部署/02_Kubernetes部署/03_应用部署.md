# Kubernetes应用部署

> **返回**: [Kubernetes部署目录](README.md) | [容器化部署首页](../README.md) | [部署指南首页](../../00_索引导航/README.md)

---

## 📋 目录

- [Kubernetes应用部署](#kubernetes应用部署)
  - [📋 目录](#-目录)
  - [1. Pod详解](#1-pod详解)
  - [2. Deployment](#2-deployment)
  - [3. StatefulSet](#3-statefulset)
  - [4. DaemonSet](#4-daemonset)
  - [5. Job与CronJob](#5-job与cronjob)
  - [6. Service](#6-service)
  - [7. Ingress](#7-ingress)
  - [8. ConfigMap与Secret](#8-configmap与secret)
  - [9. 持久化存储](#9-持久化存储)
  - [10. 应用部署最佳实践](#10-应用部署最佳实践)
  - [相关文档](#相关文档)

---

## 1. Pod详解

```yaml
Pod_Overview:
  定义:
    - Kubernetes最小部署单元
    - 一个或多个容器的集合
    - 共享网络和存储
    - 同生共死
  
  Pod生命周期:
    Pending: 等待调度或拉取镜像
    Running: 至少一个容器运行中
    Succeeded: 所有容器成功终止
    Failed: 至少一个容器失败
    Unknown: 状态未知
  
  容器类型:
    Init容器:
      - 初始化任务
      - 串行执行
      - 必须成功完成
    
    主容器:
      - 应用容器
      - 并行运行
      - Pod的主要功能
    
    Sidecar容器:
      - 辅助容器
      - 日志收集
      - 代理
      - 监控
  
  容器探针:
    Liveness Probe (存活探针):
      - 检测容器是否存活
      - 失败则重启容器
    
    Readiness Probe (就绪探针):
      - 检测容器是否就绪
      - 失败则从Service移除
    
    Startup Probe (启动探针):
      - 检测容器是否启动
      - 保护慢启动容器
  
  探针类型:
    HTTP GET:
      - HTTP请求检查
      - 返回200-399为成功
    
    TCP Socket:
      - TCP连接检查
      - 连接成功为成功
    
    Exec:
      - 执行命令
      - 退出码0为成功
```

**Pod完整示例**:

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: myapp
  namespace: default
  labels:
    app: myapp
    version: v1
  annotations:
    description: "My application pod"
spec:
  # Init容器
  initContainers:
  - name: init-mydb
    image: busybox:1.28
    command: ['sh', '-c', 'until nslookup mydb; do echo waiting for mydb; sleep 2; done;']
  
  # 主容器
  containers:
  - name: myapp
    image: myapp:v1.0
    imagePullPolicy: IfNotPresent
    
    # 端口
    ports:
    - containerPort: 8080
      name: http
      protocol: TCP
    
    # 环境变量
    env:
    - name: DB_HOST
      value: "mysql"
    - name: DB_PASSWORD
      valueFrom:
        secretKeyRef:
          name: db-secret
          key: password
    
    # 资源限制
    resources:
      requests:
        cpu: "500m"
        memory: "512Mi"
      limits:
        cpu: "1000m"
        memory: "1Gi"
    
    # 存活探针
    livenessProbe:
      httpGet:
        path: /health
        port: 8080
      initialDelaySeconds: 30
      periodSeconds: 10
      timeoutSeconds: 5
      successThreshold: 1
      failureThreshold: 3
    
    # 就绪探针
    readinessProbe:
      httpGet:
        path: /ready
        port: 8080
      initialDelaySeconds: 10
      periodSeconds: 5
      timeoutSeconds: 3
      successThreshold: 1
      failureThreshold: 3
    
    # 启动探针
    startupProbe:
      httpGet:
        path: /startup
        port: 8080
      initialDelaySeconds: 0
      periodSeconds: 10
      timeoutSeconds: 3
      failureThreshold: 30
    
    # 生命周期钩子
    lifecycle:
      postStart:
        exec:
          command: ["/bin/sh", "-c", "echo Hello from postStart > /usr/share/message"]
      preStop:
        exec:
          command: ["/bin/sh", "-c", "nginx -s quit; while killall -0 nginx; do sleep 1; done"]
    
    # 卷挂载
    volumeMounts:
    - name: config
      mountPath: /etc/config
      readOnly: true
    - name: data
      mountPath: /data
  
  # Sidecar容器
  - name: log-collector
    image: fluent/fluentd:v1.14
    volumeMounts:
    - name: varlog
      mountPath: /var/log
  
  # 卷
  volumes:
  - name: config
    configMap:
      name: myapp-config
  - name: data
    persistentVolumeClaim:
      claimName: myapp-pvc
  - name: varlog
    emptyDir: {}
  
  # 调度相关
  nodeSelector:
    disktype: ssd
  
  affinity:
    nodeAffinity:
      requiredDuringSchedulingIgnoredDuringExecution:
        nodeSelectorTerms:
        - matchExpressions:
          - key: kubernetes.io/hostname
            operator: In
            values:
            - node01
            - node02
  
  tolerations:
  - key: "key1"
    operator: "Equal"
    value: "value1"
    effect: "NoSchedule"
  
  # 安全上下文
  securityContext:
    runAsUser: 1000
    runAsGroup: 3000
    fsGroup: 2000
  
  # 重启策略
  restartPolicy: Always  # Always, OnFailure, Never
  
  # DNS策略
  dnsPolicy: ClusterFirst
  
  # 服务账号
  serviceAccountName: myapp-sa
  
  # 镜像拉取密钥
  imagePullSecrets:
  - name: regcred
```

---

## 2. Deployment

```yaml
Deployment_Overview:
  定义:
    - 无状态应用部署
    - 声明式更新
    - 滚动更新
    - 版本回滚
  
  功能:
    副本管理:
      - 维护指定副本数
      - 自动替换失败Pod
    
    滚动更新:
      - 逐步替换旧Pod
      - 零停机更新
      - 可配置更新策略
    
    版本回滚:
      - 保留历史版本
      - 快速回滚
      - 版本历史查询
  
  更新策略:
    RollingUpdate (滚动更新):
      maxSurge: 超出期望副本数的最大值
      maxUnavailable: 不可用副本的最大值
    
    Recreate (重建):
      - 先删除所有旧Pod
      - 再创建新Pod
      - 会有停机时间
```

**Deployment示例**:

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: nginx-deployment
  namespace: default
  labels:
    app: nginx
spec:
  # 副本数
  replicas: 3
  
  # 选择器
  selector:
    matchLabels:
      app: nginx
  
  # 更新策略
  strategy:
    type: RollingUpdate
    rollingUpdate:
      maxSurge: 1        # 最多超出1个Pod
      maxUnavailable: 1  # 最多1个不可用
  
  # 版本历史限制
  revisionHistoryLimit: 10
  
  # Pod模板
  template:
    metadata:
      labels:
        app: nginx
        version: v1.21
    spec:
      containers:
      - name: nginx
        image: nginx:1.21-alpine
        ports:
        - containerPort: 80
        resources:
          requests:
            cpu: 100m
            memory: 128Mi
          limits:
            cpu: 250m
            memory: 256Mi
        livenessProbe:
          httpGet:
            path: /
            port: 80
          initialDelaySeconds: 30
          periodSeconds: 10
        readinessProbe:
          httpGet:
            path: /
            port: 80
          initialDelaySeconds: 5
          periodSeconds: 5
```

**Deployment管理命令**:

```bash
# 创建Deployment
kubectl create deployment nginx --image=nginx:1.21 --replicas=3

# 或使用YAML
kubectl apply -f deployment.yaml

# 查看Deployment
kubectl get deployments
kubectl describe deployment nginx-deployment

# 查看ReplicaSet
kubectl get rs

# 查看Pods
kubectl get pods -l app=nginx

# 扩缩容
kubectl scale deployment nginx-deployment --replicas=5

# 自动扩缩容
kubectl autoscale deployment nginx-deployment --min=3 --max=10 --cpu-percent=80

# 更新镜像
kubectl set image deployment/nginx-deployment nginx=nginx:1.22

# 查看更新状态
kubectl rollout status deployment/nginx-deployment

# 查看更新历史
kubectl rollout history deployment/nginx-deployment

# 回滚到上一版本
kubectl rollout undo deployment/nginx-deployment

# 回滚到指定版本
kubectl rollout undo deployment/nginx-deployment --to-revision=2

# 暂停/恢复更新
kubectl rollout pause deployment/nginx-deployment
kubectl rollout resume deployment/nginx-deployment

# 重启Deployment
kubectl rollout restart deployment/nginx-deployment

# 删除Deployment
kubectl delete deployment nginx-deployment
```

---

## 3. StatefulSet

```yaml
StatefulSet_Overview:
  定义:
    - 有状态应用部署
    - 稳定的持久化存储
    - 稳定的网络标识
    - 有序部署和扩展
  
  特性:
    稳定标识:
      - 固定Pod名称: <statefulset-name>-<ordinal>
      - 固定hostname
      - 固定DNS域名
    
    有序操作:
      - 按顺序部署 (0, 1, 2...)
      - 按逆序删除 (2, 1, 0...)
      - 滚动更新顺序可控
    
    持久化存储:
      - volumeClaimTemplates
      - 每个Pod独立PVC
      - PVC生命周期独立于Pod
  
  适用场景:
    - 数据库 (MySQL, PostgreSQL, MongoDB)
    - 消息队列 (Kafka, RabbitMQ)
    - 分布式存储 (Ceph, HDFS)
    - 有状态中间件
```

**StatefulSet示例 - MySQL主从**:

```yaml
apiVersion: v1
kind: Service
metadata:
  name: mysql
  labels:
    app: mysql
spec:
  ports:
  - port: 3306
    name: mysql
  clusterIP: None  # Headless Service
  selector:
    app: mysql
---
apiVersion: apps/v1
kind: StatefulSet
metadata:
  name: mysql
spec:
  serviceName: mysql
  replicas: 3
  selector:
    matchLabels:
      app: mysql
  template:
    metadata:
      labels:
        app: mysql
    spec:
      initContainers:
      - name: init-mysql
        image: mysql:8.0
        command:
        - bash
        - "-c"
        - |
          set -ex
          # 从Pod序号生成server-id
          [[ `hostname` =~ -([0-9]+)$ ]] || exit 1
          ordinal=${BASH_REMATCH[1]}
          echo [mysqld] > /mnt/conf.d/server-id.cnf
          echo server-id=$((100 + $ordinal)) >> /mnt/conf.d/server-id.cnf
          # 主节点配置
          if [[ $ordinal -eq 0 ]]; then
            cp /mnt/config-map/primary.cnf /mnt/conf.d/
          else
            cp /mnt/config-map/replica.cnf /mnt/conf.d/
          fi
        volumeMounts:
        - name: conf
          mountPath: /mnt/conf.d
        - name: config-map
          mountPath: /mnt/config-map
      
      containers:
      - name: mysql
        image: mysql:8.0
        env:
        - name: MYSQL_ROOT_PASSWORD
          valueFrom:
            secretKeyRef:
              name: mysql-secret
              key: password
        ports:
        - containerPort: 3306
          name: mysql
        volumeMounts:
        - name: data
          mountPath: /var/lib/mysql
        - name: conf
          mountPath: /etc/mysql/conf.d
        resources:
          requests:
            cpu: 500m
            memory: 1Gi
          limits:
            cpu: 1000m
            memory: 2Gi
        livenessProbe:
          exec:
            command: ["mysqladmin", "ping"]
          initialDelaySeconds: 30
          periodSeconds: 10
        readinessProbe:
          exec:
            command: ["mysql", "-h", "127.0.0.1", "-e", "SELECT 1"]
          initialDelaySeconds: 5
          periodSeconds: 2
      
      volumes:
      - name: conf
        emptyDir: {}
      - name: config-map
        configMap:
          name: mysql-config
  
  # 持久化卷声明模板
  volumeClaimTemplates:
  - metadata:
      name: data
    spec:
      accessModes: ["ReadWriteOnce"]
      storageClassName: "fast"
      resources:
        requests:
          storage: 10Gi
```

**StatefulSet管理**:

```bash
# 创建StatefulSet
kubectl apply -f statefulset.yaml

# 查看StatefulSet
kubectl get statefulsets
kubectl get sts  # 简写

# 查看Pods (按序号命名)
kubectl get pods -l app=mysql
# mysql-0
# mysql-1
# mysql-2

# 查看PVC
kubectl get pvc
# data-mysql-0
# data-mysql-1
# data-mysql-2

# 扩容 (有序)
kubectl scale sts mysql --replicas=5

# 缩容 (逆序)
kubectl scale sts mysql --replicas=2

# 更新镜像
kubectl set image sts/mysql mysql=mysql:8.0.32

# 分区更新 (只更新序号>=partition的Pod)
kubectl patch sts mysql -p '{"spec":{"updateStrategy":{"rollingUpdate":{"partition":2}}}}'

# 删除StatefulSet (保留PVC)
kubectl delete sts mysql --cascade=orphan

# 删除StatefulSet (删除Pods但保留PVC)
kubectl delete sts mysql --cascade=background

# 完全删除
kubectl delete sts mysql
kubectl delete pvc -l app=mysql
```

---

## 4. DaemonSet

```yaml
DaemonSet_Overview:
  定义:
    - 每个节点运行一个Pod
    - 节点增加时自动部署
    - 节点删除时自动清理
  
  适用场景:
    - 节点监控 (Node Exporter, Datadog Agent)
    - 日志收集 (Fluentd, Filebeat)
    - 存储守护进程 (Ceph, GlusterFS)
    - 网络插件 (Calico, Cilium)
  
  更新策略:
    RollingUpdate: 滚动更新
    OnDelete: 手动删除后更新
```

**DaemonSet示例 - Node Exporter**:

```yaml
apiVersion: apps/v1
kind: DaemonSet
metadata:
  name: node-exporter
  namespace: monitoring
  labels:
    app: node-exporter
spec:
  selector:
    matchLabels:
      app: node-exporter
  updateStrategy:
    type: RollingUpdate
    rollingUpdate:
      maxUnavailable: 1
  template:
    metadata:
      labels:
        app: node-exporter
    spec:
      hostNetwork: true
      hostPID: true
      hostIPC: true
      
      # 节点选择器
      nodeSelector:
        kubernetes.io/os: linux
      
      # 容忍所有污点
      tolerations:
      - operator: Exists
      
      containers:
      - name: node-exporter
        image: prom/node-exporter:v1.6.1
        args:
        - --path.procfs=/host/proc
        - --path.sysfs=/host/sys
        - --path.rootfs=/host/root
        - --collector.filesystem.mount-points-exclude=^/(sys|proc|dev|host|etc)($$|/)
        ports:
        - containerPort: 9100
          name: metrics
        resources:
          requests:
            cpu: 100m
            memory: 128Mi
          limits:
            cpu: 250m
            memory: 256Mi
        volumeMounts:
        - name: proc
          mountPath: /host/proc
          readOnly: true
        - name: sys
          mountPath: /host/sys
          readOnly: true
        - name: root
          mountPath: /host/root
          readOnly: true
      
      volumes:
      - name: proc
        hostPath:
          path: /proc
      - name: sys
        hostPath:
          path: /sys
      - name: root
        hostPath:
          path: /
```

---

## 5. Job与CronJob

```yaml
Job_CronJob_Overview:
  Job:
    定义: 一次性任务
    
    特性:
      - 确保Pod成功完成
      - 失败重试
      - 并行执行
      - 自动清理
    
    完成模式:
      - 非并行: 单个Pod
      - 固定完成次数: completions=N
      - 工作队列: parallelism=N
  
  CronJob:
    定义: 定时任务
    
    特性:
      - Cron表达式
      - 自动创建Job
      - 历史限制
      - 并发策略
    
    并发策略:
      Allow: 允许并发
      Forbid: 禁止并发
      Replace: 替换旧Job
```

**Job示例**:

```yaml
apiVersion: batch/v1
kind: Job
metadata:
  name: pi
spec:
  # 完成次数
  completions: 5
  # 并行数
  parallelism: 2
  # 重试次数
  backoffLimit: 4
  # TTL (完成后自动删除)
  ttlSecondsAfterFinished: 100
  
  template:
    spec:
      containers:
      - name: pi
        image: perl:5.34
        command: ["perl", "-Mbignum=bpi", "-wle", "print bpi(2000)"]
        resources:
          requests:
            cpu: 100m
            memory: 128Mi
      restartPolicy: Never  # 或OnFailure
```

**CronJob示例 - 数据库备份**:

```yaml
apiVersion: batch/v1
kind: CronJob
metadata:
  name: mysql-backup
spec:
  # Cron表达式: 每天凌晨2点
  schedule: "0 2 * * *"
  
  # 并发策略
  concurrencyPolicy: Forbid
  
  # 保留历史
  successfulJobsHistoryLimit: 3
  failedJobsHistoryLimit: 1
  
  # 启动截止时间
  startingDeadlineSeconds: 300
  
  jobTemplate:
    spec:
      template:
        spec:
          containers:
          - name: mysql-backup
            image: mysql:8.0
            env:
            - name: MYSQL_HOST
              value: "mysql"
            - name: MYSQL_ROOT_PASSWORD
              valueFrom:
                secretKeyRef:
                  name: mysql-secret
                  key: password
            command:
            - /bin/bash
            - -c
            - |
              set -e
              BACKUP_FILE="/backup/mysql-backup-$(date +%Y%m%d-%H%M%S).sql"
              mysqldump -h $MYSQL_HOST -u root -p$MYSQL_ROOT_PASSWORD --all-databases > $BACKUP_FILE
              echo "Backup completed: $BACKUP_FILE"
            volumeMounts:
            - name: backup
              mountPath: /backup
          volumes:
          - name: backup
            persistentVolumeClaim:
              claimName: backup-pvc
          restartPolicy: OnFailure
```

---

## 6. Service

```yaml
Service_Overview:
  定义:
    - 服务发现与负载均衡
    - 稳定的网络端点
    - 自动更新Endpoints
  
  类型:
    ClusterIP (默认):
      - 集群内部访问
      - 分配ClusterIP
      - 适合内部服务
    
    NodePort:
      - 节点端口访问
      - 30000-32767
      - 外部可访问
    
    LoadBalancer:
      - 云厂商负载均衡器
      - 自动分配外部IP
      - 适合云环境
    
    ExternalName:
      - DNS CNAME记录
      - 外部服务映射
    
    Headless (ClusterIP: None):
      - 无ClusterIP
      - 直接返回Pod IP
      - 适合StatefulSet
```

**Service示例**:

```yaml
# ClusterIP Service
apiVersion: v1
kind: Service
metadata:
  name: myapp-service
spec:
  type: ClusterIP
  selector:
    app: myapp
  ports:
  - name: http
    protocol: TCP
    port: 80        # Service端口
    targetPort: 8080  # Pod端口
  sessionAffinity: ClientIP  # 会话亲和性
  sessionAffinityConfig:
    clientIP:
      timeoutSeconds: 10800

---
# NodePort Service
apiVersion: v1
kind: Service
metadata:
  name: myapp-nodeport
spec:
  type: NodePort
  selector:
    app: myapp
  ports:
  - port: 80
    targetPort: 8080
    nodePort: 30080  # 可选，不指定则自动分配

---
# LoadBalancer Service
apiVersion: v1
kind: Service
metadata:
  name: myapp-lb
spec:
  type: LoadBalancer
  selector:
    app: myapp
  ports:
  - port: 80
    targetPort: 8080
  loadBalancerSourceRanges:
  - 10.0.0.0/8  # IP白名单

---
# Headless Service
apiVersion: v1
kind: Service
metadata:
  name: mysql
spec:
  clusterIP: None
  selector:
    app: mysql
  ports:
  - port: 3306
```

**Service管理命令**:

```bash
# 创建Service
kubectl expose deployment nginx --port=80 --type=NodePort

# 查看Service
kubectl get svc
kubectl describe svc myapp-service

# 查看Endpoints
kubectl get endpoints myapp-service

# 测试Service
kubectl run test-pod --image=busybox:1.28 -it --rm -- sh
# wget -qO- http://myapp-service

# 删除Service
kubectl delete svc myapp-service
```

---

## 7. Ingress

```yaml
Ingress_Overview:
  定义:
    - HTTP/HTTPS路由规则
    - 七层负载均衡
    - 域名路由
    - TLS终止
  
  Ingress Controller:
    - Nginx Ingress Controller (推荐)
    - Traefik
    - HAProxy
    - Kong
    - Istio Gateway
  
  功能:
    - 基于域名路由
    - 基于路径路由
    - TLS/SSL
    - 重定向
    - 重写
    - 限流
    - 认证
```

**Ingress示例**:

```yaml
# 安装Nginx Ingress Controller
kubectl apply -f https://raw.githubusercontent.com/kubernetes/ingress-nginx/controller-v1.8.1/deploy/static/provider/cloud/deploy.yaml

---
# 简单Ingress
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: simple-ingress
  annotations:
    nginx.ingress.kubernetes.io/rewrite-target: /
spec:
  ingressClassName: nginx
  rules:
  - host: myapp.example.com
    http:
      paths:
      - path: /
        pathType: Prefix
        backend:
          service:
            name: myapp-service
            port:
              number: 80

---
# 多域名Ingress
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: multi-host-ingress
spec:
  ingressClassName: nginx
  rules:
  - host: app1.example.com
    http:
      paths:
      - path: /
        pathType: Prefix
        backend:
          service:
            name: app1-service
            port:
              number: 80
  - host: app2.example.com
    http:
      paths:
      - path: /
        pathType: Prefix
        backend:
          service:
            name: app2-service
            port:
              number: 80

---
# 路径路由Ingress
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: path-based-ingress
  annotations:
    nginx.ingress.kubernetes.io/rewrite-target: /$2
spec:
  ingressClassName: nginx
  rules:
  - host: myapp.example.com
    http:
      paths:
      - path: /api(/|$)(.*)
        pathType: Prefix
        backend:
          service:
            name: api-service
            port:
              number: 8080
      - path: /web(/|$)(.*)
        pathType: Prefix
        backend:
          service:
            name: web-service
            port:
              number: 80

---
# TLS Ingress
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: tls-ingress
spec:
  ingressClassName: nginx
  tls:
  - hosts:
    - myapp.example.com
    secretName: myapp-tls-secret
  rules:
  - host: myapp.example.com
    http:
      paths:
      - path: /
        pathType: Prefix
        backend:
          service:
            name: myapp-service
            port:
              number: 80
```

**创建TLS证书**:

```bash
# 生成自签名证书
openssl req -x509 -nodes -days 365 -newkey rsa:2048 \
  -keyout tls.key -out tls.crt \
  -subj "/CN=myapp.example.com/O=myapp"

# 创建Secret
kubectl create secret tls myapp-tls-secret \
  --key tls.key \
  --cert tls.crt
```

---

## 8. ConfigMap与Secret

```yaml
ConfigMap_Secret_Overview:
  ConfigMap:
    用途: 非敏感配置
    
    使用方式:
      - 环境变量
      - 命令行参数
      - 配置文件卷
  
  Secret:
    用途: 敏感信息 (密码、Token、证书)
    
    类型:
      Opaque: 通用Secret (base64编码)
      kubernetes.io/dockerconfigjson: 镜像拉取凭证
      kubernetes.io/tls: TLS证书
      kubernetes.io/service-account-token: SA Token
    
    使用方式:
      - 环境变量
      - 配置文件卷
      - imagePullSecrets
```

**ConfigMap示例**:

```yaml
# 创建ConfigMap
apiVersion: v1
kind: ConfigMap
metadata:
  name: app-config
data:
  # 键值对
  database_url: "mysql://db:3306/myapp"
  log_level: "info"
  
  # 配置文件
  app.conf: |
    server {
      listen 80;
      server_name localhost;
      location / {
        root /usr/share/nginx/html;
        index index.html;
      }
    }
  
  config.json: |
    {
      "apiVersion": "v1",
      "kind": "Config",
      "server": "https://api.example.com"
    }
```

```bash
# 从文件创建
kubectl create configmap app-config --from-file=app.conf

# 从目录创建
kubectl create configmap app-config --from-file=config/

# 从字面值创建
kubectl create configmap app-config \
  --from-literal=database_url=mysql://db:3306 \
  --from-literal=log_level=info
```

**Secret示例**:

```yaml
# Opaque Secret
apiVersion: v1
kind: Secret
metadata:
  name: db-secret
type: Opaque
data:
  username: YWRtaW4=  # admin (base64)
  password: cGFzc3dvcmQxMjM=  # password123 (base64)

---
# Docker Registry Secret
apiVersion: v1
kind: Secret
metadata:
  name: regcred
type: kubernetes.io/dockerconfigjson
data:
  .dockerconfigjson: eyJhdXRocyI6eyJodHRwczovL2luZGV4LmRvY2tlci5pby92MS8iOnsidXNlcm5hbWUiOiJ1c2VyIiwicGFzc3dvcmQiOiJwYXNzd29yZCJ9fX0=

---
# TLS Secret
apiVersion: v1
kind: Secret
metadata:
  name: tls-secret
type: kubernetes.io/tls
data:
  tls.crt: LS0tLS1CRUdJTi...
  tls.key: LS0tLS1CRUdJTi...
```

```bash
# 创建Opaque Secret
kubectl create secret generic db-secret \
  --from-literal=username=admin \
  --from-literal=password=password123

# 创建Docker Registry Secret
kubectl create secret docker-registry regcred \
  --docker-server=https://index.docker.io/v1/ \
  --docker-username=user \
  --docker-password=password \
  --docker-email=user@example.com

# 创建TLS Secret
kubectl create secret tls tls-secret \
  --cert=tls.crt \
  --key=tls.key
```

**使用ConfigMap和Secret**:

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: myapp
spec:
  containers:
  - name: myapp
    image: myapp:v1.0
    
    # 使用ConfigMap作为环境变量
    env:
    - name: DATABASE_URL
      valueFrom:
        configMapKeyRef:
          name: app-config
          key: database_url
    
    # 使用Secret作为环境变量
    - name: DB_PASSWORD
      valueFrom:
        secretKeyRef:
          name: db-secret
          key: password
    
    # 挂载ConfigMap为卷
    volumeMounts:
    - name: config-volume
      mountPath: /etc/config
    
    # 挂载Secret为卷
    - name: secret-volume
      mountPath: /etc/secret
      readOnly: true
  
  volumes:
  - name: config-volume
    configMap:
      name: app-config
      items:
      - key: app.conf
        path: app.conf
  
  - name: secret-volume
    secret:
      secretName: db-secret
  
  # 使用镜像拉取Secret
  imagePullSecrets:
  - name: regcred
```

---

## 9. 持久化存储

```yaml
Persistent_Storage_Overview:
  PersistentVolume (PV):
    - 集群级别资源
    - 管理员创建
    - 独立于Pod生命周期
  
  PersistentVolumeClaim (PVC):
    - 命名空间级别资源
    - 用户申请存储
    - 绑定到PV
  
  StorageClass:
    - 动态供应
    - 存储类别
    - 不同性能等级
  
  访问模式:
    ReadWriteOnce (RWO): 单节点读写
    ReadOnlyMany (ROX): 多节点只读
    ReadWriteMany (RWX): 多节点读写
  
  回收策略:
    Retain: 保留
    Delete: 删除
    Recycle: 回收 (已废弃)
```

**PV和PVC示例**:

```yaml
# PersistentVolume
apiVersion: v1
kind: PersistentVolume
metadata:
  name: pv-nfs
spec:
  capacity:
    storage: 10Gi
  accessModes:
  - ReadWriteMany
  persistentVolumeReclaimPolicy: Retain
  storageClassName: nfs
  nfs:
    server: 192.168.1.100
    path: /data/nfs

---
# PersistentVolumeClaim
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: pvc-app
spec:
  accessModes:
  - ReadWriteOnce
  resources:
    requests:
      storage: 5Gi
  storageClassName: fast

---
# 使用PVC的Pod
apiVersion: v1
kind: Pod
metadata:
  name: app-with-pvc
spec:
  containers:
  - name: app
    image: myapp:v1.0
    volumeMounts:
    - name: data
      mountPath: /data
  volumes:
  - name: data
    persistentVolumeClaim:
      claimName: pvc-app
```

**StorageClass示例**:

```yaml
# NFS StorageClass
apiVersion: storage.k8s.io/v1
kind: StorageClass
metadata:
  name: nfs
provisioner: nfs-client
parameters:
  archiveOnDelete: "false"

---
# Local Path StorageClass
apiVersion: storage.k8s.io/v1
kind: StorageClass
metadata:
  name: local-path
provisioner: rancher.io/local-path
volumeBindingMode: WaitForFirstConsumer
reclaimPolicy: Delete

---
# Rook-Ceph StorageClass
apiVersion: storage.k8s.io/v1
kind: StorageClass
metadata:
  name: rook-ceph-block
provisioner: rook-ceph.rbd.csi.ceph.com
parameters:
  clusterID: rook-ceph
  pool: replicapool
  imageFormat: "2"
  imageFeatures: layering
  csi.storage.k8s.io/provisioner-secret-name: rook-csi-rbd-provisioner
  csi.storage.k8s.io/controller-expand-secret-name: rook-csi-rbd-provisioner
  csi.storage.k8s.io/node-stage-secret-name: rook-csi-rbd-node
reclaimPolicy: Delete
allowVolumeExpansion: true
```

---

## 10. 应用部署最佳实践

```yaml
Deployment_Best_Practices:
  资源管理:
    ✅ 设置requests和limits:
      resources:
        requests:
          cpu: "500m"
          memory: "512Mi"
        limits:
          cpu: "1000m"
          memory: "1Gi"
    
    ✅ 使用HPA自动扩缩容:
      kubectl autoscale deployment myapp --min=3 --max=10 --cpu-percent=80
  
  健康检查:
    ✅ 配置Liveness Probe:
      livenessProbe:
        httpGet:
          path: /health
          port: 8080
        initialDelaySeconds: 30
    
    ✅ 配置Readiness Probe:
      readinessProbe:
        httpGet:
          path: /ready
          port: 8080
        initialDelaySeconds: 5
  
  更新策略:
    ✅ 使用滚动更新:
      strategy:
        type: RollingUpdate
        rollingUpdate:
          maxSurge: 1
          maxUnavailable: 0
    
    ✅ 保留更新历史:
      revisionHistoryLimit: 10
  
  配置管理:
    ✅ 使用ConfigMap:
      - 外部化配置
      - 环境特定配置
    
    ✅ 使用Secret:
      - 敏感信息加密
      - 不要提交到Git
  
  标签和注解:
    ✅ 使用标准标签:
      labels:
        app.kubernetes.io/name: myapp
        app.kubernetes.io/version: v1.0
        app.kubernetes.io/component: backend
        app.kubernetes.io/part-of: myproject
    
    ✅ 使用有意义的注解:
      annotations:
        description: "My application"
        owner: "team@example.com"
  
  安全:
    ✅ 使用非root用户:
      securityContext:
        runAsUser: 1000
        runAsNonRoot: true
    
    ✅ 只读根文件系统:
      securityContext:
        readOnlyRootFilesystem: true
    
    ✅ 限制能力:
      securityContext:
        capabilities:
          drop:
          - ALL
          add:
          - NET_BIND_SERVICE
  
  网络:
    ✅ 使用NetworkPolicy:
      - 限制Pod间通信
      - 最小权限原则
    
    ✅ 使用Ingress:
      - 统一入口
      - TLS终止
  
  监控和日志:
    ✅ 暴露metrics端点:
      - Prometheus格式
      - /metrics路径
    
    ✅ 结构化日志:
      - JSON格式
      - 标准输出/错误
```

---

## 相关文档

- [Kubernetes集群部署](01_集群部署.md)
- [Kubernetes核心组件](02_核心组件.md)
- [Kubernetes资源管理](04_资源管理.md)
- [Kubernetes故障排查](05_故障排查.md)
- [容器网络配置](../03_容器网络/README.md)
- [容器存储配置](../04_容器存储/README.md)

---

**更新时间**: 2025-10-19  
**文档版本**: v1.0  
**状态**: ✅ 生产就绪
