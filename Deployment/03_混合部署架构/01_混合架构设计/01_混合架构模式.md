# 混合架构模式

> **返回**: [混合架构设计首页](README.md) | [混合部署架构首页](../README.md) | [部署指南首页](../../00_索引导航/README.md)

---

## 📋 目录

- [混合架构模式](#混合架构模式)
  - [📋 目录](#-目录)
  - [1. 混合架构概述](#1-混合架构概述)
    - [1.1 什么是混合架构](#11-什么是混合架构)
    - [1.2 混合架构的价值](#12-混合架构的价值)
    - [1.3 混合架构演进路径](#13-混合架构演进路径)
  - [2. 经典三层混合架构](#2-经典三层混合架构)
    - [2.1 架构设计](#21-架构设计)
    - [2.2 技术选型](#22-技术选型)
    - [2.3 实施方案](#23-实施方案)
      - [2.3.1 网络架构](#231-网络架构)
      - [2.3.2 存储架构](#232-存储架构)
    - [2.4 典型案例](#24-典型案例)
  - [3. 微服务混合架构](#3-微服务混合架构)
    - [3.1 架构设计](#31-架构设计)
    - [3.2 服务拆分策略](#32-服务拆分策略)
    - [3.3 服务网格集成](#33-服务网格集成)
    - [3.4 典型案例](#34-典型案例)
  - [4. Serverless 混合架构](#4-serverless-混合架构)
    - [4.1 架构设计](#41-架构设计)
    - [4.2 函数计算集成](#42-函数计算集成)
    - [4.3 事件驱动架构](#43-事件驱动架构)
    - [4.4 典型案例](#44-典型案例)
  - [5. 边缘计算混合架构](#5-边缘计算混合架构)
    - [5.1 架构设计](#51-架构设计)
    - [5.2 边缘节点部署](#52-边缘节点部署)
    - [5.3 云边协同](#53-云边协同)
    - [5.4 典型案例](#54-典型案例)
  - [6. 混合架构对比](#6-混合架构对比)
    - [6.1 架构对比矩阵](#61-架构对比矩阵)
    - [6.2 适用场景](#62-适用场景)
    - [6.3 选型建议](#63-选型建议)
  - [7. 最佳实践](#7-最佳实践)
    - [7.1 架构设计原则](#71-架构设计原则)
    - [7.2 技术选型建议](#72-技术选型建议)
    - [7.3 实施路线图](#73-实施路线图)
  - [总结](#总结)

---

## 1. 混合架构概述

### 1.1 什么是混合架构

**混合架构** 是指在同一IT系统中，同时使用**虚拟化**和**容器化**技术，根据应用特点和业务需求选择最适合的部署方式。

**核心理念**:

```text
不是非此即彼，而是扬长避短
- 传统应用 → 虚拟机 (成熟稳定)
- 云原生应用 → 容器 (敏捷弹性)
- 数据库/中间件 → 根据场景灵活选择
```

**架构示意**:

```text
┌─────────────────────────────────────────────────────────────┐
│                       统一管理平面                           │
│   (监控、日志、安全、备份、灾备)                              │
└────────────────┬────────────────────────┬───────────────────┘
                 │                        │
      ┌──────────▼──────────┐  ┌─────────▼──────────┐
      │  虚拟化平台          │  │  容器化平台         │
      │  (VMware/KVM)       │  │  (Kubernetes)      │
      ├─────────────────────┤  ├────────────────────┤
      │ - 传统单体应用       │  │ - 微服务应用        │
      │ - Windows应用        │  │ - 云原生应用        │
      │ - 商业软件          │  │ - 开发测试环境      │
      │ - 核心数据库        │  │ - 无状态服务        │
      └─────────────────────┘  └────────────────────┘
                 │                        │
                 └────────────┬───────────┘
                              │
                    ┌─────────▼─────────┐
                    │   物理基础设施     │
                    │  (服务器、网络、存储) │
                    └───────────────────┘
```

---

### 1.2 混合架构的价值

| 价值维度 | 说明 | 效益 |
|---------|------|------|
| **业务连续性** | 无需大规模重构，渐进式演进 | 降低业务风险 |
| **成本优化** | 按需选择技术，提高资源利用率 | 降低TCO 30-50% |
| **技术平滑** | 遗留系统与新技术并存 | 避免推倒重来 |
| **灵活敏捷** | 新业务快速上线容器平台 | 缩短上市时间 50% |
| **风险可控** | 核心系统保持稳定，边缘创新 | 平衡稳定与创新 |

---

### 1.3 混合架构演进路径

**典型演进路径**:

```text
阶段1: 纯虚拟化
  ├─ 所有应用运行在虚拟机
  └─ 稳定但资源利用率低 (30-40%)

阶段2: 混合起步
  ├─ 开发测试环境容器化
  ├─ 新业务尝试Kubernetes
  └─ 核心业务仍在虚拟机

阶段3: 混合深化
  ├─ 50% 应用容器化
  ├─ 微服务架构落地
  └─ 虚拟机与容器互通

阶段4: 容器优先
  ├─ 80% 新应用容器化
  ├─ 仅遗留系统保留虚拟机
  └─ 统一运维管理

阶段5: 云原生
  ├─ 全面容器化
  ├─ Serverless补充
  └─ 虚拟机仅用于特殊场景
```

---

## 2. 经典三层混合架构

### 2.1 架构设计

**适用场景**: 传统企业应用 (OA、ERP、CRM等)

**架构图**:

```text
┌─────────────────────────────────────────────────────────────┐
│                    负载均衡层                                │
│  ┌──────────────────────────────────────────────────────┐  │
│  │  Nginx/HAProxy (容器) + F5 (硬件)                     │  │
│  └──────────────────────────────────────────────────────┘  │
└───────────────────┬─────────────────────────────────────────┘
                    │
      ┌─────────────┴─────────────┐
      │                           │
┌─────▼──────────┐      ┌─────────▼──────────┐
│  展现层 (Web)   │      │  API 网关 (容器)    │
│  ┌───────────┐ │      │  ┌───────────┐     │
│  │  Nginx    │ │      │  │ Kong/APISIX│     │
│  │  (容器)   │ │      │  │  (容器)    │     │
│  └───────────┘ │      │  └───────────┘     │
└────────┬────────┘      └────────┬───────────┘
         │                        │
         └────────────┬───────────┘
                      │
      ┌───────────────┴───────────────┐
      │                               │
┌─────▼──────────┐          ┌─────────▼──────────┐
│  应用层          │          │  微服务层 (容器)    │
│  ┌───────────┐  │          │  ┌───────────┐    │
│  │ Java/.NET │  │          │  │ Spring    │    │
│  │   (VM)    │  │          │  │  Cloud    │    │
│  └───────────┘  │          │  │ (容器)    │    │
└────────┬─────────┘          │  └───────────┘    │
         │                    └────────┬───────────┘
         │                             │
         └─────────────┬───────────────┘
                       │
      ┌────────────────┴────────────────┐
      │                                 │
┌─────▼──────────┐          ┌──────────▼─────────┐
│  数据层          │          │  缓存/消息队列      │
│  ┌───────────┐  │          │  ┌───────────┐    │
│  │ Oracle/   │  │          │  │ Redis/    │    │
│  │ SQL Server│  │          │  │ RabbitMQ  │    │
│  │   (VM)    │  │          │  │  (容器)   │    │
│  └───────────┘  │          │  └───────────┘    │
└─────────────────┘          └────────────────────┘
```

---

### 2.2 技术选型

| 层次 | 虚拟化技术 | 容器化技术 | 选型建议 |
|-----|----------|----------|---------|
| **负载均衡** | F5, A10 | Nginx Ingress, Traefik | 硬件LB处理外部流量，软件LB处理内部流量 |
| **Web层** | IIS (Windows VM) | Nginx (容器) | 静态内容容器化，动态内容根据技术栈选择 |
| **应用层** | Tomcat/WebLogic (VM) | Spring Boot (容器) | 遗留应用VM，新应用容器 |
| **数据层** | Oracle/SQL Server (VM) | MySQL/PostgreSQL (容器/VM) | 核心库VM，开发测试库容器 |
| **缓存** | - | Redis (容器) | 优先容器化 |
| **消息队列** | - | Kafka/RabbitMQ (容器) | 优先容器化 |

---

### 2.3 实施方案

#### 2.3.1 网络架构

```yaml
# 网络规划
管理网络 (10.0.0.0/16):
  - ESXi 管理: 10.0.1.0/24
  - vCenter: 10.0.1.10
  - K8s Master: 10.0.2.0/24

业务网络 (172.16.0.0/16):
  - VM 业务网段: 172.16.0.0/20
  - K8s Pod 网段: 172.16.16.0/20
  - K8s Service 网段: 172.16.32.0/20

存储网络 (192.168.0.0/16):
  - vSAN: 192.168.1.0/24
  - Ceph: 192.168.2.0/24
```

**网络互通方案**:

```yaml
# Calico BGP 配置 (容器与VM互通)
apiVersion: projectcalico.org/v3
kind: BGPConfiguration
metadata:
  name: default
spec:
  asNumber: 64512
  nodeToNodeMeshEnabled: true
  
---
# 暴露VM服务到Kubernetes
apiVersion: v1
kind: Service
metadata:
  name: legacy-app
spec:
  type: ExternalName
  externalName: legacy-app.vm.local  # VM应用DNS
```

---

#### 2.3.2 存储架构

**存储分层**:

```text
高性能层 (NVMe SSD):
  ├─ 数据库VM (VMware vSAN)
  └─ 容器持久化卷 (Rook-Ceph)

标准层 (SATA SSD):
  ├─ 应用VM (VMware vSAN)
  └─ 容器应用 (Longhorn)

归档层 (HDD):
  └─ 备份数据 (NFS/S3)
```

---

### 2.4 典型案例

**案例: 某银行核心系统改造**:

**原架构**:

- 全部虚拟机 (VMware)
- Oracle RAC 数据库
- WebLogic 应用服务器
- 资源利用率 35%

**混合架构**:

```text
核心交易系统 (保留VM):
  ├─ Oracle RAC (VM on vSAN)
  ├─ WebLogic (VM)
  └─ 保持现有架构，确保稳定性

外围系统 (容器化):
  ├─ 手机银行 (Kubernetes + Spring Cloud)
  ├─ 网上银行 (Kubernetes + Vue.js)
  └─ 查询服务 (Kubernetes + MySQL)

中间件 (混合):
  ├─ Redis (Kubernetes)
  ├─ Kafka (Kubernetes)
  └─ ESB (VM)
```

**效果**:

- 资源利用率提升至 65%
- 新功能上线周期从 3 个月缩短至 2 周
- 成本降低 40%

---

## 3. 微服务混合架构

### 3.1 架构设计

**适用场景**: 互联网应用、电商平台、社交媒体

**架构图**:

```text
┌─────────────────────────────────────────────────────────────┐
│                    服务网格 (Istio)                          │
└─────────────────────────────────────────────────────────────┘
                              │
      ┌───────────────────────┴───────────────────────┐
      │                                               │
┌─────▼──────────┐                         ┌─────────▼──────────┐
│  新微服务 (容器) │                         │  遗留服务 (VM)      │
│  ┌───────────┐ │                         │  ┌───────────┐     │
│  │ 用户服务   │ │                         │  │ 支付服务   │     │
│  │ 订单服务   │ │                         │  │ (PHP VM)  │     │
│  │ 商品服务   │ │                         │  └───────────┘     │
│  │ (K8s)     │ │                         │  ┌───────────┐     │
│  └───────────┘ │                         │  │ ERP集成    │     │
└────────┬────────┘                         │  │ (Java VM) │     │
         │                                  │  └───────────┘     │
         │                                  └────────┬───────────┘
         │                                           │
         └─────────────┬─────────────────────────────┘
                       │
      ┌────────────────┴────────────────┐
      │                                 │
┌─────▼──────────┐          ┌──────────▼─────────┐
│  数据层 (混合)   │          │  事件总线 (容器)    │
│  ┌───────────┐  │          │  ┌───────────┐    │
│  │ MySQL     │  │          │  │ Kafka     │    │
│  │ (VM)      │  │          │  │ (K8s)     │    │
│  │ PostgreSQL│  │          │  └───────────┘    │
│  │ (容器)    │  │          │                    │
│  └───────────┘  │          └────────────────────┘
└─────────────────┘
```

---

### 3.2 服务拆分策略

**拆分原则**:

```text
1. 业务边界清晰 → 独立微服务 (容器)
2. 变更频率高 → 容器化 (快速迭代)
3. 技术栈统一 → 容器化 (标准化)
4. 遗留系统复杂 → 暂时保留VM (降低风险)
5. 商业软件 → VM (许可证限制)
```

**拆分步骤**:

```text
阶段1: 边缘服务容器化
  ├─ Web前端 (Kubernetes)
  ├─ API网关 (Kubernetes)
  └─ 查询服务 (Kubernetes)

阶段2: 核心服务拆分
  ├─ 用户服务 (Kubernetes)
  ├─ 订单服务 (Kubernetes)
  └─ 支付服务 (VM → 容器，逐步改造)

阶段3: 数据层优化
  ├─ 读写分离 (主库VM + 只读副本容器)
  ├─ 缓存层容器化 (Redis Kubernetes)
  └─ 消息队列容器化 (Kafka Kubernetes)

阶段4: 遗留系统集成
  ├─ API适配层 (Kubernetes)
  ├─ 数据同步 (CDC工具)
  └─ 遗留服务纳入服务网格
```

---

### 3.3 服务网格集成

**Istio 混合环境配置**:

```yaml
# 将VM服务注册到Istio
apiVersion: networking.istio.io/v1beta1
kind: WorkloadEntry
metadata:
  name: legacy-payment-vm
  namespace: default
spec:
  address: 172.16.1.100  # VM IP
  labels:
    app: payment
    version: v1
  serviceAccount: legacy-sa
---
# Service 定义 (同时包含容器和VM)
apiVersion: v1
kind: Service
metadata:
  name: payment
spec:
  ports:
  - port: 8080
  selector:
    app: payment
---
# VirtualService (统一流量管理)
apiVersion: networking.istio.io/v1beta1
kind: VirtualService
metadata:
  name: payment
spec:
  hosts:
  - payment
  http:
  - match:
    - headers:
        version:
          exact: "v2"
    route:
    - destination:
        host: payment
        subset: v2-container  # 新版本容器
  - route:
    - destination:
        host: payment
        subset: v1-vm  # 旧版本VM
      weight: 90
    - destination:
        host: payment
        subset: v2-container
      weight: 10  # 金丝雀发布
```

---

### 3.4 典型案例

**案例: 某电商平台微服务改造**:

**原架构**:

- PHP单体应用 (VM)
- MySQL主从 (VM)
- Redis (VM)

**目标架构**:

```text
前端层:
  ├─ Vue.js SPA (Kubernetes + Nginx)
  └─ CDN加速

API层:
  ├─ API Gateway (Kong on Kubernetes)
  └─ BFF (Backend for Frontend, Go on Kubernetes)

微服务层 (Kubernetes):
  ├─ 用户服务 (Go)
  ├─ 商品服务 (Java Spring Boot)
  ├─ 订单服务 (Java Spring Boot)
  ├─ 库存服务 (Go)
  └─ 推荐服务 (Python)

遗留服务 (VM):
  ├─ 支付服务 (PHP, 暂时保留)
  └─ ERP集成 (Java, 商业软件)

数据层:
  ├─ MySQL主库 (VM, 保证稳定性)
  ├─ MySQL只读副本 (Kubernetes)
  ├─ Redis集群 (Kubernetes)
  ├─ Elasticsearch (Kubernetes)
  └─ Kafka (Kubernetes)
```

**迁移策略**:

```text
Week 1-2: 搭建Kubernetes集群，部署基础设施
Week 3-4: API网关+BFF上线，作为新老系统适配层
Week 5-6: 商品服务容器化，灰度10%流量
Week 7-8: 用户服务容器化，灰度20%流量
Week 9-10: 订单服务容器化，逐步切换全量流量
Week 11-12: 遗留服务通过ServiceEntry集成到Istio
```

---

## 4. Serverless 混合架构

### 4.1 架构设计

**适用场景**: 事件驱动应用、突发流量处理、轻量API

**架构图**:

```text
┌─────────────────────────────────────────────────────────────┐
│                    API 网关 / Ingress                       │
└────────────────┬────────────────────────────────────────────┘
                 │
      ┌──────────┴──────────┬──────────────┬──────────────┐
      │                     │              │              │
┌─────▼──────────┐  ┌───────▼────────┐  ┌─▼─────────┐  ┌▼──────────┐
│  常驻服务 (容器) │  │ 函数计算 (FaaS)│  │ 定时任务   │  │ 遗留服务   │
│  ┌───────────┐ │  │  ┌───────────┐ │  │ (Knative) │  │   (VM)    │
│  │ 核心API   │ │  │  │ 图片处理  │ │  │           │  │           │
│  │ (K8s)     │ │  │  │ 数据清洗  │ │  └───────────┘  └───────────┘
│  └───────────┘ │  │  │ (Knative)│ │
└────────┬────────┘  │  └───────────┘ │
         │           └───────┬─────────┘
         │                   │
         └─────────┬─────────┘
                   │
      ┌────────────▼────────────┐
      │  事件总线 (Kafka)        │
      └─────────────────────────┘
                   │
      ┌────────────▼────────────┐
      │  对象存储 (MinIO/S3)     │
      └─────────────────────────┘
```

---

### 4.2 函数计算集成

**Knative 部署**:

```yaml
# 安装 Knative Serving
kubectl apply -f https://github.com/knative/serving/releases/download/knative-v1.12.0/serving-crds.yaml
kubectl apply -f https://github.com/knative/serving/releases/download/knative-v1.12.0/serving-core.yaml

# 配置网络层 (Istio)
kubectl apply -f https://github.com/knative/net-istio/releases/download/knative-v1.12.0/net-istio.yaml
```

**Serverless 函数示例**:

```yaml
# 图片处理函数
apiVersion: serving.knative.dev/v1
kind: Service
metadata:
  name: image-resizer
spec:
  template:
    spec:
      containers:
      - image: myregistry/image-resizer:v1
        env:
        - name: TARGET_SIZE
          value: "800x600"
        resources:
          requests:
            memory: "128Mi"
            cpu: "100m"
          limits:
            memory: "512Mi"
            cpu: "1000m"
      # Knative 自动扩缩容配置
      autoscaling.knative.dev/minScale: "0"  # 缩容到0
      autoscaling.knative.dev/maxScale: "10"
      autoscaling.knative.dev/target: "100"  # 每实例并发数
```

---

### 4.3 事件驱动架构

**事件流**:

```text
1. 用户上传图片 → API Gateway
        ↓
2. 触发 Kafka 事件
        ↓
3. Knative EventSource 监听事件
        ↓
4. 自动启动图片处理函数 (从0扩容)
        ↓
5. 函数处理完成，存储到MinIO
        ↓
6. 发送完成事件到Kafka
        ↓
7. 函数空闲5分钟后缩容到0
```

**配置示例**:

```yaml
# Kafka EventSource
apiVersion: sources.knative.dev/v1beta1
kind: KafkaSource
metadata:
  name: kafka-source
spec:
  consumerGroup: image-processor
  bootstrapServers:
  - kafka-broker.kafka:9092
  topics:
  - image-upload
  sink:
    ref:
      apiVersion: serving.knative.dev/v1
      kind: Service
      name: image-resizer
```

---

### 4.4 典型案例

**案例: 某视频平台混合架构**:

**架构设计**:

```text
实时服务 (Kubernetes常驻):
  ├─ 播放服务 (Go)
  ├─ 弹幕服务 (Go)
  └─ 用户服务 (Java)

Serverless 函数 (Knative):
  ├─ 视频转码 (Python, GPU)
  ├─ 缩略图生成 (Go)
  ├─ AI内容审核 (Python)
  └─ 数据分析 (Python, Spark)

遗留服务 (VM):
  ├─ 版权管理系统 (商业软件)
  └─ 财务系统 (Oracle + Java)

存储:
  ├─ 视频文件 (MinIO集群)
  ├─ 元数据 (MySQL on VM)
  └─ 缓存 (Redis on Kubernetes)
```

**成本优化**:

- 视频转码按需启动，节省 70% 闲置资源
- 缩略图生成缩容到0，节省 90% 成本
- 实时服务保持常驻，保证用户体验

---

## 5. 边缘计算混合架构

### 5.1 架构设计

**适用场景**: IoT、CDN、智能制造、自动驾驶

**架构图**:

```text
┌─────────────────────────────────────────────────────────────┐
│                      云端 (公有云/私有云)                     │
│  ┌────────────┐  ┌────────────┐  ┌────────────┐             │
│  │ 数据中台    │  │ AI训练平台 │  │ 管理控制台  │              │
│  │ (VM)       │  │ (K8s)      │  │ (K8s)      │              │
│  └────────────┘  └────────────┘  └────────────┘              │
└────────────────────────┬─────────────────────────────────────┘
                         │ (Internet/专线)
      ┌──────────────────┴──────────────────┐
      │                                     │
┌─────▼──────────┐              ┌──────────▼─────────┐
│  边缘区域1      │              │  边缘区域2          │
│  ┌───────────┐ │              │  ┌───────────┐     │
│  │ K3s集群   │ │              │  │ K3s集群   │     │
│  │ - AI推理  │ │              │  │ - AI推理  │     │
│  │ - 数据预处理│ │             │  │ - 数据预处理│     │
│  │ - 本地缓存 │ │              │  │ - 本地缓存 │     │
│  └───────────┘ │              │  └───────────┘     │
└────────┬────────┘              └────────┬───────────┘
         │                                │
    ┌────┴────┐                      ┌────┴────┐
    │         │                      │         │
┌───▼───┐ ┌──▼───┐              ┌───▼───┐ ┌──▼───┐
│ 设备1 │ │ 设备2 │              │ 设备3 │ │ 设备4 │
│(摄像头)│ │(传感器)│            │(机械臂)│ │(AGV) │
└───────┘ └──────┘              └───────┘ └──────┘
```

---

### 5.2 边缘节点部署

**K3s 轻量级 Kubernetes**:

```bash
# 云端 K3s Server
curl -sfL https://get.k3s.io | sh -s - server \
  --disable traefik \
  --disable servicelb \
  --write-kubeconfig-mode 644

# 边缘节点 K3s Agent
curl -sfL https://get.k3s.io | K3S_URL=https://cloud-server:6443 \
  K3S_TOKEN=xxxxx sh -s - agent
```

**边缘应用部署**:

```yaml
# 边缘AI推理服务
apiVersion: apps/v1
kind: Deployment
metadata:
  name: edge-inference
  labels:
    app: edge-inference
spec:
  replicas: 1
  selector:
    matchLabels:
      app: edge-inference
  template:
    metadata:
      labels:
        app: edge-inference
    spec:
      nodeSelector:
        node.kubernetes.io/edge: "true"  # 部署到边缘节点
      containers:
      - name: inference
        image: myregistry/yolov5:latest
        resources:
          requests:
            memory: "2Gi"
            cpu: "2"
          limits:
            nvidia.com/gpu: 1  # GPU加速
        volumeMounts:
        - name: model
          mountPath: /models
      volumes:
      - name: model
        hostPath:
          path: /opt/models
```

---

### 5.3 云边协同

**KubeEdge 架构**:

```yaml
# 云端 CloudCore
apiVersion: apps/v1
kind: Deployment
metadata:
  name: cloudcore
  namespace: kubeedge
spec:
  replicas: 1
  selector:
    matchLabels:
      app: cloudcore
  template:
    spec:
      containers:
      - name: cloudcore
        image: kubeedge/cloudcore:v1.15.0
        ports:
        - containerPort: 10000  # WebSocket
        - containerPort: 10002  # HTTPS
---
# 边缘节点 EdgeCore
# 通过 keadm 安装
keadm join --cloudcore-ipport=<cloud-ip>:10000 \
  --token=<token>
```

**云边消息同步**:

```yaml
# 边缘节点设备管理
apiVersion: devices.kubeedge.io/v1alpha2
kind: Device
metadata:
  name: camera-01
  namespace: default
spec:
  deviceModelRef:
    name: camera-model
  nodeName: edge-node-1
  data:
    properties:
    - name: resolution
      desired:
        value: "1920x1080"
    - name: fps
      desired:
        value: "30"
```

---

### 5.4 典型案例

**案例: 某智能工厂边缘计算**:

**架构设计**:

```text
云端 (AWS/阿里云):
  ├─ 数据中台 (大数据平台, VM)
  ├─ AI训练平台 (Kubernetes + GPU)
  ├─ MES系统 (VM)
  └─ 工业互联网平台 (Kubernetes)

边缘数据中心 (工厂机房):
  ├─ 边缘K8s集群 (生产调度)
  ├─ 数据预处理 (Spark on K8s)
  └─ 本地数据库 (PostgreSQL on VM)

边缘节点 (产线):
  ├─ K3s轻量集群
  ├─ AI质检推理 (TensorFlow Lite)
  ├─ 实时监控 (Prometheus)
  └─ 本地缓存 (Redis)

终端设备:
  ├─ 视觉检测摄像头 (200+)
  ├─ 工业机器人 (50+)
  ├─ PLC控制器 (100+)
  └─ AGV小车 (20+)
```

**数据流**:

```text
1. 设备数据 → 边缘节点 (实时处理)
2. 异常数据 → 边缘数据中心 (分析)
3. 汇总数据 → 云端 (长期存储 + AI训练)
4. AI模型 → 边缘节点 (模型下发)
```

**效益**:

- 实时响应: <100ms (云端>500ms)
- 带宽节省: 90% (边缘过滤)
- 成本降低: 60% (边缘计算 vs 全云端)

---

## 6. 混合架构对比

### 6.1 架构对比矩阵

| 架构模式 | 复杂度 | 成本 | 性能 | 灵活性 | 适用规模 |
|---------|-------|------|------|--------|---------|
| **经典三层混合** | ⭐⭐ | ⭐⭐⭐ | ⭐⭐⭐ | ⭐⭐ | 中小型企业 |
| **微服务混合** | ⭐⭐⭐⭐ | ⭐⭐⭐⭐ | ⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ | 互联网公司 |
| **Serverless混合** | ⭐⭐⭐ | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ | 事件驱动应用 |
| **边缘计算混合** | ⭐⭐⭐⭐⭐ | ⭐⭐⭐ | ⭐⭐⭐⭐⭐ | ⭐⭐⭐ | IoT、工业互联网 |

---

### 6.2 适用场景

| 场景 | 推荐架构 | 理由 |
|-----|---------|------|
| **传统企业应用** | 经典三层混合 | 稳定性优先，渐进式演进 |
| **互联网电商** | 微服务混合 | 高并发、快速迭代 |
| **视频图片处理** | Serverless混合 | 成本优化、按需扩展 |
| **智能制造** | 边缘计算混合 | 实时性、数据安全 |
| **金融核心系统** | 经典三层混合 | 合规、稳定性 |

---

### 6.3 选型建议

**决策树**:

```text
是否需要实时处理 (<100ms)?
├─ 是 → 边缘计算混合
└─ 否
    ├─ 是否事件驱动 (突发流量)?
    │   ├─ 是 → Serverless混合
    │   └─ 否
    │       ├─ 是否微服务架构?
    │       │   ├─ 是 → 微服务混合
    │       │   └─ 否 → 经典三层混合
```

---

## 7. 最佳实践

### 7.1 架构设计原则

**1. 分层解耦**:

```text
展现层 ←→ API层 ←→ 业务层 ←→ 数据层
  │         │         │         │
容器化    容器化   VM/容器混合   VM为主
```

**2. 渐进演进**:

```text
Week 1-4:  基础设施搭建
Week 5-8:  边缘服务容器化
Week 9-12: 核心服务拆分
Week 13+:  持续优化
```

**3. 风险可控**:

```text
- 核心系统保持稳定 (VM)
- 新业务创新试错 (容器)
- 灰度发布验证 (流量分割)
- 快速回滚 (蓝绿部署)
```

---

### 7.2 技术选型建议

| 技术类别 | 虚拟化选型 | 容器化选型 | 混合建议 |
|---------|----------|----------|---------|
| **计算** | VMware vSphere, KVM | Kubernetes, K3s | 根据负载特性选择 |
| **网络** | NSX, Calico | Calico, Cilium | 统一CNI (Calico) |
| **存储** | vSAN, Ceph | Rook-Ceph, Longhorn | 分层存储 (高性能VM, 标准容器) |
| **监控** | vROps, Zabbix | Prometheus, Grafana | 统一监控平台 |
| **日志** | Splunk | ELK, Loki | 统一日志中心 |
| **服务网格** | - | Istio, Linkerd | 纳入VM服务 |

---

### 7.3 实施路线图

**第一阶段: 基础设施 (1-2个月)**:

```text
- [ ] 虚拟化平台部署 (VMware/KVM)
- [ ] Kubernetes集群部署
- [ ] 网络互通配置 (BGP/VXLAN)
- [ ] 统一存储规划 (vSAN + Ceph)
- [ ] 监控告警搭建 (Prometheus + vROps)
```

**第二阶段: 试点应用 (2-3个月)**:

```text
- [ ] 选择1-2个非核心应用容器化
- [ ] 开发测试环境全面容器化
- [ ] 灰度发布流程验证
- [ ] 监控数据收集分析
```

**第三阶段: 规模推广 (3-6个月)**:

```text
- [ ] 核心应用逐步拆分
- [ ] 微服务架构落地
- [ ] 服务网格集成 (VM + 容器)
- [ ] 数据层优化 (读写分离)
```

**第四阶段: 持续优化 (持续)**:

```text
- [ ] 成本优化 (资源利用率提升)
- [ ] 性能优化 (响应时间优化)
- [ ] 自动化运维 (CI/CD完善)
- [ ] 故障演练 (混沌工程)
```

---

## 总结

**混合架构核心价值**:

- ✅ **降低风险**: 渐进式演进，避免激进变革
- ✅ **优化成本**: 按需选择技术，提高资源利用率
- ✅ **灵活敏捷**: 容器化新业务，保留稳定遗留系统
- ✅ **平滑过渡**: 技术债务逐步偿还

**架构选择建议**:

- **经典三层混合**: 传统企业、稳定性优先
- **微服务混合**: 互联网公司、高并发场景
- **Serverless混合**: 事件驱动、成本敏感
- **边缘计算混合**: IoT、实时性要求高

**关键成功因素**:

1. 高层支持与战略规划
2. 分阶段实施，快速验证
3. 统一运维管理平台
4. 持续学习与优化

---

**相关文档**:

- [架构选型决策](02_架构选型决策.md)
- [容量规划与成本](03_容量规划与成本.md)
- [高可用架构设计](04_高可用架构设计.md)

---

**更新时间**: 2025-10-19  
**文档版本**: v1.0  
**状态**: ✅ 完成
