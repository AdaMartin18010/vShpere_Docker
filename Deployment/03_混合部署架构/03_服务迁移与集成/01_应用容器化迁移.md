# 应用容器化迁移

> **返回**: [服务迁移与集成首页](README.md) | [混合部署架构首页](../README.md) | [部署指南首页](../../00_索引导航/README.md)

---

## 📋 目录

- [应用容器化迁移](#应用容器化迁移)
  - [📋 目录](#-目录)
  - [1. 迁移评估](#1-迁移评估)
  - [2. 改造策略](#2-改造策略)
  - [3. 分步迁移](#3-分步迁移)
  - [4. 回滚方案](#4-回滚方案)

---

## 1. 迁移评估

**12因子应用评估**:

| 因子 | 要求 | VM应用现状 | 改造建议 |
|-----|------|----------|---------|
| **代码库** | 单一代码库 | ✅ 已满足 | 无需改造 |
| **依赖** | 显式声明依赖 | ⚠️ 系统依赖 | Dockerfile声明 |
| **配置** | 环境变量存储 | ❌ 配置文件 | ConfigMap/Secret |
| **后端服务** | 资源附加 | ⚠️ 硬编码IP | 服务发现 |
| **构建发布运行** | 严格分离 | ❌ 手动部署 | CI/CD流水线 |
| **进程** | 无状态进程 | ❌ 本地会话 | Redis存储会话 |
| **端口绑定** | 导出服务 | ✅ 已满足 | 无需改造 |
| **并发** | 水平扩展 | ❌ 垂直扩展 | Kubernetes HPA |
| **易处理** | 快速启动关闭 | ⚠️ 启动慢 | 优化启动时间 |
| **环境一致** | 开发生产一致 | ❌ 环境差异 | 容器化统一 |
| **日志** | 事件流 | ⚠️ 文件日志 | stdout/stderr |
| **管理进程** | 一次性任务 | ⚠️ cron任务 | Kubernetes Job |

**迁移难度评估**:

```text
低难度 (1-2周):
  - 无状态应用
  - 标准技术栈 (Java/Python/Node.js)
  - 配置简单

中等难度 (3-4周):
  - 有状态应用 (需要存储方案)
  - 复杂配置
  - 多服务依赖

高难度 (2-3个月):
  - 单体应用 (需要拆分)
  - 商业软件 (许可证限制)
  - 紧耦合架构
```

---

## 2. 改造策略

**策略1: Lift and Shift (直接迁移)**:

```dockerfile
# 最小改造
FROM ubuntu:20.04
COPY legacy-app /opt/app
COPY config /etc/app
CMD ["/opt/app/start.sh"]
```

**优点**: 快速迁移  
**缺点**: 未充分利用容器优势

**策略2: Replatform (轻度改造)**:

```dockerfile
# 基于官方镜像
FROM openjdk:11-jre
COPY app.jar /app/
EXPOSE 8080
ENTRYPOINT ["java", "-jar", "/app/app.jar"]
---
# ConfigMap外部化配置
apiVersion: v1
kind: ConfigMap
metadata:
  name: app-config
data:
  application.properties: |
    server.port=8080
    db.url=jdbc:mysql://db:3306/app
```

**优点**: 平衡速度与优化  
**缺点**: 部分旧架构遗留

**策略3: Refactor (重构)**:

```text
单体应用 → 微服务
  ├─ API网关
  ├─ 用户服务
  ├─ 订单服务
  └─ 支付服务

配置重构:
  ├─ Spring Cloud Config
  ├─ Consul
  └─ etcd
```

**优点**: 充分云原生  
**缺点**: 周期长、成本高

---

## 3. 分步迁移

**Phase 1: 容器化打包**:

```bash
# 1. 编写Dockerfile
cat > Dockerfile << 'EOF'
FROM python:3.9-slim
WORKDIR /app
COPY requirements.txt .
RUN pip install -r requirements.txt
COPY . .
CMD ["python", "app.py"]
EOF

# 2. 构建镜像
docker build -t myapp:v1 .

# 3. 本地测试
docker run -p 8080:8080 myapp:v1
```

**Phase 2: Kubernetes部署**:

```yaml
# Deployment
apiVersion: apps/v1
kind: Deployment
metadata:
  name: myapp
spec:
  replicas: 1  # 初始单副本
  selector:
    matchLabels:
      app: myapp
  template:
    metadata:
      labels:
        app: myapp
    spec:
      containers:
      - name: myapp
        image: myapp:v1
        ports:
        - containerPort: 8080
        env:
        - name: DB_HOST
          value: "legacy-db.vm.local"  # 先连接VM数据库
---
# Service
apiVersion: v1
kind: Service
metadata:
  name: myapp
spec:
  selector:
    app: myapp
  ports:
  - port: 80
    targetPort: 8080
```

**Phase 3: 灰度验证**:

```yaml
# Istio VirtualService
apiVersion: networking.istio.io/v1beta1
kind: VirtualService
metadata:
  name: myapp
spec:
  hosts:
  - myapp.example.com
  http:
  - match:
    - headers:
        x-canary:
          exact: "true"  # 内部测试
    route:
    - destination:
        host: myapp
        subset: v2-k8s
  - route:
    - destination:
        host: myapp-vm
        subset: v1-vm
      weight: 90
    - destination:
        host: myapp
        subset: v2-k8s
      weight: 10  # 10%流量
```

**Phase 4: 全量切换**:

```yaml
# 逐步增加权重
weight: 10 → 30 → 50 → 80 → 100
```

---

## 4. 回滚方案

**快速回滚 (DNS)**:

```bash
# 回滚到VM
kubectl patch svc myapp -p '{"spec":{"type":"ExternalName","externalName":"myapp-vm.legacy.local"}}'
```

**Kubernetes回滚**:

```bash
# 回滚到上一版本
kubectl rollout undo deployment/myapp

# 回滚到指定版本
kubectl rollout undo deployment/myapp --to-revision=2

# 查看回滚历史
kubectl rollout history deployment/myapp
```

**数据回滚**:

```bash
# 恢复数据库快照
mysql -h db.legacy.local < backup-2024-01-01.sql

# 恢复PV数据
velero restore create --from-backup backup-2024-01-01
```

---

**更新时间**: 2025-10-19  
**文档版本**: v1.0  
**状态**: ✅ 完成
