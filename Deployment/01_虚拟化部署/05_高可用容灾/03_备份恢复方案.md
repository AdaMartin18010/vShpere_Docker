# 备份恢复方案

> **返回**: [高可用容灾目录](README.md) | [虚拟化部署首页](../README.md) | [部署指南首页](../../00_索引导航/README.md)

---

## 📋 目录

- [备份恢复方案](#备份恢复方案)
  - [📋 目录](#-目录)
  - [1. 备份策略概述](#1-备份策略概述)
  - [2. 虚拟化环境备份](#2-虚拟化环境备份)
    - [2.1 VMware备份脚本](#21-vmware备份脚本)
    - [2.2 KVM备份脚本](#22-kvm备份脚本)
  - [3. Kubernetes备份](#3-kubernetes备份)
    - [3.1 Velero部署与配置](#31-velero部署与配置)
    - [3.2 etcd备份脚本](#32-etcd备份脚本)
    - [3.3 Kubernetes资源导出脚本](#33-kubernetes资源导出脚本)
  - [4. 数据库备份](#4-数据库备份)
    - [4.1 MySQL备份脚本](#41-mysql备份脚本)
    - [4.2 PostgreSQL备份脚本](#42-postgresql备份脚本)
    - [4.3 MongoDB备份脚本](#43-mongodb备份脚本)
  - [5. 应用数据备份](#5-应用数据备份)
    - [5.1 应用数据备份脚本](#51-应用数据备份脚本)
  - [6. 备份存储与管理](#6-备份存储与管理)
  - [7. 恢复流程](#7-恢复流程)
    - [7.1 恢复脚本示例](#71-恢复脚本示例)
  - [8. 备份监控与验证](#8-备份监控与验证)
    - [8.1 备份监控脚本](#81-备份监控脚本)
  - [9. 最佳实践](#9-最佳实践)
  - [相关文档](#相关文档)

---

## 1. 备份策略概述

```yaml
Backup_Strategy_Overview:
  备份原则:
    3-2-1规则:
      - 3份数据副本: 1份生产数据 + 2份备份
      - 2种不同介质: 磁盘、磁带、云存储
      - 1份异地备份: 不同地理位置
    
    附加原则:
      - 3-2-1-1-0:
        - 3份副本
        - 2种介质
        - 1份异地
        - 1份离线 (Air-gapped)
        - 0错误 (定期验证)

  备份类型:
    全量备份 (Full Backup):
      定义: 备份所有数据
      优点:
        - 恢复速度快
        - 恢复简单
        - 独立性强
      缺点:
        - 耗时长
        - 存储空间大
        - 网络开销大
      频率: 每周/每月
      适用: 关键系统、定期归档
    
    增量备份 (Incremental Backup):
      定义: 只备份自上次备份后变化的数据
      优点:
        - 备份速度快
        - 存储空间小
        - 网络开销小
      缺点:
        - 恢复复杂
        - 依赖完整备份链
        - 恢复时间长
      频率: 每天
      适用: 日常备份
    
    差异备份 (Differential Backup):
      定义: 备份自上次全量备份后所有变化
      优点:
        - 恢复比增量快
        - 只需全备 + 最后一次差异备份
        - 备份链简单
      缺点:
        - 备份量逐渐增大
        - 比增量备份慢
      频率: 每周2-3次
      适用: 中等规模环境
    
    合成全备 (Synthetic Full):
      定义: 从全备和增量合成新的全备
      优点:
        - 减少生产环境影响
        - 加快全备频率
        - 优化存储
      缺点:
        - 需要额外计算
        - 依赖备份软件支持
      频率: 每周
      适用: 大型环境

  备份窗口:
    业务时间分析:
      高峰期: 09:00-18:00 (工作日)
        - 避免备份
        - 最小化影响
      
      低峰期: 18:00-次日09:00
        - 增量备份
        - 差异备份
      
      维护窗口: 周末/凌晨
        - 全量备份
        - 系统维护
        - 备份验证

  RPO与RTO:
    RPO (Recovery Point Objective):
      定义: 可接受的数据丢失时间
      级别:
        关键业务: 15分钟-1小时
        重要业务: 4-8小时
        普通业务: 24小时
      
      实现方式:
        - 实时复制: RPO接近0
        - 频繁快照: RPO 15分钟-1小时
        - 定时备份: RPO 4-24小时
    
    RTO (Recovery Time Objective):
      定义: 可接受的恢复时间
      级别:
        关键业务: 1-4小时
        重要业务: 4-8小时
        普通业务: 24-48小时
      
      影响因素:
        - 备份类型
        - 数据量
        - 网络带宽
        - 恢复复杂度

  备份级别:
    L0_系统级备份:
      - 虚拟机/容器镜像
      - 操作系统
      - 配置文件
      - 系统状态
    
    L1_应用级备份:
      - 应用程序
      - 中间件
      - 配置文件
      - 日志文件
    
    L2_数据级备份:
      - 数据库
      - 文件系统
      - 对象存储
      - 持久化卷
    
    L3_配置级备份:
      - K8s资源定义
      - 网络配置
      - 安全策略
      - 密钥证书
```

---

## 2. 虚拟化环境备份

```yaml
VMware_Backup:
  备份方法:
    方法1_vSphere_Replication:
      特点:
        - VMware原生复制
        - 接近CDP
        - RPO: 5分钟-24小时
      
      配置:
        - 安装vSphere Replication Appliance
        - 配置复制关系
        - 设置RPO目标
        - 启用加密传输
      
      适用场景:
        - 灾难恢复
        - 站点间复制
        - 关键VM保护
    
    方法2_Veeam_Backup:
      特点:
        - 企业级备份软件
        - 支持增量/差异备份
        - 快速恢复
      
      功能:
        - Changed Block Tracking (CBT)
        - 即时恢复 (Instant VM Recovery)
        - 应用感知备份
        - 重复数据删除
        - 压缩加密
      
      备份作业:
        - 全量备份: 每周六
        - 增量备份: 每天
        - 保留: 30天
    
    方法3_手动导出:
      OVF导出:
        - 适合少量VM
        - 完整VM导出
        - 可跨平台
      
      命令:
        ovftool vi://vcenter/datacenter/vm/vmname /backup/vmname.ovf
      
      限制:
        - 需要关机或快照
        - 耗时较长
        - 不适合自动化
    
    方法4_快照:
      用途:
        - 临时保护点
        - 升级前备份
        - 测试回滚
      
      注意事项:
        - 不是真正备份
        - 影响性能
        - 及时删除
        - 最多保留72小时

  备份脚本:
    PowerCLI_自动备份:
      功能:
        - 自动化VM导出
        - 多VM并行
        - 邮件通知
        - 日志记录

KVM_Backup:
  备份方法:
    方法1_virsh_dump:
      特点:
        - KVM原生命令
        - 支持在线备份
        - XML定义导出
      
      命令:
        # 备份VM定义
        virsh dumpxml vm-name > /backup/vm-name.xml
        
        # 备份磁盘
        virsh domblklist vm-name
        cp /var/lib/libvirt/images/vm-name.qcow2 /backup/
      
      恢复:
        virsh define /backup/vm-name.xml
        cp /backup/vm-name.qcow2 /var/lib/libvirt/images/
        virsh start vm-name
    
    方法2_快照备份:
      外部快照:
        - 不修改原磁盘
        - 快照链管理
        - 适合频繁备份
      
      命令:
        # 创建快照
        virsh snapshot-create-as vm-name \
            snapshot1 "Backup before upgrade" \
            --disk-only --atomic
        
        # 列出快照
        virsh snapshot-list vm-name
        
        # 恢复快照
        virsh snapshot-revert vm-name snapshot1
    
    方法3_qcow2工具:
      特点:
        - 增量备份
        - 压缩备份
        - 快速恢复
      
      命令:
        # 创建增量备份
        qemu-img create -f qcow2 \
            -b /var/lib/libvirt/images/vm-base.qcow2 \
            /backup/vm-incremental.qcow2
        
        # 转换格式
        qemu-img convert -f qcow2 -O raw \
            vm.qcow2 vm.raw

Hyper-V_Backup:
  备份方法:
    方法1_Windows_Server_Backup:
      特点:
        - Windows原生工具
        - VSS感知备份
        - 免费
      
      配置:
        # PowerShell安装
        Install-WindowsFeature Windows-Server-Backup
        
        # 创建备份策略
        $Policy = New-WBPolicy
        $BackupLocation = New-WBBackupTarget -VolumePath "E:"
        Add-WBBackupTarget -Policy $Policy -Target $BackupLocation
        Add-WBVirtualMachine -Policy $Policy -VirtualMachine (Get-VM)
        Set-WBSchedule -Policy $Policy -Schedule 02:00
        Set-WBPolicy -Policy $Policy
    
    方法2_Hyper-V_Replica:
      特点:
        - 原生复制功能
        - 异步复制
        - RPO: 30秒-15分钟
      
      配置步骤:
        1. 启用Hyper-V Replica
        2. 配置复制服务器
        3. 为VM启用复制
        4. 选择复制频率
        5. 配置恢复点数量
    
    方法3_Export导出:
      命令:
        # 导出VM
        Export-VM -Name "VM01" -Path "E:\Backup"
        
        # 批量导出
        Get-VM | Export-VM -Path "E:\Backup"
        
        # 导入VM
        Import-VM -Path "E:\Backup\VM01\Virtual Machines\*.vmcx"
```

### 2.1 VMware备份脚本

```powershell
#!/usr/bin/env pwsh
# ========================================
# VMware自动化备份脚本
# ========================================

# 配置参数
$vCenterServer = "vcenter.example.com"
$Username = "administrator@vsphere.local"
$Password = "P@ssw0rd"
$BackupPath = "\\nas.example.com\backup\vmware"
$LogPath = "C:\Scripts\Logs"
$EmailTo = "admin@example.com"
$EmailFrom = "backup@example.com"
$SMTPServer = "smtp.example.com"

# 创建日志目录
New-Item -ItemType Directory -Force -Path $LogPath | Out-Null
$LogFile = Join-Path $LogPath "VMBackup-$(Get-Date -Format 'yyyyMMdd-HHmmss').log"

function Write-Log {
    param([string]$Message)
    $Timestamp = Get-Date -Format "yyyy-MM-dd HH:mm:ss"
    $LogMessage = "[$Timestamp] $Message"
    Write-Host $LogMessage
    Add-Content -Path $LogFile -Value $LogMessage
}

try {
    Write-Log "===== VMware备份任务开始 ====="
    
    # 连接vCenter
    Write-Log "连接vCenter: $vCenterServer"
    $SecurePassword = ConvertTo-SecureString $Password -AsPlainText -Force
    $Credential = New-Object System.Management.Automation.PSCredential($Username, $SecurePassword)
    Connect-VIServer -Server $vCenterServer -Credential $Credential -ErrorAction Stop
    
    # 获取需要备份的VM (标签为"Backup")
    Write-Log "获取需要备份的虚拟机列表"
    $VMsToBackup = Get-VM -Tag "Backup" | Where-Object {$_.PowerState -eq "PoweredOn"}
    Write-Log "找到 $($VMsToBackup.Count) 台虚拟机需要备份"
    
    $SuccessCount = 0
    $FailCount = 0
    $FailedVMs = @()
    
    foreach ($VM in $VMsToBackup) {
        try {
            Write-Log "开始备份虚拟机: $($VM.Name)"
            
            # 创建快照
            Write-Log "  创建快照: $($VM.Name)"
            $Snapshot = New-Snapshot -VM $VM -Name "Backup-$(Get-Date -Format 'yyyyMMdd-HHmmss')" `
                -Description "Automated backup snapshot" -Memory:$false -Quiesce:$true
            
            # 导出VM配置
            $VMBackupPath = Join-Path $BackupPath $VM.Name
            New-Item -ItemType Directory -Force -Path $VMBackupPath | Out-Null
            
            Write-Log "  导出VM定义: $($VM.Name)"
            $VM | Export-VApp -Destination $VMBackupPath -Force
            
            # 备份VM配置信息
            $VMInfo = @{
                Name = $VM.Name
                CPUs = $VM.NumCpu
                Memory = $VM.MemoryGB
                Disks = $VM.HardDisks | Select-Object Name, CapacityGB, StorageFormat
                Networks = $VM.NetworkAdapters | Select-Object Name, NetworkName, Type
                BackupDate = Get-Date -Format "yyyy-MM-dd HH:mm:ss"
            }
            $VMInfo | ConvertTo-Json | Out-File (Join-Path $VMBackupPath "vm-info.json")
            
            # 删除快照
            Write-Log "  删除快照: $($VM.Name)"
            Remove-Snapshot -Snapshot $Snapshot -Confirm:$false
            
            Write-Log "✅ 虚拟机备份成功: $($VM.Name)"
            $SuccessCount++
            
        } catch {
            Write-Log "❌ 虚拟机备份失败: $($VM.Name) - $($_.Exception.Message)"
            $FailCount++
            $FailedVMs += $VM.Name
            
            # 清理失败的快照
            try {
                Get-Snapshot -VM $VM -Name "Backup-*" | Remove-Snapshot -Confirm:$false
            } catch {}
        }
    }
    
    # 断开vCenter
    Disconnect-VIServer -Server $vCenterServer -Confirm:$false
    
    # 备份摘要
    Write-Log "===== 备份任务完成 ====="
    Write-Log "成功: $SuccessCount"
    Write-Log "失败: $FailCount"
    if ($FailCount -gt 0) {
        Write-Log "失败的VM: $($FailedVMs -join ', ')"
    }
    
    # 发送邮件通知
    $EmailBody = @"
VMware备份任务报告

执行时间: $(Get-Date -Format "yyyy-MM-dd HH:mm:ss")
总计: $($VMsToBackup.Count) 台虚拟机
成功: $SuccessCount
失败: $FailCount

$(if ($FailCount -gt 0) { "失败的VM:`n$($FailedVMs -join "`n")" })

详细日志: $LogFile
"@
    
    Send-MailMessage -To $EmailTo -From $EmailFrom -Subject "VMware备份报告 - $(Get-Date -Format 'yyyy-MM-dd')" `
        -Body $EmailBody -SmtpServer $SMTPServer
    
} catch {
    Write-Log "❌ 备份任务异常: $($_.Exception.Message)"
    
    # 发送告警邮件
    Send-MailMessage -To $EmailTo -From $EmailFrom -Subject "VMware备份失败 - $(Get-Date -Format 'yyyy-MM-dd')" `
        -Body "备份任务异常终止:`n$($_.Exception.Message)`n`n详细日志: $LogFile" -SmtpServer $SMTPServer
    
    exit 1
}
```

### 2.2 KVM备份脚本

```bash
#!/bin/bash
# ========================================
# KVM自动化备份脚本
# ========================================

# 配置参数
BACKUP_DIR="/backup/kvm"
LOG_DIR="/var/log/kvm-backup"
RETENTION_DAYS=30
EMAIL="admin@example.com"

# 创建目录
mkdir -p "$BACKUP_DIR" "$LOG_DIR"
LOG_FILE="$LOG_DIR/backup-$(date +%Y%m%d-%H%M%S).log"

# 日志函数
log() {
    echo "[$(date +'%Y-%m-%d %H:%M:%S')] $1" | tee -a "$LOG_FILE"
}

# 错误处理
error_exit() {
    log "❌ 错误: $1"
    echo "KVM备份失败" | mail -s "KVM Backup Failed" "$EMAIL"
    exit 1
}

log "===== KVM备份任务开始 ====="

# 获取所有运行中的VM
VMS=$(virsh list --name)
TOTAL=$(echo "$VMS" | wc -w)
SUCCESS=0
FAILED=0
FAILED_VMS=""

log "找到 $TOTAL 台虚拟机需要备份"

for VM in $VMS; do
    log "开始备份虚拟机: $VM"
    
    VM_BACKUP_DIR="$BACKUP_DIR/$VM/$(date +%Y%m%d)"
    mkdir -p "$VM_BACKUP_DIR"
    
    # 备份VM定义
    log "  备份VM定义: $VM"
    if virsh dumpxml "$VM" > "$VM_BACKUP_DIR/$VM.xml"; then
        log "  ✅ VM定义备份成功"
    else
        log "  ❌ VM定义备份失败"
        ((FAILED++))
        FAILED_VMS="$FAILED_VMS $VM"
        continue
    fi
    
    # 获取磁盘列表
    DISKS=$(virsh domblklist "$VM" --details | grep disk | awk '{print $4}')
    
    for DISK in $DISKS; do
        DISK_NAME=$(basename "$DISK")
        log "  备份磁盘: $DISK_NAME"
        
        # 创建外部快照
        SNAPSHOT_NAME="backup-$(date +%Y%m%d-%H%M%S)"
        if virsh snapshot-create-as "$VM" "$SNAPSHOT_NAME" \
            --description "Backup snapshot" \
            --disk-only --atomic --no-metadata 2>&1 | tee -a "$LOG_FILE"; then
            
            log "  快照创建成功: $SNAPSHOT_NAME"
            
            # 备份原磁盘 (快照已冻结状态)
            if rsync -ah --progress "$DISK" "$VM_BACKUP_DIR/" 2>&1 | tee -a "$LOG_FILE"; then
                log "  ✅ 磁盘备份成功: $DISK_NAME"
            else
                log "  ❌ 磁盘备份失败: $DISK_NAME"
                ((FAILED++))
                FAILED_VMS="$FAILED_VMS $VM"
                continue
            fi
            
            # 合并快照 (blockcommit)
            log "  合并快照..."
            if virsh blockcommit "$VM" "$DISK" --active --pivot 2>&1 | tee -a "$LOG_FILE"; then
                log "  ✅ 快照合并成功"
            else
                log "  ⚠️  快照合并失败，请手动检查"
            fi
            
        else
            log "  ❌ 快照创建失败"
            ((FAILED++))
            FAILED_VMS="$FAILED_VMS $VM"
            continue
        fi
    done
    
    # 保存VM信息
    virsh dominfo "$VM" > "$VM_BACKUP_DIR/vm-info.txt"
    
    log "✅ 虚拟机备份完成: $VM"
    ((SUCCESS++))
done

# 清理旧备份
log "清理 $RETENTION_DAYS 天前的旧备份"
find "$BACKUP_DIR" -type d -mtime +$RETENTION_DAYS -exec rm -rf {} + 2>/dev/null

# 备份摘要
log "===== 备份任务完成 ====="
log "总计: $TOTAL"
log "成功: $SUCCESS"
log "失败: $FAILED"
if [ $FAILED -gt 0 ]; then
    log "失败的VM:$FAILED_VMS"
fi

# 发送邮件通知
MAIL_BODY="KVM备份任务报告

执行时间: $(date +'%Y-%m-%d %H:%M:%S')
总计: $TOTAL 台虚拟机
成功: $SUCCESS
失败: $FAILED

$(if [ $FAILED -gt 0 ]; then echo "失败的VM:$FAILED_VMS"; fi)

详细日志: $LOG_FILE
"

echo "$MAIL_BODY" | mail -s "KVM备份报告 - $(date +%Y-%m-%d)" "$EMAIL"

log "备份脚本执行完成"
```

---

## 3. Kubernetes备份

```yaml
Kubernetes_Backup:
  备份范围:
    集群级资源:
      - Namespaces
      - Nodes
      - PersistentVolumes
      - StorageClasses
      - ClusterRoles
      - ClusterRoleBindings
    
    命名空间级资源:
      - Deployments
      - StatefulSets
      - DaemonSets
      - Services
      - Ingresses
      - ConfigMaps
      - Secrets
      - PersistentVolumeClaims
    
    etcd数据:
      - 集群状态
      - 资源定义
      - 配置数据
      - 密钥信息

  备份工具:
    Velero:
      特点:
        - CNCF项目
        - 云原生备份
        - 支持多云
        - 灾难恢复
      
      功能:
        - 备份K8s资源
        - 备份PV数据
        - 定时备份
        - 增量备份
        - 跨集群迁移
      
      架构:
        - Velero Server (集群内Pod)
        - Velero CLI (管理工具)
        - Restic (文件级备份)
        - Object Storage (S3/MinIO/Azure)
    
    etcd备份:
      原生方法:
        - etcdctl snapshot
        - 定期快照
        - 增量备份
      
      自动化:
        - CronJob定时备份
        - 保留策略
        - 异地存储
    
    GitOps备份:
      工具:
        - Flux
        - ArgoCD
      
      优点:
        - 版本控制
        - 声明式配置
        - 审计追踪
        - 快速恢复
```

### 3.1 Velero部署与配置

```bash
#!/bin/bash
# ========================================
# Velero安装与配置脚本
# ========================================

# 前提条件:
# 1. Kubernetes集群已部署
# 2. kubectl已配置
# 3. MinIO/S3存储可用

# 安装Velero CLI
wget https://github.com/vmware-tanzu/velero/releases/download/v1.12.0/velero-v1.12.0-linux-amd64.tar.gz
tar -xvf velero-v1.12.0-linux-amd64.tar.gz
sudo mv velero-v1.12.0-linux-amd64/velero /usr/local/bin/
velero version --client-only

# ========================================
# 配置MinIO作为备份存储
# ========================================

# 创建MinIO凭证文件
cat > credentials-velero << EOF
[default]
aws_access_key_id = minioadmin
aws_secret_access_key = minioadmin
EOF

# 安装Velero (使用MinIO)
velero install \
    --provider aws \
    --plugins velero/velero-plugin-for-aws:v1.8.0 \
    --bucket velero \
    --secret-file ./credentials-velero \
    --use-volume-snapshots=false \
    --backup-location-config region=minio,s3ForcePathStyle="true",s3Url=http://minio.example.com:9000

# 验证安装
kubectl get pods -n velero
velero version

# ========================================
# 安装Restic (文件级备份)
# ========================================

velero install \
    --provider aws \
    --plugins velero/velero-plugin-for-aws:v1.8.0 \
    --bucket velero \
    --secret-file ./credentials-velero \
    --use-restic \
    --backup-location-config region=minio,s3ForcePathStyle="true",s3Url=http://minio.example.com:9000

# 为需要备份的Pod添加注解
kubectl -n my-app annotate pod/my-pod \
    backup.velero.io/backup-volumes=data-volume,config-volume

# ========================================
# 创建定时备份任务
# ========================================

# 每天凌晨2点备份
velero schedule create daily-backup \
    --schedule="0 2 * * *" \
    --ttl 720h0m0s

# 每周日凌晨备份 (保留90天)
velero schedule create weekly-backup \
    --schedule="0 2 * * 0" \
    --ttl 2160h0m0s

# 查看备份计划
velero schedule get

# ========================================
# 手动创建备份
# ========================================

# 备份整个集群
velero backup create full-cluster-backup

# 备份特定命名空间
velero backup create ns-backup --include-namespaces production,staging

# 备份特定资源
velero backup create deploy-backup \
    --include-resources deployments,services \
    --selector app=nginx

# 查看备份
velero backup get
velero backup describe full-cluster-backup

# 查看备份日志
velero backup logs full-cluster-backup

# ========================================
# 恢复操作
# ========================================

# 恢复整个备份
velero restore create --from-backup full-cluster-backup

# 恢复特定命名空间
velero restore create --from-backup full-cluster-backup \
    --include-namespaces production

# 恢复并重命名命名空间
velero restore create --from-backup full-cluster-backup \
    --namespace-mappings production:production-restored

# 查看恢复状态
velero restore get
velero restore describe <restore-name>
velero restore logs <restore-name>

echo "✅ Velero配置完成"
```

### 3.2 etcd备份脚本

```bash
#!/bin/bash
# ========================================
# etcd自动化备份脚本
# ========================================

BACKUP_DIR="/backup/etcd"
RETENTION_DAYS=7
LOG_FILE="/var/log/etcd-backup.log"

# etcd连接信息 (根据实际情况修改)
ETCDCTL_API=3
ENDPOINTS="https://192.168.10.101:2379"
CACERT="/etc/kubernetes/pki/etcd/ca.crt"
CERT="/etc/kubernetes/pki/etcd/server.crt"
KEY="/etc/kubernetes/pki/etcd/server.key"

# 创建备份目录
mkdir -p "$BACKUP_DIR"

# 日志函数
log() {
    echo "[$(date +'%Y-%m-%d %H:%M:%S')] $1" | tee -a "$LOG_FILE"
}

log "===== etcd备份开始 ====="

# 备份文件名
BACKUP_FILE="$BACKUP_DIR/etcd-snapshot-$(date +%Y%m%d-%H%M%S).db"

# 执行备份
log "创建etcd快照: $BACKUP_FILE"
if etcdctl --endpoints="$ENDPOINTS" \
    --cacert="$CACERT" \
    --cert="$CERT" \
    --key="$KEY" \
    snapshot save "$BACKUP_FILE" 2>&1 | tee -a "$LOG_FILE"; then
    
    log "✅ etcd快照创建成功"
    
    # 验证快照
    log "验证快照..."
    if etcdctl --write-out=table snapshot status "$BACKUP_FILE" 2>&1 | tee -a "$LOG_FILE"; then
        log "✅ 快照验证成功"
    else
        log "❌ 快照验证失败"
        exit 1
    fi
    
    # 压缩备份
    log "压缩备份文件..."
    gzip "$BACKUP_FILE"
    log "✅ 备份文件已压缩: ${BACKUP_FILE}.gz"
    
    # 上传到远程存储 (可选)
    # scp "${BACKUP_FILE}.gz" backup-server:/remote/backup/etcd/
    
else
    log "❌ etcd快照创建失败"
    exit 1
fi

# 清理旧备份
log "清理 $RETENTION_DAYS 天前的旧备份"
find "$BACKUP_DIR" -name "etcd-snapshot-*.db.gz" -type f -mtime +$RETENTION_DAYS -delete

log "===== etcd备份完成 ====="

# 列出当前备份
log "当前备份列表:"
ls -lh "$BACKUP_DIR"/etcd-snapshot-*.db.gz | tee -a "$LOG_FILE"
```

### 3.3 Kubernetes资源导出脚本

```bash
#!/bin/bash
# ========================================
# Kubernetes资源导出脚本
# ========================================

BACKUP_DIR="/backup/kubernetes/$(date +%Y%m%d)"
mkdir -p "$BACKUP_DIR"

echo "===== Kubernetes资源导出开始 ====="

# 导出所有命名空间
echo "导出命名空间..."
kubectl get namespaces -o yaml > "$BACKUP_DIR/namespaces.yaml"

# 导出集群级资源
echo "导出集群级资源..."
kubectl get clusterroles -o yaml > "$BACKUP_DIR/clusterroles.yaml"
kubectl get clusterrolebindings -o yaml > "$BACKUP_DIR/clusterrolebindings.yaml"
kubectl get storageclasses -o yaml > "$BACKUP_DIR/storageclasses.yaml"
kubectl get persistentvolumes -o yaml > "$BACKUP_DIR/persistentvolumes.yaml"

# 遍历所有命名空间
for NS in $(kubectl get ns -o jsonpath='{.items[*].metadata.name}'); do
    echo "导出命名空间: $NS"
    NS_DIR="$BACKUP_DIR/namespaces/$NS"
    mkdir -p "$NS_DIR"
    
    # 导出各种资源
    kubectl get deployments -n "$NS" -o yaml > "$NS_DIR/deployments.yaml" 2>/dev/null
    kubectl get statefulsets -n "$NS" -o yaml > "$NS_DIR/statefulsets.yaml" 2>/dev/null
    kubectl get daemonsets -n "$NS" -o yaml > "$NS_DIR/daemonsets.yaml" 2>/dev/null
    kubectl get services -n "$NS" -o yaml > "$NS_DIR/services.yaml" 2>/dev/null
    kubectl get ingresses -n "$NS" -o yaml > "$NS_DIR/ingresses.yaml" 2>/dev/null
    kubectl get configmaps -n "$NS" -o yaml > "$NS_DIR/configmaps.yaml" 2>/dev/null
    kubectl get secrets -n "$NS" -o yaml > "$NS_DIR/secrets.yaml" 2>/dev/null
    kubectl get pvc -n "$NS" -o yaml > "$NS_DIR/pvcs.yaml" 2>/dev/null
done

# 打包备份
echo "打包备份..."
cd "$BACKUP_DIR/.."
tar -czf "k8s-resources-$(date +%Y%m%d).tar.gz" "$(basename $BACKUP_DIR)"

echo "✅ Kubernetes资源导出完成: $(du -sh $BACKUP_DIR)"
echo "备份路径: $BACKUP_DIR"
```

---

## 4. 数据库备份

```yaml
Database_Backup:
  MySQL_Backup:
    备份工具:
      mysqldump:
        特点:
          - 逻辑备份
          - 文本SQL格式
          - 跨平台
          - 可选表/库
        
        命令:
          全库备份:
            mysqldump --all-databases \
                --single-transaction \
                --routines --triggers --events \
                --master-data=2 \
                > full-backup.sql
          
          单库备份:
            mysqldump database_name \
                --single-transaction \
                > database_name.sql
          
          压缩备份:
            mysqldump --all-databases \
                --single-transaction \
                | gzip > backup.sql.gz
      
      XtraBackup (Percona):
        特点:
          - 物理备份
          - 热备份
          - 增量备份
          - 快速恢复
        
        全量备份:
          xtrabackup --backup \
              --target-dir=/backup/full \
              --user=root --password=password
        
        增量备份:
          xtrabackup --backup \
              --target-dir=/backup/inc1 \
              --incremental-basedir=/backup/full \
              --user=root --password=password
      
      MySQL Enterprise Backup:
        - 官方企业工具
        - 支持加密备份
        - 云集成
    
    复制备份:
      主从复制:
        - 实时复制
        - 读写分离
        - 备份从库
      
      Group Replication:
        - 多主复制
        - 自动故障切换
        - 高可用

  PostgreSQL_Backup:
    备份工具:
      pg_dump:
        特点:
          - 逻辑备份
          - SQL/自定义格式
          - 可选对象
        
        命令:
          单库备份:
            pg_dump database_name > backup.sql
          
          自定义格式 (支持并行恢复):
            pg_dump -Fc database_name > backup.dump
          
          并行导出:
            pg_dump -Fd -j 4 database_name -f backup_dir
      
      pg_basebackup:
        特点:
          - 物理备份
          - 支持流式备份
          - PITR支持
        
        命令:
          pg_basebackup -D /backup/base \
              -Fp -Xs -P -R
      
      WAL归档:
        配置:
          archive_mode = on
          archive_command = 'cp %p /backup/wal/%f'
        
        优点:
          - PITR (时间点恢复)
          - 增量备份
          - 持续归档
    
    复制备份:
      Streaming Replication:
        - 实时复制
        - 同步/异步
        - 热备份
      
      Logical Replication:
        - 表级复制
        - 跨版本
        - 选择性复制

  MongoDB_Backup:
    备份工具:
      mongodump:
        特点:
          - 逻辑备份
          - BSON格式
          - 支持查询备份
        
        命令:
          全库备份:
            mongodump --out=/backup/mongo
          
          单库备份:
            mongodump --db=mydb --out=/backup/
          
          压缩备份:
            mongodump --archive=backup.gz --gzip
      
      Filesystem Snapshot:
        - 存储级快照
        - LVM/ZFS快照
        - 云快照
      
      Ops Manager / Cloud Manager:
        - 企业备份
        - 自动化
        - 时间点恢复
    
    复制备份:
      Replica Set:
        - 自动复制
        - 选举机制
        - 读取首选项

  Redis_Backup:
    备份方式:
      RDB快照:
        特点:
          - 时间点快照
          - 二进制格式
          - 适合全量备份
        
        配置:
          save 900 1      # 15分钟内至少1个key变化
          save 300 10     # 5分钟内至少10个key变化
          save 60 10000   # 1分钟内至少10000个key变化
        
        手动备份:
          redis-cli SAVE
          redis-cli BGSAVE
      
      AOF日志:
        特点:
          - 追加日志
          - 每秒/每命令fsync
          - 适合持续备份
        
        配置:
          appendonly yes
          appendfsync everysec
      
      组合策略:
        - RDB: 定期全量
        - AOF: 实时增量
        - 最佳实践: 同时启用
```

### 4.1 MySQL备份脚本

```bash
#!/bin/bash
# ========================================
# MySQL自动化备份脚本
# ========================================

# 配置参数
MYSQL_USER="backup_user"
MYSQL_PASSWORD="BackupP@ss123"
MYSQL_HOST="localhost"
BACKUP_DIR="/backup/mysql"
RETENTION_DAYS=7
LOG_FILE="/var/log/mysql-backup.log"
EMAIL="dba@example.com"

# 创建备份目录
mkdir -p "$BACKUP_DIR"

# 日志函数
log() {
    echo "[$(date +'%Y-%m-%d %H:%M:%S')] $1" | tee -a "$LOG_FILE"
}

log "===== MySQL备份开始 ====="

# 备份文件名
BACKUP_DATE=$(date +%Y%m%d-%H%M%S)
BACKUP_FILE="$BACKUP_DIR/mysql-full-$BACKUP_DATE.sql.gz"

# 执行备份
log "开始备份MySQL数据库"
if mysqldump --user="$MYSQL_USER" --password="$MYSQL_PASSWORD" \
    --host="$MYSQL_HOST" \
    --all-databases \
    --single-transaction \
    --quick \
    --lock-tables=false \
    --routines \
    --triggers \
    --events \
    --master-data=2 \
    --flush-logs \
    | gzip > "$BACKUP_FILE" 2>&1 | tee -a "$LOG_FILE"; then
    
    log "✅ MySQL备份成功"
    
    # 备份文件信息
    BACKUP_SIZE=$(du -sh "$BACKUP_FILE" | cut -f1)
    log "备份文件大小: $BACKUP_SIZE"
    log "备份文件路径: $BACKUP_FILE"
    
else
    log "❌ MySQL备份失败"
    echo "MySQL备份失败，请检查日志: $LOG_FILE" | mail -s "MySQL Backup Failed" "$EMAIL"
    exit 1
fi

# 验证备份
log "验证备份文件..."
if gunzip -t "$BACKUP_FILE" 2>&1 | tee -a "$LOG_FILE"; then
    log "✅ 备份文件完整性验证通过"
else
    log "❌ 备份文件损坏"
    echo "MySQL备份文件损坏！" | mail -s "MySQL Backup Corrupted" "$EMAIL"
    exit 1
fi

# 备份binlog (可选)
log "备份binlog文件"
BINLOG_DIR="$BACKUP_DIR/binlog-$BACKUP_DATE"
mkdir -p "$BINLOG_DIR"
cp /var/lib/mysql/mysql-bin.* "$BINLOG_DIR/" 2>/dev/null
log "✅ binlog备份完成"

# 清理旧备份
log "清理 $RETENTION_DAYS 天前的旧备份"
find "$BACKUP_DIR" -name "mysql-full-*.sql.gz" -type f -mtime +$RETENTION_DAYS -delete
find "$BACKUP_DIR" -name "binlog-*" -type d -mtime +$RETENTION_DAYS -exec rm -rf {} + 2>/dev/null

log "===== MySQL备份完成 ====="

# 发送成功通知
MAIL_BODY="MySQL备份成功

备份时间: $(date +'%Y-%m-%d %H:%M:%S')
备份文件: $BACKUP_FILE
文件大小: $BACKUP_SIZE

详细日志: $LOG_FILE
"

echo "$MAIL_BODY" | mail -s "MySQL Backup Success - $(date +%Y-%m-%d)" "$EMAIL"

# 上传到远程存储 (可选)
# scp "$BACKUP_FILE" backup-server:/remote/backup/mysql/
# aws s3 cp "$BACKUP_FILE" s3://my-bucket/mysql-backups/
```

### 4.2 PostgreSQL备份脚本

```bash
#!/bin/bash
# ========================================
# PostgreSQL自动化备份脚本
# ========================================

# 配置参数
PG_USER="postgres"
PG_HOST="localhost"
PG_PORT="5432"
BACKUP_DIR="/backup/postgresql"
RETENTION_DAYS=7
LOG_FILE="/var/log/pg-backup.log"

# 创建备份目录
mkdir -p "$BACKUP_DIR"

# 日志函数
log() {
    echo "[$(date +'%Y-%m-%d %H:%M:%S')] $1" | tee -a "$LOG_FILE"
}

log "===== PostgreSQL备份开始 ====="

# 备份日期
BACKUP_DATE=$(date +%Y%m%d-%H%M%S)

# 获取所有数据库列表
DATABASES=$(psql -U "$PG_USER" -h "$PG_HOST" -p "$PG_PORT" -t -c "SELECT datname FROM pg_database WHERE datistemplate = false AND datname != 'postgres';")

# 备份全局对象 (角色和表空间)
log "备份全局对象"
GLOBALS_FILE="$BACKUP_DIR/pg_globals-$BACKUP_DATE.sql"
if pg_dumpall -U "$PG_USER" -h "$PG_HOST" -p "$PG_PORT" --globals-only > "$GLOBALS_FILE" 2>&1 | tee -a "$LOG_FILE"; then
    log "✅ 全局对象备份成功"
    gzip "$GLOBALS_FILE"
else
    log "❌ 全局对象备份失败"
fi

# 备份每个数据库
for DB in $DATABASES; do
    log "备份数据库: $DB"
    DB_BACKUP_FILE="$BACKUP_DIR/${DB}-$BACKUP_DATE.dump"
    
    if pg_dump -U "$PG_USER" -h "$PG_HOST" -p "$PG_PORT" \
        -Fc -b -v \
        -f "$DB_BACKUP_FILE" \
        "$DB" 2>&1 | tee -a "$LOG_FILE"; then
        
        log "✅ 数据库备份成功: $DB"
        
        # 备份文件信息
        BACKUP_SIZE=$(du -sh "$DB_BACKUP_FILE" | cut -f1)
        log "  文件大小: $BACKUP_SIZE"
    else
        log "❌ 数据库备份失败: $DB"
    fi
done

# 备份WAL归档 (如果启用了归档)
if psql -U "$PG_USER" -h "$PG_HOST" -p "$PG_PORT" -t -c "SHOW archive_mode;" | grep -q "on"; then
    log "备份WAL归档"
    WAL_BACKUP_DIR="$BACKUP_DIR/wal-$BACKUP_DATE"
    mkdir -p "$WAL_BACKUP_DIR"
    cp -r /var/lib/postgresql/14/main/pg_wal/* "$WAL_BACKUP_DIR/" 2>/dev/null
    log "✅ WAL归档备份完成"
fi

# 清理旧备份
log "清理 $RETENTION_DAYS 天前的旧备份"
find "$BACKUP_DIR" -name "*.dump" -type f -mtime +$RETENTION_DAYS -delete
find "$BACKUP_DIR" -name "pg_globals-*.sql.gz" -type f -mtime +$RETENTION_DAYS -delete
find "$BACKUP_DIR" -name "wal-*" -type d -mtime +$RETENTION_DAYS -exec rm -rf {} + 2>/dev/null

log "===== PostgreSQL备份完成 ====="

# 列出当前备份
log "当前备份列表:"
ls -lh "$BACKUP_DIR"/*.dump 2>/dev/null | tee -a "$LOG_FILE"
```

### 4.3 MongoDB备份脚本

```bash
#!/bin/bash
# ========================================
# MongoDB自动化备份脚本
# ========================================

# 配置参数
MONGO_USER="backup_user"
MONGO_PASSWORD="BackupP@ss123"
MONGO_HOST="localhost"
MONGO_PORT="27017"
BACKUP_DIR="/backup/mongodb"
RETENTION_DAYS=7
LOG_FILE="/var/log/mongo-backup.log"

# 创建备份目录
mkdir -p "$BACKUP_DIR"

# 日志函数
log() {
    echo "[$(date +'%Y-%m-%d %H:%M:%S')] $1" | tee -a "$LOG_FILE"
}

log "===== MongoDB备份开始 ====="

# 备份日期
BACKUP_DATE=$(date +%Y%m%d-%H%M%S)
BACKUP_PATH="$BACKUP_DIR/mongo-$BACKUP_DATE"

# 执行备份
log "开始备份MongoDB数据库"
if mongodump \
    --host="$MONGO_HOST:$MONGO_PORT" \
    --username="$MONGO_USER" \
    --password="$MONGO_PASSWORD" \
    --authenticationDatabase=admin \
    --out="$BACKUP_PATH" \
    --gzip \
    2>&1 | tee -a "$LOG_FILE"; then
    
    log "✅ MongoDB备份成功"
    
    # 打包备份
    log "打包备份文件"
    cd "$BACKUP_DIR"
    tar -czf "mongo-$BACKUP_DATE.tar.gz" "mongo-$BACKUP_DATE"
    rm -rf "mongo-$BACKUP_DATE"
    
    BACKUP_SIZE=$(du -sh "mongo-$BACKUP_DATE.tar.gz" | cut -f1)
    log "备份文件大小: $BACKUP_SIZE"
    
else
    log "❌ MongoDB备份失败"
    exit 1
fi

# 清理旧备份
log "清理 $RETENTION_DAYS 天前的旧备份"
find "$BACKUP_DIR" -name "mongo-*.tar.gz" -type f -mtime +$RETENTION_DAYS -delete

log "===== MongoDB备份完成 ====="

# 列出当前备份
log "当前备份列表:"
ls -lh "$BACKUP_DIR"/mongo-*.tar.gz | tee -a "$LOG_FILE"
```

---

## 5. 应用数据备份

```yaml
Application_Data_Backup:
  文件系统备份:
    rsync:
      特点:
        - 增量同步
        - 保留权限
        - 压缩传输
      
      命令:
        本地备份:
          rsync -avz --delete \
              /source/ /backup/destination/
        
        远程备份:
          rsync -avz -e ssh \
              /source/ user@remote:/backup/
        
        排除文件:
          rsync -avz --exclude='*.tmp' \
              --exclude='cache/' \
              /source/ /backup/
    
    tar归档:
      特点:
        - 打包压缩
        - 保留属性
        - 增量备份
      
      命令:
        全量备份:
          tar -czf backup.tar.gz /data/
        
        增量备份:
          tar -czf inc.tar.gz --listed-incremental=snapshot.file /data/
    
    ZFS快照:
      特点:
        - 写时复制
        - 即时快照
        - 增量发送
      
      命令:
        创建快照:
          zfs snapshot pool/dataset@snapshot1
        
        发送快照:
          zfs send pool/dataset@snapshot1 | gzip > backup.gz
        
        增量发送:
          zfs send -i @snapshot1 pool/dataset@snapshot2 | gzip > inc.gz

  对象存储备份:
    S3同步:
      工具: aws s3 sync, rclone, MinIO Client
      
      命令:
        # AWS CLI
        aws s3 sync /local/data/ s3://my-bucket/backup/
        
        # rclone
        rclone sync /local/data/ remote:bucket/backup/
        
        # MinIO
        mc mirror /local/data/ myminio/bucket/backup/
    
    版本控制:
      - S3版本管理
      - 对象版本历史
      - 误删除保护

  容器持久化卷备份:
    Docker Volume:
      备份方法:
        # 导出卷数据
        docker run --rm \
            -v myvolume:/data \
            -v /backup:/backup \
            alpine tar czf /backup/volume-backup.tar.gz -C /data .
      
      恢复方法:
        docker run --rm \
            -v myvolume:/data \
            -v /backup:/backup \
            alpine tar xzf /backup/volume-backup.tar.gz -C /data
    
    Kubernetes PV:
      备份方法:
        - Velero + Restic
        - CSI快照
        - 存储级快照 (Ceph/vSAN)
      
      恢复方法:
        - Velero恢复
        - 快照克隆
        - 数据复制
```

### 5.1 应用数据备份脚本

```bash
#!/bin/bash
# ========================================
# 应用数据自动化备份脚本
# ========================================

# 配置参数
APP_NAME="myapp"
APP_DATA_DIR="/var/www/html"
UPLOAD_DIR="/var/www/uploads"
CONFIG_DIR="/etc/myapp"
BACKUP_DIR="/backup/applications/$APP_NAME"
RETENTION_DAYS=30
LOG_FILE="/var/log/app-backup.log"
S3_BUCKET="s3://my-backup-bucket/applications/$APP_NAME"

# 创建备份目录
mkdir -p "$BACKUP_DIR"

# 日志函数
log() {
    echo "[$(date +'%Y-%m-%d %H:%M:%S')] $1" | tee -a "$LOG_FILE"
}

log "===== $APP_NAME 应用数据备份开始 ====="

# 备份日期
BACKUP_DATE=$(date +%Y%m%d-%H%M%S)
BACKUP_PATH="$BACKUP_DIR/$APP_NAME-$BACKUP_DATE"
mkdir -p "$BACKUP_PATH"

# 1. 备份应用代码
log "备份应用代码"
if rsync -avz --delete "$APP_DATA_DIR/" "$BACKUP_PATH/app/" 2>&1 | tee -a "$LOG_FILE"; then
    log "✅ 应用代码备份成功"
else
    log "❌ 应用代码备份失败"
fi

# 2. 备份用户上传文件
log "备份用户上传文件"
if rsync -avz --delete "$UPLOAD_DIR/" "$BACKUP_PATH/uploads/" 2>&1 | tee -a "$LOG_FILE"; then
    log "✅ 用户上传文件备份成功"
else
    log "❌ 用户上传文件备份失败"
fi

# 3. 备份配置文件
log "备份配置文件"
if cp -r "$CONFIG_DIR" "$BACKUP_PATH/config/" 2>&1 | tee -a "$LOG_FILE"; then
    log "✅ 配置文件备份成功"
else
    log "❌ 配置文件备份失败"
fi

# 4. 备份数据库 (如果有)
log "备份应用数据库"
DB_NAME="${APP_NAME}_db"
DB_BACKUP="$BACKUP_PATH/database.sql.gz"
if mysqldump --single-transaction "$DB_NAME" | gzip > "$DB_BACKUP" 2>&1 | tee -a "$LOG_FILE"; then
    log "✅ 数据库备份成功"
else
    log "❌ 数据库备份失败"
fi

# 5. 创建备份清单
log "创建备份清单"
cat > "$BACKUP_PATH/manifest.txt" << EOF
应用名称: $APP_NAME
备份时间: $(date +'%Y-%m-%d %H:%M:%S')
备份路径: $BACKUP_PATH
备份内容:
  - 应用代码: $APP_DATA_DIR
  - 上传文件: $UPLOAD_DIR
  - 配置文件: $CONFIG_DIR
  - 数据库: $DB_NAME

文件清单:
$(find "$BACKUP_PATH" -type f -exec ls -lh {} \; | awk '{print $9, $5}')

总大小: $(du -sh "$BACKUP_PATH" | cut -f1)
EOF

log "✅ 备份清单创建成功"

# 6. 打包备份
log "打包备份文件"
cd "$BACKUP_DIR"
if tar -czf "$APP_NAME-$BACKUP_DATE.tar.gz" "$APP_NAME-$BACKUP_DATE" 2>&1 | tee -a "$LOG_FILE"; then
    log "✅ 备份打包成功"
    rm -rf "$APP_NAME-$BACKUP_DATE"
    
    BACKUP_SIZE=$(du -sh "$APP_NAME-$BACKUP_DATE.tar.gz" | cut -f1)
    log "备份文件大小: $BACKUP_SIZE"
else
    log "❌ 备份打包失败"
fi

# 7. 上传到S3 (可选)
log "上传备份到S3"
if aws s3 cp "$BACKUP_DIR/$APP_NAME-$BACKUP_DATE.tar.gz" "$S3_BUCKET/" 2>&1 | tee -a "$LOG_FILE"; then
    log "✅ 备份上传成功"
else
    log "⚠️  备份上传失败，保留本地备份"
fi

# 8. 清理旧备份
log "清理 $RETENTION_DAYS 天前的本地旧备份"
find "$BACKUP_DIR" -name "$APP_NAME-*.tar.gz" -type f -mtime +$RETENTION_DAYS -delete

# 清理S3旧备份 (保留90天)
log "清理90天前的S3旧备份"
aws s3 ls "$S3_BUCKET/" | \
    awk '{print $4}' | \
    while read file; do
        file_date=$(echo "$file" | grep -oP '\d{8}' | head -1)
        if [ ! -z "$file_date" ]; then
            days_old=$(( ($(date +%s) - $(date -d "$file_date" +%s)) / 86400 ))
            if [ $days_old -gt 90 ]; then
                log "删除旧备份: $file (${days_old}天前)"
                aws s3 rm "$S3_BUCKET/$file"
            fi
        fi
    done

log "===== $APP_NAME 应用数据备份完成 ====="

# 列出当前备份
log "本地备份列表:"
ls -lh "$BACKUP_DIR"/*.tar.gz 2>/dev/null | tail -5 | tee -a "$LOG_FILE"

log "S3备份列表:"
aws s3 ls "$S3_BUCKET/" | tail -5 | tee -a "$LOG_FILE"
```

---

## 6. 备份存储与管理

```yaml
Backup_Storage:
  存储类型:
    磁盘存储:
      本地磁盘:
        优点:
          - 速度快
          - 成本低
          - 访问方便
        缺点:
          - 容量有限
          - 单点故障
          - 需定期维护
        适用: 短期备份、快速恢复
      
      NAS存储:
        优点:
          - 集中管理
          - 网络访问
          - 容量可扩展
        缺点:
          - 网络依赖
          - 成本较高
        适用: 中期备份、共享访问
      
      SAN存储:
        优点:
          - 高性能
          - 块级访问
          - 企业级可靠性
        缺点:
          - 成本高
          - 复杂度高
        适用: 大型企业备份
    
    磁带存储:
      LTO磁带:
        优点:
          - 成本最低
          - 大容量 (15TB+)
          - 长期保存 (30年+)
          - 离线安全
        缺点:
          - 访问慢
          - 顺序读取
          - 需要磁带库
        适用: 长期归档、合规要求
      
      管理:
        - 磁带循环策略
        - GFS策略 (Grandfather-Father-Son)
        - 异地存放
    
    云存储:
      对象存储:
        - AWS S3
        - Azure Blob
        - Google Cloud Storage
        - MinIO (私有云)
      
      优点:
        - 无限容量
        - 高可用性
        - 地理冗余
        - 按需付费
      
      存储类别:
        Standard (标准):
          - 频繁访问
          - 低延迟
          - 成本较高
        
        Infrequent Access (IA):
          - 不频繁访问
          - 低成本
          - 检索费用
        
        Glacier (归档):
          - 长期归档
          - 极低成本
          - 检索时间长 (分钟-小时)
        
        Deep Archive (深度归档):
          - 超长期归档
          - 最低成本
          - 检索时间 (12-48小时)

  备份生命周期:
    热备份 (Hot):
      - 0-7天
      - 本地磁盘/NAS
      - 快速恢复
      - 频繁访问
    
    温备份 (Warm):
      - 8-30天
      - 云标准存储
      - 中等恢复速度
      - 偶尔访问
    
    冷备份 (Cold):
      - 31-90天
      - 云IA存储
      - 较慢恢复
      - 很少访问
    
    归档 (Archive):
      - 90天+
      - 磁带/云归档
      - 长期保存
      - 合规需求

  备份策略示例:
    GFS策略 (Grandfather-Father-Son):
      Son (儿子 - 每日):
        - 每天增量备份
        - 保留7天
        - 本地磁盘
      
      Father (父亲 - 每周):
        - 每周差异备份
        - 保留4周
        - NAS/云标准
      
      Grandfather (祖父 - 每月):
        - 每月全量备份
        - 保留12个月
        - 云归档/磁带
      
      Yearly (年度):
        - 年度全量备份
        - 保留7年
        - 磁带/深度归档
    
    Tower of Hanoi:
      - 减少全备频率
      - 优化存储空间
      - 复杂但高效

  备份加密与压缩:
    加密:
      传输加密:
        - TLS/SSL
        - SSH
        - VPN
      
      存储加密:
        - AES-256
        - 客户端加密
        - 密钥管理 (KMS)
      
      工具:
        # GPG加密
        gpg --encrypt --recipient backup@example.com backup.tar.gz
        
        # OpenSSL加密
        openssl enc -aes-256-cbc -salt -in backup.tar -out backup.tar.enc
    
    压缩:
      工具对比:
        gzip:
          - 速度快
          - 压缩率中等
          - 广泛支持
        
        bzip2:
          - 速度慢
          - 压缩率高
          - CPU密集
        
        xz:
          - 速度较慢
          - 压缩率最高
          - 内存占用大
        
        zstd:
          - 速度快
          - 压缩率高
          - 现代推荐
      
      命令:
        tar -czf backup.tar.gz /data/      # gzip
        tar -cjf backup.tar.bz2 /data/     # bzip2
        tar -cJf backup.tar.xz /data/      # xz
        tar --zstd -cf backup.tar.zst /data/  # zstd

  备份重复数据删除:
    工具:
      - Veeam (内置去重)
      - Bacula (插件去重)
      - Duplicity (增量去重)
      - BorgBackup (块级去重)
      - Restic (去重备份)
    
    优点:
      - 节省存储空间 (30-95%)
      - 减少网络传输
      - 加快备份速度
    
    方法:
      固定块去重:
        - 固定大小块
        - 简单快速
        - 效果一般
      
      可变块去重:
        - 可变大小块
        - 复杂高效
        - 效果最佳
```

---

## 7. 恢复流程

```yaml
Recovery_Procedures:
  恢复类型:
    文件级恢复:
      场景: 误删文件、文件损坏
      步骤:
        1. 确定文件位置和时间点
        2. 查找对应备份
        3. 提取目标文件
        4. 恢复到原位置或临时位置
        5. 验证文件完整性
        6. 通知用户
      
      工具:
        - 备份软件文件浏览
        - tar解压特定文件
        - Velero恢复特定资源
    
    系统级恢复:
      场景: 操作系统故障、系统配置错误
      步骤:
        1. 准备恢复环境
        2. 启动恢复介质
        3. 选择恢复时间点
        4. 执行系统恢复
        5. 验证系统启动
        6. 测试系统功能
      
      方法:
        - 裸机恢复 (BMR)
        - 系统镜像恢复
        - 虚拟机快照回滚
    
    应用级恢复:
      场景: 应用故障、数据损坏
      步骤:
        1. 停止应用服务
        2. 备份当前状态 (安全起见)
        3. 恢复应用数据
        4. 恢复配置文件
        5. 启动应用服务
        6. 验证应用功能
      
      注意:
        - 依赖关系处理
        - 配置文件兼容性
        - 数据库一致性
    
    数据库恢复:
      场景: 数据库损坏、数据丢失
      
      MySQL恢复:
        全量恢复:
          mysql < full-backup.sql
        
        时间点恢复 (PITR):
          1. 恢复全量备份
          2. 应用binlog到指定时间点
          mysqlbinlog --stop-datetime="2025-10-19 14:30:00" \
              mysql-bin.000001 | mysql
      
      PostgreSQL恢复:
        全量恢复:
          pg_restore -d database_name backup.dump
        
        时间点恢复:
          1. 恢复基础备份
          2. 配置recovery.conf
          3. 应用WAL到指定时间点
      
      MongoDB恢复:
        mongorestore --gzip --dir=/backup/mongo

  灾难恢复 (DR):
    DR计划:
      1. 灾难声明
      2. 激活DR团队
      3. 评估损坏范围
      4. 启动恢复流程
      5. 验证系统功能
      6. 切换生产流量
      7. 事后分析
    
    DR演练:
      频率: 每季度/每半年
      内容:
        - 完整恢复流程
        - 团队协作
        - 文档验证
        - 时间记录
      
      评估:
        - RTO达成率
        - RPO达成率
        - 团队响应时间
        - 流程改进点

  恢复验证:
    验证内容:
      文件完整性:
        - 文件数量
        - 文件大小
        - 校验和 (MD5/SHA256)
      
      数据一致性:
        - 数据库完整性检查
        - 外键约束验证
        - 业务逻辑测试
      
      系统功能:
        - 服务启动测试
        - 应用功能测试
        - 性能基准测试
      
      业务验证:
        - 关键业务流程测试
        - 用户验收测试
        - 性能验收测试
    
    验证脚本:
      自动化验证:
        - 健康检查脚本
        - 功能测试脚本
        - 数据一致性检查
        - 报告生成
```

### 7.1 恢复脚本示例

```bash
#!/bin/bash
# ========================================
# MySQL恢复脚本
# ========================================

# 配置参数
MYSQL_USER="root"
MYSQL_PASSWORD="password"
BACKUP_FILE="$1"
TARGET_DB="$2"

# 参数检查
if [ -z "$BACKUP_FILE" ] || [ -z "$TARGET_DB" ]; then
    echo "用法: $0 <backup_file> <target_database>"
    echo "示例: $0 /backup/mysql-full-20251019.sql.gz mydb"
    exit 1
fi

# 检查备份文件
if [ ! -f "$BACKUP_FILE" ]; then
    echo "❌ 备份文件不存在: $BACKUP_FILE"
    exit 1
fi

echo "===== MySQL数据库恢复 ====="
echo "备份文件: $BACKUP_FILE"
echo "目标数据库: $TARGET_DB"
echo ""

# 询问确认
read -p "确认要恢复数据库吗? (yes/no): " CONFIRM
if [ "$CONFIRM" != "yes" ]; then
    echo "取消恢复操作"
    exit 0
fi

# 备份当前数据库 (安全起见)
echo "备份当前数据库..."
mysqldump --user="$MYSQL_USER" --password="$MYSQL_PASSWORD" \
    "$TARGET_DB" | gzip > "/tmp/${TARGET_DB}-before-restore-$(date +%Y%m%d%H%M%S).sql.gz"

# 删除现有数据库 (可选)
read -p "是否删除现有数据库? (yes/no): " DROP_DB
if [ "$DROP_DB" = "yes" ]; then
    echo "删除现有数据库..."
    mysql --user="$MYSQL_USER" --password="$MYSQL_PASSWORD" \
        -e "DROP DATABASE IF EXISTS $TARGET_DB;"
fi

# 创建数据库
echo "创建数据库..."
mysql --user="$MYSQL_USER" --password="$MYSQL_PASSWORD" \
    -e "CREATE DATABASE IF NOT EXISTS $TARGET_DB CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;"

# 恢复数据库
echo "恢复数据库..."
if [[ "$BACKUP_FILE" == *.gz ]]; then
    gunzip < "$BACKUP_FILE" | mysql --user="$MYSQL_USER" --password="$MYSQL_PASSWORD" "$TARGET_DB"
else
    mysql --user="$MYSQL_USER" --password="$MYSQL_PASSWORD" "$TARGET_DB" < "$BACKUP_FILE"
fi

if [ $? -eq 0 ]; then
    echo "✅ 数据库恢复成功"
    
    # 验证恢复
    echo "验证数据库..."
    TABLE_COUNT=$(mysql --user="$MYSQL_USER" --password="$MYSQL_PASSWORD" \
        -e "SELECT COUNT(*) FROM information_schema.tables WHERE table_schema='$TARGET_DB';" -s -N)
    echo "表数量: $TABLE_COUNT"
    
    # 运行mysqlcheck
    echo "检查数据库完整性..."
    mysqlcheck --user="$MYSQL_USER" --password="$MYSQL_PASSWORD" --check --databases "$TARGET_DB"
    
else
    echo "❌ 数据库恢复失败"
    exit 1
fi

echo "===== 恢复完成 ====="
```

---

## 8. 备份监控与验证

```yaml
Backup_Monitoring:
  监控指标:
    备份任务状态:
      - 任务成功率
      - 任务失败原因
      - 任务执行时间
      - 任务超时告警
    
    备份数据:
      - 备份文件大小
      - 备份增长趋势
      - 备份完整性
      - 备份覆盖率
    
    存储资源:
      - 存储空间使用率
      - 存储增长速度
      - 存储容量告警
      - 存储性能指标
    
    恢复能力:
      - RTO达成率
      - RPO达成率
      - 恢复成功率
      - 恢复测试频率

  监控工具:
    Prometheus + Grafana:
      指标采集:
        - 备份任务exporter
        - 文件系统指标
        - 数据库指标
      
      告警规则:
        - 备份失败告警
        - 存储空间告警
        - 备份超时告警
        - 恢复失败告警
    
    日志聚合:
      - ELK Stack
      - Loki
      - 备份日志收集
      - 错误日志分析
    
    邮件通知:
      - 备份成功/失败通知
      - 每日备份报告
      - 每周备份摘要
      - 月度备份统计

  备份验证:
    自动验证:
      文件完整性:
        - 校验和验证
        - 文件解压测试
        - 文件列表对比
      
      恢复测试:
        - 自动恢复到测试环境
        - 功能验证测试
        - 性能基准测试
      
      频率:
        - 关键备份: 每天验证
        - 重要备份: 每周验证
        - 普通备份: 每月验证
    
    手动验证:
      季度DR演练:
        - 完整灾难恢复流程
        - 多系统协同验证
        - 团队响应验证
      
      年度审计:
        - 备份策略审查
        - 合规性检查
        - 文档更新

  备份报告:
    每日报告:
      - 今日备份任务
      - 成功/失败统计
      - 存储使用情况
      - 异常事件
    
    每周报告:
      - 本周备份概况
      - 备份趋势分析
      - 存储增长预测
      - 问题和改进
    
    每月报告:
      - 月度备份统计
      - SLA达成率
      - 容量规划建议
      - 优化建议
```

### 8.1 备份监控脚本

```bash
#!/bin/bash
# ========================================
# 备份监控与验证脚本
# ========================================

BACKUP_DIRS="/backup/vmware /backup/kubernetes /backup/mysql /backup/postgresql"
LOG_FILE="/var/log/backup-monitor.log"
ALERT_EMAIL="admin@example.com"
ALERT_THRESHOLD_DAYS=2

# 日志函数
log() {
    echo "[$(date +'%Y-%m-%d %H:%M:%S')] $1" | tee -a "$LOG_FILE"
}

log "===== 备份监控检查开始 ====="

# 检查函数
check_backup_age() {
    local dir=$1
    local name=$(basename "$dir")
    
    log "检查 $name 备份"
    
    # 查找最新备份
    latest_backup=$(find "$dir" -type f -name "*.gz" -o -name "*.tar.gz" -o -name "*.sql.gz" 2>/dev/null | sort -r | head -1)
    
    if [ -z "$latest_backup" ]; then
        log "  ❌ 未找到备份文件"
        echo "警告: $name 目录中未找到备份文件" | mail -s "Backup Alert: No Backup Found" "$ALERT_EMAIL"
        return 1
    fi
    
    # 检查备份年龄
    backup_age_seconds=$(( $(date +%s) - $(stat -c %Y "$latest_backup") ))
    backup_age_days=$(( backup_age_seconds / 86400 ))
    
    log "  最新备份: $(basename "$latest_backup")"
    log "  备份年龄: $backup_age_days 天"
    
    if [ $backup_age_days -gt $ALERT_THRESHOLD_DAYS ]; then
        log "  ⚠️  备份过旧 (超过 $ALERT_THRESHOLD_DAYS 天)"
        echo "警告: $name 最新备份已经 $backup_age_days 天未更新" | \
            mail -s "Backup Alert: Backup Too Old" "$ALERT_EMAIL"
    else
        log "  ✅ 备份正常"
    fi
    
    # 检查备份文件完整性
    log "  验证备份完整性..."
    if file "$latest_backup" | grep -q "gzip compressed"; then
        if gunzip -t "$latest_backup" 2>/dev/null; then
            log "  ✅ 备份文件完整"
        else
            log "  ❌ 备份文件损坏"
            echo "错误: $name 备份文件损坏: $latest_backup" | \
                mail -s "Backup Alert: Corrupted Backup" "$ALERT_EMAIL"
        fi
    fi
}

# 检查所有备份目录
for dir in $BACKUP_DIRS; do
    if [ -d "$dir" ]; then
        check_backup_age "$dir"
    else
        log "⚠️  备份目录不存在: $dir"
    fi
    echo ""
done

# 检查存储空间
log "检查存储空间"
for dir in $BACKUP_DIRS; do
    if [ -d "$dir" ]; then
        usage=$(df -h "$dir" | awk 'NR==2 {print $5}' | sed 's/%//')
        log "  $(basename $dir): ${usage}% 已使用"
        
        if [ "$usage" -gt 90 ]; then
            log "  ⚠️  存储空间不足 (${usage}%)"
            echo "警告: $(basename $dir) 存储空间使用率 ${usage}%" | \
                mail -s "Backup Alert: Low Storage" "$ALERT_EMAIL"
        fi
    fi
done

log "===== 备份监控检查完成 ====="

# 生成报告
REPORT="/tmp/backup-report-$(date +%Y%m%d).txt"
cat > "$REPORT" << EOF
备份监控报告
生成时间: $(date +'%Y-%m-%d %H:%M:%S')

备份状态:
$(for dir in $BACKUP_DIRS; do
    if [ -d "$dir" ]; then
        name=$(basename "$dir")
        count=$(find "$dir" -type f -name "*.gz" -o -name "*.tar.gz" -o -name "*.sql.gz" 2>/dev/null | wc -l)
        size=$(du -sh "$dir" 2>/dev/null | cut -f1)
        latest=$(find "$dir" -type f -name "*.gz" -o -name "*.tar.gz" -o -name "*.sql.gz" 2>/dev/null | sort -r | head -1)
        if [ ! -z "$latest" ]; then
            age=$(( ($(date +%s) - $(stat -c %Y "$latest")) / 86400 ))
            echo "  $name: $count 个备份, 总计 $size, 最新备份 $age 天前"
        else
            echo "  $name: 无备份"
        fi
    fi
done)

存储使用情况:
$(for dir in $BACKUP_DIRS; do
    if [ -d "$dir" ]; then
        df -h "$dir" | awk 'NR==2 {printf "  %s: %s / %s (%s)\n", $6, $3, $2, $5}'
    fi
done)

详细日志: $LOG_FILE
EOF

# 发送报告
cat "$REPORT" | mail -s "Daily Backup Report - $(date +%Y-%m-%d)" "$ALERT_EMAIL"

log "报告已发送到: $ALERT_EMAIL"
```

---

## 9. 最佳实践

```yaml
Backup_Best_Practices:
  策略制定:
    ✅ 遵循3-2-1规则
    ✅ 根据业务优先级分级备份
    ✅ 定义明确的RPO和RTO
    ✅ 制定详细的备份计划
    ✅ 定期审查和更新策略
  
  备份执行:
    ✅ 自动化备份任务
    ✅ 避开业务高峰期
    ✅ 使用增量/差异备份减少开销
    ✅ 启用备份压缩
    ✅ 加密敏感数据备份
    ✅ 记录详细的备份日志
  
  存储管理:
    ✅ 实施分层存储策略
    ✅ 定期清理过期备份
    ✅ 监控存储空间使用
    ✅ 异地备份关键数据
    ✅ 使用重复数据删除
  
  验证测试:
    ✅ 定期验证备份完整性
    ✅ 定期执行恢复演练
    ✅ 测试恢复时间
    ✅ 验证数据一致性
    ✅ 记录测试结果
  
  监控告警:
    ✅ 监控备份任务状态
    ✅ 设置失败告警
    ✅ 监控存储容量
    ✅ 生成定期报告
    ✅ 建立响应流程
  
  文档维护:
    ✅ 维护备份策略文档
    ✅ 记录恢复流程
    ✅ 更新联系人列表
    ✅ 文档化特殊配置
    ✅ 保持文档更新
  
  安全措施:
    ✅ 备份数据加密
    ✅ 限制备份访问权限
    ✅ 定期轮换加密密钥
    ✅ 审计备份操作
    ✅ 离线备份副本 (Air-gap)

常见错误:
  ❌ 只有一份备份副本
  ❌ 备份和生产在同一存储
  ❌ 从不验证备份
  ❌ 没有异地备份
  ❌ 没有备份加密
  ❌ 备份窗口过长
  ❌ 没有监控备份状态
  ❌ 恢复流程未测试
  ❌ 文档过时或缺失
  ❌ 忽略备份告警

检查清单:
  每日检查:
    ✅ 备份任务完成
    ✅ 无失败告警
    ✅ 存储空间充足
    ✅ 备份日志正常
  
  每周检查:
    ✅ 备份完整性验证
    ✅ 恢复测试
    ✅ 存储使用趋势
    ✅ 备份策略执行情况
  
  每月检查:
    ✅ 完整DR演练
    ✅ 备份策略审查
    ✅ 容量规划
    ✅ 文档更新
    ✅ 团队培训
  
  每季度检查:
    ✅ 全面灾难恢复演练
    ✅ 备份架构审查
    ✅ 安全审计
    ✅ 合规性检查
    ✅ 供应商评估
```

---

## 相关文档

- [VMware高可用配置](01_VMware高可用配置.md)
- [Kubernetes高可用架构](02_Kubernetes高可用架构.md)
- [容灾演练流程](04_容灾演练流程.md)
- [存储容灾与备份](../03_存储架构/07_存储容灾与备份.md)

---

**更新时间**: 2025-10-19  
**文档版本**: v1.0  
**状态**: ✅ 生产就绪
