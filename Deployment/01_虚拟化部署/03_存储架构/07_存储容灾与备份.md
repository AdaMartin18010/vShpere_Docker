# 存储容灾与备份方案

> **返回**: [存储架构目录](README.md) | [虚拟化部署首页](../README.md) | [部署指南首页](../../00_索引导航/README.md)

---

## 📋 目录

- [存储容灾与备份方案](#存储容灾与备份方案)
  - [📋 目录](#-目录)
  - [容灾备份概述](#容灾备份概述)
  - [备份策略与方案](#备份策略与方案)
  - [虚拟机备份](#虚拟机备份)
  - [容器备份](#容器备份)
  - [数据库备份](#数据库备份)
  - [存储级备份](#存储级备份)
  - [灾备架构](#灾备架构)
  - [恢复测试](#恢复测试)
  - [备份监控](#备份监控)
  - [最佳实践](#最佳实践)
  - [相关文档](#相关文档)

---

## 容灾备份概述

```yaml
核心概念:
  RPO (Recovery Point Objective):
    定义: 恢复点目标
    含义: 数据丢失的最大可容忍时间
    示例:
      RPO=0: 实时复制，无数据丢失
      RPO=4小时: 最多丢失4小时数据
      RPO=24小时: 每日备份
    
    业务分类:
      关键业务: RPO <1小时
      重要业务: RPO 4-8小时
      一般业务: RPO 24小时
      归档数据: RPO 7天
  
  RTO (Recovery Time Objective):
    定义: 恢复时间目标
    含义: 系统恢复的最大可容忍时间
    示例:
      RTO=0: 高可用，无停机
      RTO=1小时: 1小时内恢复
      RTO=24小时: 1天内恢复
    
    业务分类:
      关键业务: RTO <1小时
      重要业务: RTO 4-8小时
      一般业务: RTO 24小时
      归档数据: RTO 7天
  
  备份类型:
    热备份 (Hot Backup):
      特点: 在线备份，不停机
      适用: 生产数据库
      示例: MySQL热备份
    
    温备份 (Warm Backup):
      特点: 只读模式备份
      适用: 可短暂锁表
    
    冷备份 (Cold Backup):
      特点: 停机备份
      适用: 维护窗口
      示例: 文件系统拷贝

备份方案对比:
  全量备份 (Full Backup):
    描述: 备份所有数据
    优点:
      ✅ 恢复速度快
      ✅ 恢复简单
    缺点:
      ❌ 备份时间长
      ❌ 存储空间大
      ❌ 网络带宽消耗大
    
    适用:
      - 首次备份
      - 周期性基准备份
      - 小数据量环境
    
    频率: 每周/每月
  
  增量备份 (Incremental Backup):
    描述: 备份自上次备份后的变化
    优点:
      ✅ 备份速度快
      ✅ 存储空间小
      ✅ 网络消耗低
    缺点:
      ❌ 恢复速度慢 (需要完整链)
      ❌ 恢复复杂
    
    适用:
      - 频繁备份
      - 大数据量环境
      - 带宽受限环境
    
    频率: 每天/每小时
  
  差异备份 (Differential Backup):
    描述: 备份自上次全量备份后的变化
    优点:
      ✅ 恢复较快 (全量+差异)
      ✅ 折中方案
    缺点:
      ⚠️ 备份量逐渐增大
    
    适用:
      - 折中需求
      - 中等数据量
    
    频率: 每天
  
  持续数据保护 (CDP):
    描述: 实时数据复制
    优点:
      ✅ RPO接近0
      ✅ 任意时间点恢复
    缺点:
      ❌ 成本高
      ❌ 复杂度高
    
    适用:
      - 关键业务
      - 金融交易
      - 医疗系统

备份策略:
  3-2-1规则:
    3: 保留3份数据副本
    2: 使用2种不同存储介质
    1: 1份异地存储
    
    示例:
      - 生产数据 (1份)
      - 本地备份磁盘 (第2份)
      - 异地备份磁盘 (第3份, 不同介质)
  
  GFS策略 (Grandfather-Father-Son):
    每日备份 (Son): 保留7天
    每周备份 (Father): 保留4周
    每月备份 (Grandfather): 保留12个月
    
    优点:
      ✅ 平衡存储空间
      ✅ 长期数据保留
      ✅ 灵活恢复选项
  
  Tower of Hanoi策略:
    复杂的轮转策略
    适用: 磁带备份
```

---

## 备份策略与方案

```bash
#!/bin/bash
# 企业级备份策略实现脚本

set -e

BACKUP_ROOT="/backup"
DATE=$(date +%Y%m%d_%H%M%S)
DAY_OF_WEEK=$(date +%u)  # 1-7 (Monday-Sunday)
DAY_OF_MONTH=$(date +%d)
LOG_FILE="/var/log/backup_${DATE}.log"

# 日志函数
log() {
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] $1" | tee -a "$LOG_FILE"
}

# 备份保留策略
DAILY_RETENTION=7      # 保留7天日备份
WEEKLY_RETENTION=4     # 保留4周周备份
MONTHLY_RETENTION=12   # 保留12个月月备份

log "========================================="
log "  备份任务开始"
log "========================================="

# 1. 确定备份类型
if [ "$DAY_OF_MONTH" -eq 1 ]; then
    BACKUP_TYPE="monthly"
    BACKUP_DIR="$BACKUP_ROOT/monthly/$DATE"
    log "执行：月度全量备份"
elif [ "$DAY_OF_WEEK" -eq 7 ]; then
    BACKUP_TYPE="weekly"
    BACKUP_DIR="$BACKUP_ROOT/weekly/$DATE"
    log "执行：周度全量备份"
else
    BACKUP_TYPE="daily"
    BACKUP_DIR="$BACKUP_ROOT/daily/$DATE"
    log "执行：日度增量备份"
fi

mkdir -p "$BACKUP_DIR"

# 2. 数据库备份
log "--- 数据库备份 ---"

# MySQL备份
if command -v mysqldump &> /dev/null; then
    log "备份MySQL数据库..."
    MYSQL_BACKUP_DIR="$BACKUP_DIR/mysql"
    mkdir -p "$MYSQL_BACKUP_DIR"
    
    # 获取所有数据库
    DATABASES=$(mysql -e "SHOW DATABASES;" | grep -Ev "^(Database|information_schema|performance_schema|mysql|sys)$")
    
    for DB in $DATABASES; do
        log "  备份数据库: $DB"
        mysqldump --single-transaction --routines --triggers --events \
            --add-drop-database --databases "$DB" \
            | gzip > "$MYSQL_BACKUP_DIR/${DB}.sql.gz"
    done
fi

# PostgreSQL备份
if command -v pg_dumpall &> /dev/null; then
    log "备份PostgreSQL数据库..."
    PGSQL_BACKUP_DIR="$BACKUP_DIR/postgresql"
    mkdir -p "$PGSQL_BACKUP_DIR"
    
    sudo -u postgres pg_dumpall | gzip > "$PGSQL_BACKUP_DIR/all_databases.sql.gz"
fi

# MongoDB备份
if command -v mongodump &> /dev/null; then
    log "备份MongoDB数据库..."
    MONGO_BACKUP_DIR="$BACKUP_DIR/mongodb"
    mkdir -p "$MONGO_BACKUP_DIR"
    
    mongodump --out "$MONGO_BACKUP_DIR" --gzip
fi

# 3. 配置文件备份
log "--- 配置文件备份 ---"
CONFIG_BACKUP_DIR="$BACKUP_DIR/configs"
mkdir -p "$CONFIG_BACKUP_DIR"

CONFIGS=(
    "/etc"
    "/root/.ssh"
    "/home/*/.ssh"
    "/var/www/html/config"
)

for CONFIG in "${CONFIGS[@]}"; do
    if [ -e "$CONFIG" ]; then
        log "  备份: $CONFIG"
        tar czf "$CONFIG_BACKUP_DIR/$(basename $CONFIG)_${DATE}.tar.gz" "$CONFIG" 2>/dev/null || true
    fi
done

# 4. 虚拟机备份 (如果有)
if command -v virsh &> /dev/null; then
    log "--- 虚拟机备份 ---"
    VM_BACKUP_DIR="$BACKUP_DIR/vms"
    mkdir -p "$VM_BACKUP_DIR"
    
    # 获取运行中的虚拟机
    VMS=$(virsh list --name)
    
    for VM in $VMS; do
        if [ -n "$VM" ]; then
            log "  备份虚拟机: $VM"
            virsh dumpxml "$VM" > "$VM_BACKUP_DIR/${VM}.xml"
            
            # 创建快照（如果是全量备份）
            if [ "$BACKUP_TYPE" != "daily" ]; then
                virsh snapshot-create-as "$VM" "${VM}_backup_${DATE}" \
                    "Backup snapshot created on ${DATE}"
            fi
        fi
    done
fi

# 5. Docker容器备份
if command -v docker &> /dev/null; then
    log "--- Docker容器备份 ---"
    DOCKER_BACKUP_DIR="$BACKUP_DIR/docker"
    mkdir -p "$DOCKER_BACKUP_DIR"
    
    # 备份所有容器配置
    docker ps -a --format '{{.Names}}' | while read CONTAINER; do
        log "  导出容器: $CONTAINER"
        docker inspect "$CONTAINER" > "$DOCKER_BACKUP_DIR/${CONTAINER}_config.json"
    done
    
    # 备份Docker卷
    docker volume ls -q | while read VOLUME; do
        log "  备份卷: $VOLUME"
        docker run --rm -v "$VOLUME:/data" -v "$DOCKER_BACKUP_DIR:/backup" \
            alpine tar czf "/backup/${VOLUME}.tar.gz" -C /data .
    done
fi

# 6. 应用数据备份
log "--- 应用数据备份 ---"
DATA_BACKUP_DIR="$BACKUP_DIR/data"
mkdir -p "$DATA_BACKUP_DIR"

# 根据备份类型选择备份方法
if [ "$BACKUP_TYPE" != "daily" ]; then
    # 全量备份
    log "  执行全量备份..."
    tar czf "$DATA_BACKUP_DIR/app_data_full_${DATE}.tar.gz" /var/www /opt/apps 2>/dev/null || true
else
    # 增量备份
    log "  执行增量备份..."
    LAST_FULL=$(ls -t $BACKUP_ROOT/weekly/*/data/app_data_full_*.tar.gz 2>/dev/null | head -1)
    if [ -n "$LAST_FULL" ]; then
        find /var/www /opt/apps -newer "$LAST_FULL" -type f \
            | tar czf "$DATA_BACKUP_DIR/app_data_incr_${DATE}.tar.gz" -T - 2>/dev/null || true
    fi
fi

# 7. 创建备份清单
log "--- 创建备份清单 ---"
cat > "$BACKUP_DIR/manifest.txt" <<EOF
备份信息
========================================
备份时间: $(date '+%Y-%m-%d %H:%M:%S')
备份类型: $BACKUP_TYPE
主机名称: $(hostname)
操作系统: $(uname -a)
备份路径: $BACKUP_DIR

备份内容:
EOF

du -sh "$BACKUP_DIR"/* >> "$BACKUP_DIR/manifest.txt"

# 8. 校验备份
log "--- 校验备份 ---"
find "$BACKUP_DIR" -type f -name "*.tar.gz" -o -name "*.sql.gz" | while read FILE; do
    if gzip -t "$FILE" 2>/dev/null; then
        log "  校验通过: $(basename $FILE)"
    else
        log "  校验失败: $(basename $FILE)" >&2
    fi
done

# 9. 清理过期备份
log "--- 清理过期备份 ---"

# 清理日备份 (保留7天)
find "$BACKUP_ROOT/daily" -maxdepth 1 -type d -mtime +$DAILY_RETENTION -exec rm -rf {} \; 2>/dev/null || true
log "  清理日备份: 保留 ${DAILY_RETENTION} 天"

# 清理周备份 (保留4周)
find "$BACKUP_ROOT/weekly" -maxdepth 1 -type d -mtime +$((WEEKLY_RETENTION * 7)) -exec rm -rf {} \; 2>/dev/null || true
log "  清理周备份: 保留 ${WEEKLY_RETENTION} 周"

# 清理月备份 (保留12个月)
find "$BACKUP_ROOT/monthly" -maxdepth 1 -type d -mtime +$((MONTHLY_RETENTION * 30)) -exec rm -rf {} \; 2>/dev/null || true
log "  清理月备份: 保留 ${MONTHLY_RETENTION} 月"

# 10. 异地传输 (可选)
if [ -n "$REMOTE_BACKUP_HOST" ]; then
    log "--- 异地传输 ---"
    log "传输到远程主机: $REMOTE_BACKUP_HOST"
    
    rsync -avz --progress "$BACKUP_DIR" \
        "$REMOTE_BACKUP_HOST:/backup/offsite/" || log "警告: 异地传输失败"
fi

# 11. 备份统计
log "========================================="
log "  备份任务完成"
log "========================================="
log "备份位置: $BACKUP_DIR"
log "备份大小: $(du -sh $BACKUP_DIR | awk '{print $1}')"
log "磁盘使用: $(df -h $BACKUP_ROOT | tail -1 | awk '{print $5}')"
log "日志文件: $LOG_FILE"

# 12. 发送通知 (可选)
# sendmail -t <<EOF
# To: admin@example.com
# Subject: 备份任务完成 - $(hostname) - $DATE
# 
# 备份任务已完成
# 类型: $BACKUP_TYPE
# 大小: $(du -sh $BACKUP_DIR | awk '{print $1}')
# 状态: 成功
# EOF

exit 0
```

**定时任务配置**:

```bash
# /etc/cron.d/backup
# 每天凌晨2点执行备份
0 2 * * * root /usr/local/bin/backup.sh >> /var/log/backup_cron.log 2>&1
```

---

## 虚拟机备份

```yaml
VMware vSphere备份:
  方法1: vSphere Data Protection (VDP)
    简介: VMware官方备份方案
    功能:
      ✅ 映像级备份
      ✅ 重复数据删除
      ✅ 增量备份
      ✅ 文件级恢复
    
    配置步骤:
      1. 部署VDP虚拟设备
      2. 配置备份目标
      3. 创建备份任务
      4. 设置保留策略
  
  方法2: Veeam Backup & Replication
    简介: 业界领先备份方案
    版本: Community Edition (免费) / Standard / Enterprise
    
    功能:
      ✅ 增量备份 (CBT)
      ✅ 即时VM恢复
      ✅ 文件级恢复
      ✅ 应用感知备份
      ✅ 备份复制
      ✅ SureBackup验证
    
    配置示例:
      1. 安装Veeam服务器
      2. 添加vCenter
      3. 创建备份任务
         名称: Daily_VM_Backup
         对象: 生产VM
         目标: 备份仓库
         计划: 每天22:00
         保留: 14个还原点
      4. 启用应用感知处理 (数据库)
  
  方法3: VMware快照
    注意: ⚠️ 快照不是备份
    
    用途:
      - 临时保护点
      - 升级前创建
      - 短期保留 (<72小时)
    
    命令:
      # 创建快照
      vim-cmd vmsvc/snapshot.create <vmid> "Snapshot Name" "Description" 0 0
      
      # 恢复快照
      vim-cmd vmsvc/snapshot.revert <vmid> <snapshot-id> 0
      
      # 删除快照
      vim-cmd vmsvc/snapshot.remove <vmid> <snapshot-id>
    
    最佳实践:
      ✅ 快照保留时间 <72小时
      ✅ 定期清理
      ✅ 监控快照大小
      ❌ 不要创建快照链
      ❌ 不要依赖快照作为长期备份
  
  方法4: PowerCLI备份脚本
```

```powershell
# PowerCLI - 自动化VM备份脚本

# 连接vCenter
Connect-VIServer -Server vcenter.example.com -User administrator@vsphere.local -Password 'P@ssw0rd'

# 配置
$BackupPath = "\\backup-server\vmware"
$VMs = Get-VM | Where-Object {$_.PowerState -eq "PoweredOn" -and $_.Name -like "prod-*"}

foreach ($VM in $VMs) {
    Write-Host "备份虚拟机: $($VM.Name)"
    
    # 创建快照
    $Snapshot = New-Snapshot -VM $VM -Name "Backup_$(Get-Date -Format 'yyyyMMdd_HHmmss')" `
        -Description "Automated backup snapshot"
    
    # 导出OVF
    $ExportPath = Join-Path $BackupPath "$($VM.Name)_$(Get-Date -Format 'yyyyMMdd')"
    Export-VApp -VM $VM -Destination $ExportPath -Format Ovf
    
    # 删除快照
    Remove-Snapshot -Snapshot $Snapshot -Confirm:$false
    
    Write-Host "完成: $($VM.Name)"
}

Disconnect-VIServer -Confirm:$false
```

```yaml
KVM虚拟机备份:
  方法1: virt-backup (脚本)
```

```bash
#!/bin/bash
# KVM虚拟机备份脚本

BACKUP_DIR="/backup/kvm"
DATE=$(date +%Y%m%d_%H%M%S)

# 获取所有运行的虚拟机
VMS=$(virsh list --name)

for VM in $VMS; do
    if [ -z "$VM" ]; then
        continue
    fi
    
    echo "备份虚拟机: $VM"
    VM_BACKUP_DIR="$BACKUP_DIR/$VM/$DATE"
    mkdir -p "$VM_BACKUP_DIR"
    
    # 1. 导出XML配置
    virsh dumpxml "$VM" > "$VM_BACKUP_DIR/${VM}.xml"
    
    # 2. 创建快照
    SNAPSHOT_NAME="${VM}_backup_${DATE}"
    virsh snapshot-create-as "$VM" "$SNAPSHOT_NAME" \
        "Backup snapshot" --disk-only --atomic
    
    # 3. 备份磁盘镜像
    DISKS=$(virsh domblklist "$VM" --details | grep disk | awk '{print $4}')
    for DISK in $DISKS; do
        DISK_NAME=$(basename "$DISK")
        echo "  备份磁盘: $DISK_NAME"
        cp "$DISK" "$VM_BACKUP_DIR/$DISK_NAME"
    done
    
    # 4. 合并快照
    SNAPSHOTS=$(virsh snapshot-list "$VM" --name)
    for SNAPSHOT in $SNAPSHOTS; do
        virsh blockcommit "$VM" vda --active --pivot
    done
    
    # 5. 删除快照
    virsh snapshot-delete "$VM" "$SNAPSHOT_NAME" --metadata
    
    # 6. 压缩备份
    cd "$BACKUP_DIR/$VM"
    tar czf "${VM}_${DATE}.tar.gz" "$DATE"
    rm -rf "$DATE"
    
    echo "完成: $VM"
done

# 清理7天前的备份
find "$BACKUP_DIR" -type f -name "*.tar.gz" -mtime +7 -delete

echo "所有虚拟机备份完成"
```

```yaml
  方法2: virtnbdbackup (增量备份)
    特点: 支持增量备份
    要求: libvirt 6.0+, qemu 4.2+
    
    安装:
      pip3 install virtnbdbackup
    
    使用:
      # 全量备份
      virtnbdbackup -d vm-name -l full -o /backup/vm-name
      
      # 增量备份
      virtnbdbackup -d vm-name -l inc -o /backup/vm-name
      
      # 恢复
      virtnbdrestore -i /backup/vm-name -o /var/lib/libvirt/images/vm-name.qcow2
```

---

## 容器备份

```yaml
Docker容器备份:
  容器导出:
    导出容器为镜像:
      docker commit <container-id> my-backup:latest
      docker save -o my-backup.tar my-backup:latest
    
    恢复:
      docker load -i my-backup.tar
      docker run -d my-backup:latest
  
  卷备份:
```

```bash
#!/bin/bash
# Docker卷备份脚本

BACKUP_DIR="/backup/docker"
DATE=$(date +%Y%m%d_%H%M%S)

mkdir -p "$BACKUP_DIR"

# 备份所有Docker卷
docker volume ls -q | while read VOLUME; do
    echo "备份卷: $VOLUME"
    
    docker run --rm \
        -v "$VOLUME:/data:ro" \
        -v "$BACKUP_DIR:/backup" \
        alpine \
        tar czf "/backup/${VOLUME}_${DATE}.tar.gz" -C /data .
done

# 备份Docker Compose配置
find /opt -name "docker-compose.yml" -exec cp {} "$BACKUP_DIR/" \;

echo "Docker备份完成"
```

```yaml
Kubernetes备份:
  方法1: Velero (推荐)
    简介: Kubernetes备份与迁移工具
    功能:
      ✅ 集群资源备份
      ✅ PV快照
      ✅ 定时备份
      ✅ 跨集群迁移
    
    安装:
```

```bash
# 安装Velero CLI
wget https://github.com/vmware-tanzu/velero/releases/download/v1.11.0/velero-v1.11.0-linux-amd64.tar.gz
tar -xvf velero-v1.11.0-linux-amd64.tar.gz
sudo mv velero-v1.11.0-linux-amd64/velero /usr/local/bin/

# 安装Velero到Kubernetes
velero install \
    --provider aws \
    --plugins velero/velero-plugin-for-aws:v1.7.0 \
    --bucket velero-backups \
    --secret-file ./credentials-velero \
    --backup-location-config region=us-east-1 \
    --snapshot-location-config region=us-east-1
```

```yaml
    使用:
      # 备份整个命名空间
      velero backup create backup-prod --include-namespaces production
      
      # 备份特定资源
      velero backup create backup-mysql --selector app=mysql
      
      # 定时备份
      velero schedule create daily-backup --schedule="0 2 * * *"
      
      # 恢复
      velero restore create --from-backup backup-prod
      
      # 查看备份
      velero backup get
      velero backup describe backup-prod
  
  方法2: etcd备份
    重要性: ⚠️ etcd存储所有K8s状态
```

```bash
#!/bin/bash
# etcd备份脚本

BACKUP_DIR="/backup/etcd"
DATE=$(date +%Y%m%d_%H%M%S)

mkdir -p "$BACKUP_DIR"

# 备份etcd
ETCDCTL_API=3 etcdctl snapshot save "$BACKUP_DIR/etcd-snapshot-${DATE}.db" \
    --endpoints=https://127.0.0.1:2379 \
    --cacert=/etc/kubernetes/pki/etcd/ca.crt \
    --cert=/etc/kubernetes/pki/etcd/server.crt \
    --key=/etc/kubernetes/pki/etcd/server.key

# 验证备份
ETCDCTL_API=3 etcdctl snapshot status "$BACKUP_DIR/etcd-snapshot-${DATE}.db"

# 保留7天
find "$BACKUP_DIR" -name "etcd-snapshot-*.db" -mtime +7 -delete

echo "etcd备份完成: $BACKUP_DIR/etcd-snapshot-${DATE}.db"
```

```yaml
    恢复:
      # 停止kube-apiserver
      mv /etc/kubernetes/manifests/kube-apiserver.yaml /tmp/
      
      # 恢复etcd
      ETCDCTL_API=3 etcdctl snapshot restore etcd-snapshot.db \
          --data-dir=/var/lib/etcd-restored
      
      # 更新etcd数据目录
      mv /var/lib/etcd /var/lib/etcd.bak
      mv /var/lib/etcd-restored /var/lib/etcd
      
      # 启动kube-apiserver
      mv /tmp/kube-apiserver.yaml /etc/kubernetes/manifests/
```

---

## 数据库备份

```yaml
MySQL/MariaDB备份:
  方法1: mysqldump (逻辑备份)
```

```bash
#!/bin/bash
# MySQL逻辑备份脚本

BACKUP_DIR="/backup/mysql"
DATE=$(date +%Y%m%d_%H%M%S)
MYSQL_USER="backup_user"
MYSQL_PASSWORD="backup_password"

mkdir -p "$BACKUP_DIR"

# 备份所有数据库
mysqldump --all-databases \
    --user="$MYSQL_USER" \
    --password="$MYSQL_PASSWORD" \
    --single-transaction \
    --routines \
    --triggers \
    --events \
    --add-drop-database \
    --master-data=2 \
    | gzip > "$BACKUP_DIR/all_databases_${DATE}.sql.gz"

# 单独备份关键数据库
CRITICAL_DBS=("production_db" "user_db" "order_db")

for DB in "${CRITICAL_DBS[@]}"; do
    mysqldump --databases "$DB" \
        --user="$MYSQL_USER" \
        --password="$MYSQL_PASSWORD" \
        --single-transaction \
        --routines \
        --triggers \
        | gzip > "$BACKUP_DIR/${DB}_${DATE}.sql.gz"
done

# 清理15天前的备份
find "$BACKUP_DIR" -name "*.sql.gz" -mtime +15 -delete

echo "MySQL备份完成"
```

```yaml
  方法2: XtraBackup (物理备份)
    优势:
      ✅ 热备份，不锁表
      ✅ 支持增量备份
      ✅ 恢复速度快
```

```bash
#!/bin/bash
# MySQL物理备份脚本 (XtraBackup)

BACKUP_DIR="/backup/xtrabackup"
DATE=$(date +%Y%m%d_%H%M%S)
DAY_OF_WEEK=$(date +%u)

# 周日全量备份，其他增量备份
if [ "$DAY_OF_WEEK" -eq 7 ]; then
    echo "执行全量备份..."
    FULL_BACKUP_DIR="$BACKUP_DIR/full/$DATE"
    
    xtrabackup --backup \
        --user=backup_user \
        --password=backup_password \
        --target-dir="$FULL_BACKUP_DIR"
    
    # 记录全量备份路径
    echo "$FULL_BACKUP_DIR" > "$BACKUP_DIR/last_full_backup.txt"
else
    echo "执行增量备份..."
    LAST_FULL=$(cat "$BACKUP_DIR/last_full_backup.txt")
    INCR_BACKUP_DIR="$BACKUP_DIR/incremental/$DATE"
    
    xtrabackup --backup \
        --user=backup_user \
        --password=backup_password \
        --target-dir="$INCR_BACKUP_DIR" \
        --incremental-basedir="$LAST_FULL"
fi

echo "XtraBackup备份完成"
```

```yaml
    恢复:
      # 准备全量备份
      xtrabackup --prepare --apply-log-only --target-dir=/backup/full/20250119
      
      # 应用增量备份
      xtrabackup --prepare --apply-log-only \
          --target-dir=/backup/full/20250119 \
          --incremental-dir=/backup/incremental/20250120
      
      # 最后准备
      xtrabackup --prepare --target-dir=/backup/full/20250119
      
      # 停止MySQL
      systemctl stop mysql
      
      # 恢复数据
      xtrabackup --copy-back --target-dir=/backup/full/20250119
      chown -R mysql:mysql /var/lib/mysql
      
      # 启动MySQL
      systemctl start mysql

PostgreSQL备份:
  方法1: pg_dump (逻辑备份)
```

```bash
#!/bin/bash
# PostgreSQL逻辑备份脚本

BACKUP_DIR="/backup/postgresql"
DATE=$(date +%Y%m%d_%H%M%S)

mkdir -p "$BACKUP_DIR"

# 备份所有数据库
sudo -u postgres pg_dumpall | gzip > "$BACKUP_DIR/all_databases_${DATE}.sql.gz"

# 单独备份数据库
DATABASES=$(sudo -u postgres psql -t -c "SELECT datname FROM pg_database WHERE datistemplate = false;")

for DB in $DATABASES; do
    if [ "$DB" != "postgres" ]; then
        sudo -u postgres pg_dump "$DB" -F c \
            -f "$BACKUP_DIR/${DB}_${DATE}.dump"
    fi
done

# 清理15天前的备份
find "$BACKUP_DIR" -mtime +15 -delete

echo "PostgreSQL备份完成"
```

```yaml
  方法2: pg_basebackup (物理备份)
```

```bash
# PostgreSQL物理备份
pg_basebackup -h localhost -U replication_user \
    -D /backup/postgresql/base_backup_$(date +%Y%m%d) \
    -F tar -z -P -v
```

```yaml
MongoDB备份:
```

```bash
#!/bin/bash
# MongoDB备份脚本

BACKUP_DIR="/backup/mongodb"
DATE=$(date +%Y%m%d_%H%M%S)

mkdir -p "$BACKUP_DIR"

# mongodump备份
mongodump --host localhost --port 27017 \
    --username backup_user \
    --password backup_password \
    --authenticationDatabase admin \
    --out "$BACKUP_DIR/dump_${DATE}" \
    --gzip

# 压缩备份
cd "$BACKUP_DIR"
tar czf "mongodb_${DATE}.tar.gz" "dump_${DATE}"
rm -rf "dump_${DATE}"

# 清理30天前的备份
find "$BACKUP_DIR" -name "mongodb_*.tar.gz" -mtime +30 -delete

echo "MongoDB备份完成"
```

---

## 存储级备份

```yaml
快照技术:
  LVM快照:
    创建:
      # 创建5GB快照卷
      lvcreate -L 5G -s -n data_snapshot /dev/vg0/data
    
    挂载:
      mount /dev/vg0/data_snapshot /mnt/snapshot
    
    备份:
      tar czf /backup/data_$(date +%Y%m%d).tar.gz /mnt/snapshot
    
    删除:
      umount /mnt/snapshot
      lvremove /dev/vg0/data_snapshot
  
  Btrfs快照:
    创建:
      btrfs subvolume snapshot /data /data/.snapshots/$(date +%Y%m%d)
    
    列表:
      btrfs subvolume list /data
    
    删除:
      btrfs subvolume delete /data/.snapshots/20250119
  
  ZFS快照:
    创建:
      zfs snapshot tank/data@$(date +%Y%m%d)
    
    列表:
      zfs list -t snapshot
    
    回滚:
      zfs rollback tank/data@20250119
    
    克隆:
      zfs clone tank/data@20250119 tank/data_restored
    
    删除:
      zfs destroy tank/data@20250119

存储复制:
  vSAN复制:
    vSphere Replication:
      RPO: 15分钟-24小时
      配置:
        1. 部署vSphere Replication设备
        2. 配对站点
        3. 配置复制
           虚拟机 → 配置复制
           目标: 灾备站点
           RPO: 1小时
           数据存储: DR-Datastore
  
  Ceph RBD镜像:
    配置:
      # 在主站点
      rbd mirror pool enable rbd image
      rbd mirror image enable rbd/image01
      
      # 在灾备站点
      rbd mirror pool peer add rbd <primary-cluster>
    
    监控:
      rbd mirror image status rbd/image01
```

---

## 灾备架构

```yaml
灾备级别:
  同城灾备:
    距离: <100km
    RPO: <30分钟
    RTO: <4小时
    方案:
      - 同步复制
      - Metro Cluster
      - vSAN延伸集群
  
  异地灾备:
    距离: >100km
    RPO: <4小时
    RTO: <24小时
    方案:
      - 异步复制
      - 备份传输
      - 云灾备

灾备模式:
  主备模式 (Active-Passive):
    描述: 主站点运行，备站点待机
    优点:
      ✅ 简单
      ✅ 成本低
    缺点:
      ❌ 资源浪费
      ❌ 切换时间长
    
    适用: 一般业务
  
  双活模式 (Active-Active):
    描述: 两站点同时运行
    优点:
      ✅ 资源利用率高
      ✅ 无缝切换
      ✅ 负载均衡
    缺点:
      ❌ 复杂度高
      ❌ 成本高
      ❌ 数据一致性挑战
    
    适用: 关键业务
    
    技术方案:
      - VMware vSAN延伸集群
      - Oracle RAC
      - MySQL Group Replication
      - PostgreSQL逻辑复制

VMware vSAN延伸集群:
  架构:
    站点A: 3+ ESXi主机
    站点B: 3+ ESXi主机
    见证站点: 见证主机
  
  特点:
    ✅ 跨站点数据镜像
    ✅ 自动故障切换
    ✅ RPO接近0
    ✅ RTO <5分钟
  
  要求:
    网络延迟: <5ms (站点A-B)
    带宽: 10GbE+
    见证: <200ms延迟

数据库异地灾备:
  MySQL主从复制:
```

```bash
# 主库配置
[mysqld]
server-id=1
log-bin=mysql-bin
binlog-format=ROW
gtid-mode=ON
enforce-gtid-consistency=ON

# 从库配置
[mysqld]
server-id=2
relay-log=mysql-relay-bin
gtid-mode=ON
enforce-gtid-consistency=ON
read_only=ON

# 设置复制
CHANGE MASTER TO
    MASTER_HOST='primary-db.example.com',
    MASTER_USER='replication_user',
    MASTER_PASSWORD='replication_password',
    MASTER_AUTO_POSITION=1;

START SLAVE;
SHOW SLAVE STATUS\G
```

```yaml
  PostgreSQL流复制:
    # primary配置 (postgresql.conf)
    wal_level = replica
    max_wal_senders = 10
    wal_keep_segments = 64
    
    # primary配置 (pg_hba.conf)
    host replication repl_user 192.168.1.0/24 md5
    
    # standby配置 (recovery.conf)
    standby_mode = 'on'
    primary_conninfo = 'host=primary-db port=5432 user=repl_user password=xxx'
    trigger_file = '/tmp/trigger_failover'
```

---

## 恢复测试

```yaml
恢复演练重要性:
  为什么必须演练:
    ❌ 备份未测试 = 没有备份
    ❌ 恢复程序未验证 = 无法恢复
    ❌ RTO/RPO未实测 = 指标虚假
  
  演练频率:
    关键系统: 每季度
    重要系统: 每半年
    一般系统: 每年

恢复测试计划:
```

```bash
#!/bin/bash
# 恢复演练脚本

DRILL_DATE=$(date +%Y%m%d_%H%M%S)
REPORT_FILE="/var/log/drill_report_${DRILL_DATE}.txt"

exec > >(tee -a "$REPORT_FILE")
exec 2>&1

echo "========================================="
echo "  灾备恢复演练"
echo "========================================="
echo "演练时间: $(date '+%Y-%m-%d %H:%M:%S')"
echo ""

# 1. 验证备份完整性
echo "=== 1. 备份完整性验证 ==="
START_TIME=$(date +%s)

BACKUP_FILES=$(find /backup -type f -name "*.tar.gz" -o -name "*.sql.gz" -mtime -1)

for FILE in $BACKUP_FILES; do
    echo "检查: $(basename $FILE)"
    if gzip -t "$FILE" 2>/dev/null; then
        echo "  ✓ 完整性正常"
    else
        echo "  ✗ 完整性异常"
    fi
done

END_TIME=$(date +%s)
echo "耗时: $((END_TIME - START_TIME)) 秒"
echo ""

# 2. 恢复数据库到测试环境
echo "=== 2. 数据库恢复测试 ==="
START_TIME=$(date +%s)

LATEST_BACKUP=$(ls -t /backup/mysql/*.sql.gz | head -1)
echo "恢复备份: $LATEST_BACKUP"

# 创建测试数据库
mysql -u root -p'password' -e "CREATE DATABASE IF NOT EXISTS drill_test;"

# 恢复数据
gunzip < "$LATEST_BACKUP" | mysql -u root -p'password' drill_test

# 验证数据
RECORD_COUNT=$(mysql -u root -p'password' -N -e "SELECT COUNT(*) FROM drill_test.users;")
echo "验证记录数: $RECORD_COUNT"

# 清理
mysql -u root -p'password' -e "DROP DATABASE drill_test;"

END_TIME=$(date +%s)
echo "恢复耗时: $((END_TIME - START_TIME)) 秒"
echo "RTO达成: $(if [ $((END_TIME - START_TIME)) -lt 3600 ]; then echo "是"; else echo "否"; fi)"
echo ""

# 3. 恢复虚拟机到测试环境
echo "=== 3. 虚拟机恢复测试 ==="
START_TIME=$(date +%s)

# 选择最新备份
LATEST_VM_BACKUP=$(ls -t /backup/kvm/*.tar.gz | head -1)
echo "恢复虚拟机: $LATEST_VM_BACKUP"

# 解压到临时目录
TEMP_DIR="/tmp/vm_drill_$$"
mkdir -p "$TEMP_DIR"
tar xzf "$LATEST_VM_BACKUP" -C "$TEMP_DIR"

# 导入虚拟机配置
VM_XML=$(find "$TEMP_DIR" -name "*.xml" | head -1)
if [ -n "$VM_XML" ]; then
    # 修改VM名称为测试版本
    sed -i 's/<name>.*<\/name>/<name>drill-test-vm<\/name>/' "$VM_XML"
    virsh define "$VM_XML"
    echo "  ✓ 虚拟机已导入"
else
    echo "  ✗ 未找到虚拟机配置"
fi

# 清理
rm -rf "$TEMP_DIR"
virsh undefine drill-test-vm

END_TIME=$(date +%s)
echo "恢复耗时: $((END_TIME - START_TIME)) 秒"
echo ""

# 4. 应用配置恢复测试
echo "=== 4. 配置文件恢复测试 ==="
START_TIME=$(date +%s)

LATEST_CONFIG=$(ls -t /backup/configs/*.tar.gz | head -1)
echo "恢复配置: $LATEST_CONFIG"

TEMP_DIR="/tmp/config_drill_$$"
mkdir -p "$TEMP_DIR"
tar xzf "$LATEST_CONFIG" -C "$TEMP_DIR"

# 验证关键配置文件
CRITICAL_CONFIGS=(
    "sshd_config"
    "nginx.conf"
    "my.cnf"
)

for CONFIG in "${CRITICAL_CONFIGS[@]}"; do
    if find "$TEMP_DIR" -name "$CONFIG" | grep -q .; then
        echo "  ✓ $CONFIG 存在"
    else
        echo "  ✗ $CONFIG 缺失"
    fi
done

rm -rf "$TEMP_DIR"

END_TIME=$(date +%s)
echo "验证耗时: $((END_TIME - START_TIME)) 秒"
echo ""

# 5. 生成演练报告
echo "========================================="
echo "  演练总结"
echo "========================================="
echo "演练完成时间: $(date '+%Y-%m-%d %H:%M:%S')"
echo ""
echo "指标达成情况:"
echo "  - 备份完整性: 通过"
echo "  - 数据库RTO: $(if [ $((END_TIME - START_TIME)) -lt 3600 ]; then echo "达标"; else echo "未达标"; fi)"
echo "  - 虚拟机恢复: 通过"
echo "  - 配置文件: 通过"
echo ""
echo "建议:"
echo "  1. 定期清理过期备份"
echo "  2. 优化备份脚本性能"
echo "  3. 增加自动化测试"
echo ""
echo "详细报告: $REPORT_FILE"
```

---

## 备份监控

```yaml
监控指标:
  备份状态:
    ✓ 备份成功率
    ✓ 备份完成时间
    ✓ 备份大小趋势
    ✓ 备份失败告警
  
  存储容量:
    ✓ 备份仓库使用率
    ✓ 容量增长率
    ✓ 预计剩余天数
  
  恢复指标:
    ✓ 恢复测试成功率
    ✓ 实际RTO/RPO
    ✓ 数据完整性

告警配置:
```

```yaml
# Prometheus告警规则
groups:
  - name: backup_alerts
    rules:
      - alert: BackupFailed
        expr: backup_job_status{status="failed"} > 0
        for: 5m
        annotations:
          summary: "备份任务失败"
          description: "{{ $labels.job }} 备份失败"
      
      - alert: BackupStorageFull
        expr: (backup_storage_used / backup_storage_total) > 0.85
        for: 10m
        annotations:
          summary: "备份存储空间不足"
          description: "备份存储使用率 {{ $value }}%"
      
      - alert: BackupNotRunning
        expr: time() - backup_last_success_time > 86400
        for: 1h
        annotations:
          summary: "备份任务超过24小时未运行"
          description: "{{ $labels.job }} 最后成功时间 {{ $value }} 秒前"
```

---

## 最佳实践

```yaml
备份策略最佳实践:
  1. 3-2-1规则:
     ✓ 保留3份数据副本
     ✓ 使用2种不同存储介质
     ✓ 1份异地存储
  
  2. 自动化:
     ✓ 定时自动备份
     ✓ 自动验证
     ✓ 自动清理
     ✓ 自动告警
  
  3. 测试验证:
     ✓ 定期恢复演练
     ✓ 验证数据完整性
     ✓ 测量实际RTO/RPO
  
  4. 安全保护:
     ✓ 备份加密
     ✓ 访问控制
     ✓ 离线备份
     ✓ 防勒索病毒
  
  5. 文档记录:
     ✓ 备份流程文档
     ✓ 恢复步骤文档
     ✓ 应急联系方式
     ✓ 演练记录

容灾架构最佳实践:
  1. 分层保护:
     L1: 存储RAID (硬件容错)
     L2: 快照 (误操作恢复)
     L3: 备份 (数据丢失恢复)
     L4: 异地容灾 (站点级灾难)
  
  2. 关键数据优先:
     数据库 > 配置文件 > 应用数据 > 日志
  
  3. 合理的保留期:
     日志: 7-30天
     数据库: 30-90天
     配置: 365天
     归档: 永久
  
  4. 定期审查:
     季度: 审查备份策略
     半年: 容灾演练
     年度: 全面评估

常见错误:
  ❌ 只备份不测试恢复
  ❌ 备份和生产在同一存储
  ❌ 没有异地备份
  ❌ 过期备份不清理
  ❌ 备份窗口过长影响业务
  ❌ 没有监控告警
  ❌ 恢复流程不清晰
  ❌ 备份介质单一

成本优化:
  1. 分级存储:
     热数据: 高性能存储 (SSD)
     温数据: 标准存储 (HDD)
     冷数据: 对象存储 (S3)
     归档: 磁带/冰川存储
  
  2. 重复数据删除:
     Veeam: 内置去重
     备份一体机: 硬件去重
     云备份: 服务端去重
  
  3. 压缩:
     gzip: 通用压缩
     lz4: 快速压缩
     zstd: 高压缩比
  
  4. 增量备份:
     减少存储空间
     减少备份时间
     减少网络带宽
```

---

## 相关文档

- [存储类型与选型标准](01_存储类型与选型标准.md)
- [iSCSI配置与优化](02_iSCSI配置与优化.md)
- [NFS配置与优化](03_NFS配置与优化.md)
- [VMware vSAN配置](04_VMware_vSAN配置.md)
- [Ceph分布式存储](05_Ceph分布式存储.md)
- [存储性能优化](06_存储性能优化.md)

---

**更新时间**: 2025-10-19  
**文档版本**: v3.0  
**状态**: ✅ 生产就绪
