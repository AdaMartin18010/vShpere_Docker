# vSphere自动化基础

## 自动化概述

### 自动化价值

- **效率提升**: 减少重复性工作，提升运维效率
- **错误减少**: 标准化操作，降低人为错误
- **成本降低**: 减少人力成本，优化资源利用
- **可扩展性**: 支持大规模环境管理

### 自动化层次

```text
┌─────────────────────────────────────────────────────────────┐
│                   自动化层次结构                          │
│                                                             │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐         │
│  │   应用层    │  │   服务层    │  │   基础层    │         │
│  │   自动化    │  │   自动化    │  │   自动化    │         │
│  └─────────────┘  └─────────────┘  └─────────────┘         │
│         │                   │                   │          │
│         ▼                   ▼                   ▼          │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐         │
│  │   业务      │  │   运维      │  │   配置      │         │
│  │   流程      │  │   服务      │  │   管理      │         │
│  └─────────────┘  └─────────────┘  └─────────────┘         │
└─────────────────────────────────────────────────────────────┘
```

## 自动化工具链

### PowerCLI基础

```powershell
# 连接vCenter
Connect-VIServer -Server vcenter.company.com

# 基础操作
Get-VMHost | Select Name, Version, ConnectionState
Get-VM | Select Name, PowerState, NumCpu, MemoryGB
Get-Datastore | Select Name, FreeSpaceGB, CapacityGB
```

### 自动化脚本框架

```powershell
# 自动化脚本模板
function Invoke-VMwareAutomation {
    param(
        [string]$Operation,
        [hashtable]$Parameters,
        [string]$LogPath
    )
    
    # 日志记录
    Start-Transcript -Path $LogPath -Append
    
    try {
        # 执行操作
        switch ($Operation) {
            "DeployVM" { Deploy-VirtualMachine @Parameters }
            "ConfigureCluster" { Configure-vSphereCluster @Parameters }
            "BackupVM" { Backup-VirtualMachine @Parameters }
            default { throw "未知操作: $Operation" }
        }
        
        Write-Host "操作成功完成: $Operation" -ForegroundColor Green
    }
    catch {
        Write-Error "操作失败: $($_.Exception.Message)"
        throw
    }
    finally {
        Stop-Transcript
    }
}
```

## 自动化最佳实践

### 错误处理

```powershell
# 错误处理最佳实践
function Safe-VMwareOperation {
    param(
        [scriptblock]$Operation,
        [int]$MaxRetries = 3,
        [int]$RetryDelay = 5
    )
    
    $retryCount = 0
    
    do {
        try {
            & $Operation
            return $true
        }
        catch {
            $retryCount++
            Write-Warning "操作失败，重试 $retryCount/$MaxRetries: $($_.Exception.Message)"
            
            if ($retryCount -lt $MaxRetries) {
                Start-Sleep -Seconds $RetryDelay
            }
            else {
                throw "操作失败，已达到最大重试次数"
            }
        }
    } while ($retryCount -lt $MaxRetries)
}
```

### 配置管理

```powershell
# 配置管理
function Get-AutomationConfig {
    param([string]$ConfigPath)
    
    if (Test-Path $ConfigPath) {
        return Get-Content $ConfigPath | ConvertFrom-Json
    }
    else {
        # 创建默认配置
        $defaultConfig = @{
            vCenter = "vcenter.company.com"
            CredentialPath = "C:\Scripts\credentials.xml"
            LogPath = "C:\Logs\automation.log"
            BackupPath = "\\backup\vsphere\"
        }
        
        $defaultConfig | ConvertTo-Json | Set-Content $ConfigPath
        return $defaultConfig
    }
}
```

## 自动化监控

### 性能监控

```powershell
# 自动化性能监控
function Start-AutomatedMonitoring {
    param(
        [string]$ClusterName,
        [int]$IntervalMinutes = 5
    )
    
    while ($true) {
        $cluster = Get-Cluster -Name $ClusterName
        $hosts = Get-VMHost -Location $cluster
        
        foreach ($host in $hosts) {
            $cpuUsage = Get-Stat -Entity $host -Stat cpu.usage.average -Realtime
            $memUsage = Get-Stat -Entity $host -Stat mem.usage.average -Realtime
            
            if ($cpuUsage.Value -gt 80) {
                Send-Alert -Message "主机 $($host.Name) CPU使用率过高: $($cpuUsage.Value)%"
            }
            
            if ($memUsage.Value -gt 80) {
                Send-Alert -Message "主机 $($host.Name) 内存使用率过高: $($memUsage.Value)%"
            }
        }
        
        Start-Sleep -Seconds ($IntervalMinutes * 60)
    }
}
```

### 健康检查

```powershell
# 自动化健康检查
function Invoke-HealthCheck {
    param([string]$Environment)
    
    $healthReport = @{
        Timestamp = Get-Date
        Environment = $Environment
        Checks = @()
    }
    
    # 检查vCenter连接
    try {
        $vcenter = Get-VCenterServer
        $healthReport.Checks += @{
            Name = "vCenter连接"
            Status = "正常"
            Details = "连接成功"
        }
    }
    catch {
        $healthReport.Checks += @{
            Name = "vCenter连接"
            Status = "异常"
            Details = $_.Exception.Message
        }
    }
    
    # 检查主机状态
    $hosts = Get-VMHost
    foreach ($host in $hosts) {
        $healthReport.Checks += @{
            Name = "主机状态 - $($host.Name)"
            Status = if ($host.ConnectionState -eq "Connected") { "正常" } else { "异常" }
            Details = $host.ConnectionState
        }
    }
    
    return $healthReport
}
```

## 自动化部署

### 虚拟机部署

```powershell
# 自动化虚拟机部署
function Deploy-VirtualMachine {
    param(
        [string]$VMName,
        [string]$TemplateName,
        [string]$DatastoreName,
        [string]$ClusterName,
        [hashtable]$CustomizationSpec
    )
    
    # 获取模板
    $template = Get-Template -Name $TemplateName
    
    # 获取目标位置
    $datastore = Get-Datastore -Name $DatastoreName
    $cluster = Get-Cluster -Name $ClusterName
    
    # 创建虚拟机
    $vm = New-VM -Name $VMName -Template $template -Datastore $datastore -Location $cluster
    
    # 应用自定义规范
    if ($CustomizationSpec) {
        Set-VM -VM $vm -CustomizationSpec $CustomizationSpec
    }
    
    # 启动虚拟机
    Start-VM -VM $vm
    
    return $vm
}
```

### 集群配置

```powershell
# 自动化集群配置
function Configure-vSphereCluster {
    param(
        [string]$ClusterName,
        [hashtable]$ClusterConfig
    )
    
    $cluster = Get-Cluster -Name $ClusterName
    
    # 配置HA
    if ($ClusterConfig.HAEnabled) {
        Set-Cluster -Cluster $cluster -HAEnabled $true
        Set-Cluster -Cluster $cluster -HAAdmissionControlEnabled $ClusterConfig.HAAdmissionControl
    }
    
    # 配置DRS
    if ($ClusterConfig.DRSEnabled) {
        Set-Cluster -Cluster $cluster -DRSEnabled $true
        Set-Cluster -Cluster $cluster -DRSAutomationLevel $ClusterConfig.DRSAutomationLevel
    }
    
    # 配置EVC
    if ($ClusterConfig.EVCMode) {
        Set-Cluster -Cluster $cluster -EVCMode $ClusterConfig.EVCMode
    }
    
    return $cluster
}
```

## 自动化备份

### 虚拟机备份

```powershell
# 自动化虚拟机备份
function Backup-VirtualMachine {
    param(
        [string]$VMName,
        [string]$BackupPath,
        [string]$BackupType = "Full"
    )
    
    $vm = Get-VM -Name $VMName
    
    # 创建快照
    $snapshot = New-Snapshot -VM $vm -Name "Backup_$(Get-Date -Format 'yyyyMMdd_HHmmss')" -Description "自动化备份"
    
    try {
        # 导出虚拟机
        $exportPath = Join-Path $BackupPath "$VMName_$(Get-Date -Format 'yyyyMMdd_HHmmss')"
        Export-VApp -Source $vm -Destination $exportPath
        
        Write-Host "虚拟机 $VMName 备份成功" -ForegroundColor Green
    }
    finally {
        # 删除快照
        Remove-Snapshot -Snapshot $snapshot -Confirm:$false
    }
}
```

### 配置备份

```powershell
# 自动化配置备份
function Backup-vSphereConfig {
    param([string]$BackupPath)
    
    $backupData = @{
        Timestamp = Get-Date
        vCenter = Get-VCenterServer | Select Name, Version
        Clusters = Get-Cluster | Select Name, HAEnabled, DRSEnabled
        Hosts = Get-VMHost | Select Name, Version, ConnectionState
        VMs = Get-VM | Select Name, PowerState, NumCpu, MemoryGB
        Datastores = Get-Datastore | Select Name, FreeSpaceGB, CapacityGB
    }
    
    $backupFile = Join-Path $BackupPath "vSphereConfig_$(Get-Date -Format 'yyyyMMdd_HHmmss').json"
    $backupData | ConvertTo-Json -Depth 3 | Set-Content $backupFile
    
    Write-Host "配置备份完成: $backupFile" -ForegroundColor Green
}
```

## 自动化报告

### 生成报告

```powershell
# 自动化报告生成
function Generate-vSphereReport {
    param(
        [string]$ReportType,
        [string]$OutputPath
    )
    
    switch ($ReportType) {
        "Inventory" {
            $report = Get-VMHost | Select Name, Version, ConnectionState, @{
                Name = "VMs"
                Expression = { (Get-VM -Location $_).Count }
            }
        }
        "Performance" {
            $report = Get-VMHost | Select Name, @{
                Name = "CPU Usage %"
                Expression = { [math]::Round((Get-Stat -Entity $_ -Stat cpu.usage.average -Realtime).Value, 2) }
            }, @{
                Name = "Memory Usage %"
                Expression = { [math]::Round((Get-Stat -Entity $_ -Stat mem.usage.average -Realtime).Value, 2) }
            }
        }
        "Capacity" {
            $report = Get-Datastore | Select Name, @{
                Name = "Used Space GB"
                Expression = { [math]::Round(($_.CapacityGB - $_.FreeSpaceGB), 2) }
            }, @{
                Name = "Free Space GB"
                Expression = { [math]::Round($_.FreeSpaceGB, 2) }
            }, @{
                Name = "Usage %"
                Expression = { [math]::Round((($_.CapacityGB - $_.FreeSpaceGB) / $_.CapacityGB) * 100, 2) }
            }
        }
    }
    
    $reportFile = Join-Path $OutputPath "$ReportType_$(Get-Date -Format 'yyyyMMdd_HHmmss').csv"
    $report | Export-Csv -Path $reportFile -NoTypeInformation
    
    Write-Host "报告生成完成: $reportFile" -ForegroundColor Green
}
```

## 自动化调度

### 任务调度

```powershell
# 自动化任务调度
function Schedule-VMwareTask {
    param(
        [string]$TaskName,
        [scriptblock]$TaskScript,
        [string]$Schedule,
        [string]$Description
    )
    
    $action = New-ScheduledTaskAction -Execute "PowerShell.exe" -Argument "-Command & {$TaskScript}"
    $trigger = New-ScheduledTaskTrigger -Once -At (Get-Date).AddMinutes(1)
    $settings = New-ScheduledTaskSettingsSet -AllowStartIfOnBatteries -DontStopIfGoingOnBatteries
    
    Register-ScheduledTask -TaskName $TaskName -Action $action -Trigger $trigger -Settings $settings -Description $Description
    
    Write-Host "任务已调度: $TaskName" -ForegroundColor Green
}
```

### 工作流编排

```powershell
# 工作流编排
function Invoke-VMwareWorkflow {
    param(
        [string]$WorkflowName,
        [hashtable]$WorkflowSteps
    )
    
    $workflowLog = @{
        Name = $WorkflowName
        StartTime = Get-Date
        Steps = @()
    }
    
    foreach ($step in $WorkflowSteps.GetEnumerator()) {
        $stepLog = @{
            Name = $step.Key
            StartTime = Get-Date
            Status = "Running"
        }
        
        try {
            & $step.Value
            $stepLog.Status = "Success"
        }
        catch {
            $stepLog.Status = "Failed"
            $stepLog.Error = $_.Exception.Message
            throw
        }
        finally {
            $stepLog.EndTime = Get-Date
            $workflowLog.Steps += $stepLog
        }
    }
    
    $workflowLog.EndTime = Get-Date
    return $workflowLog
}
```

## 自动化最佳实践总结

### 设计原则

1. **模块化**: 将复杂任务分解为小模块
2. **可重用**: 设计可重用的函数和脚本
3. **错误处理**: 完善的错误处理和日志记录
4. **配置管理**: 外部化配置，便于维护
5. **测试验证**: 充分的测试和验证

### 实施建议

1. **渐进式实施**: 从简单任务开始，逐步扩展
2. **标准化**: 建立标准化的脚本和流程
3. **文档化**: 完善的文档和注释
4. **版本控制**: 使用版本控制系统管理脚本
5. **持续改进**: 定期评估和优化自动化流程

---

*本指南提供了vSphere自动化的基础框架和最佳实践，可根据实际需求进行扩展和定制。*
