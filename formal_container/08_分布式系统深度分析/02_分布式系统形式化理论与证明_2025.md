# åˆ†å¸ƒå¼ç³»ç»Ÿå½¢å¼åŒ–ç†è®ºä¸è¯æ˜ï¼ˆ2025ç‰ˆï¼‰

> **æ–‡æ¡£å®šä½**: åˆ†å¸ƒå¼ç³»ç»Ÿçš„å½¢å¼åŒ–æ¨¡å‹ã€å®šç†è¯æ˜ä¸ç†è®ºåˆ†æ  
> **å¯¹æ ‡æ°´å¹³**: MIT 6.824, TLA+ Raftè§„çº¦, Jepsenæµ‹è¯•, å­¦æœ¯é¡¶ä¼šï¼ˆOSDI/SOSP/POPLï¼‰  
> **æ›´æ–°æ—¥æœŸ**: 2025å¹´10æœˆ20æ—¥

---

## ğŸ“‹ ç›®å½•

- [åˆ†å¸ƒå¼ç³»ç»Ÿå½¢å¼åŒ–ç†è®ºä¸è¯æ˜ï¼ˆ2025ç‰ˆï¼‰](#åˆ†å¸ƒå¼ç³»ç»Ÿå½¢å¼åŒ–ç†è®ºä¸è¯æ˜2025ç‰ˆ)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [ç¬¬ä¸€éƒ¨åˆ†ï¼šåˆ†å¸ƒå¼ç³»ç»Ÿçš„å½¢å¼åŒ–æ¨¡å‹](#ç¬¬ä¸€éƒ¨åˆ†åˆ†å¸ƒå¼ç³»ç»Ÿçš„å½¢å¼åŒ–æ¨¡å‹)
    - [1.1 åˆ†å¸ƒå¼ç³»ç»Ÿçš„åŸºæœ¬å®šä¹‰](#11-åˆ†å¸ƒå¼ç³»ç»Ÿçš„åŸºæœ¬å®šä¹‰)
    - [1.2 ç³»ç»Ÿæ¨¡å‹åˆ†ç±»](#12-ç³»ç»Ÿæ¨¡å‹åˆ†ç±»)
      - [1.2.1 åŒæ­¥ç³»ç»Ÿ vs å¼‚æ­¥ç³»ç»Ÿ](#121-åŒæ­¥ç³»ç»Ÿ-vs-å¼‚æ­¥ç³»ç»Ÿ)
      - [1.2.2 æ•…éšœæ¨¡å‹](#122-æ•…éšœæ¨¡å‹)
    - [1.3 è¿›ç¨‹é—´é€šä¿¡æ¨¡å‹](#13-è¿›ç¨‹é—´é€šä¿¡æ¨¡å‹)
      - [1.3.1 æ¶ˆæ¯ä¼ é€’è¯­ä¹‰](#131-æ¶ˆæ¯ä¼ é€’è¯­ä¹‰)
    - [1.4 å…¨å±€çŠ¶æ€ä¸ä¸€è‡´åˆ‡åˆ†](#14-å…¨å±€çŠ¶æ€ä¸ä¸€è‡´åˆ‡åˆ†)
      - [1.4.1 å…¨å±€çŠ¶æ€å®šä¹‰](#141-å…¨å±€çŠ¶æ€å®šä¹‰)
      - [1.4.2 Chandy-Lamportå¿«ç…§ç®—æ³•](#142-chandy-lamportå¿«ç…§ç®—æ³•)
  - [ç¬¬äºŒéƒ¨åˆ†ï¼šCAPå®šç†ä¸PACELCå®šç†çš„å½¢å¼åŒ–è¯æ˜](#ç¬¬äºŒéƒ¨åˆ†capå®šç†ä¸pacelcå®šç†çš„å½¢å¼åŒ–è¯æ˜)
    - [2.1 CAPå®šç†](#21-capå®šç†)
    - [2.2 CAPå®šç†çš„å½¢å¼åŒ–å®šä¹‰](#22-capå®šç†çš„å½¢å¼åŒ–å®šä¹‰)
    - [2.3 CAPä¸å¯èƒ½æ€§è¯æ˜](#23-capä¸å¯èƒ½æ€§è¯æ˜)
    - [2.4 PACELCå®šç†](#24-pacelcå®šç†)
  - [ç¬¬ä¸‰éƒ¨åˆ†ï¼šæ—¶é’Ÿã€æ—¶é—´ä¸å› æœå…³ç³»](#ç¬¬ä¸‰éƒ¨åˆ†æ—¶é’Ÿæ—¶é—´ä¸å› æœå…³ç³»)
    - [3.1 ç‰©ç†æ—¶é’Ÿä¸é€»è¾‘æ—¶é’Ÿ](#31-ç‰©ç†æ—¶é’Ÿä¸é€»è¾‘æ—¶é’Ÿ)
      - [3.1.1 æ—¶é’ŸåŒæ­¥é—®é¢˜](#311-æ—¶é’ŸåŒæ­¥é—®é¢˜)
      - [3.1.2 Lamporté€»è¾‘æ—¶é’Ÿ](#312-lamporté€»è¾‘æ—¶é’Ÿ)
    - [3.2 Vector Clock (å‘é‡æ—¶é’Ÿ)](#32-vector-clock-å‘é‡æ—¶é’Ÿ)
    - [3.3 Hybrid Logical Clock (HLC)](#33-hybrid-logical-clock-hlc)
  - [ç¬¬å››éƒ¨åˆ†ï¼šåˆ†å¸ƒå¼å…±è¯†ç®—æ³•çš„æ·±åº¦åˆ†æ](#ç¬¬å››éƒ¨åˆ†åˆ†å¸ƒå¼å…±è¯†ç®—æ³•çš„æ·±åº¦åˆ†æ)
    - [4.1 å…±è¯†é—®é¢˜çš„å½¢å¼åŒ–å®šä¹‰](#41-å…±è¯†é—®é¢˜çš„å½¢å¼åŒ–å®šä¹‰)
    - [4.2 FLPä¸å¯èƒ½æ€§å®šç†](#42-flpä¸å¯èƒ½æ€§å®šç†)
    - [4.3 Raftå…±è¯†ç®—æ³•](#43-raftå…±è¯†ç®—æ³•)
      - [4.3.1 Raftç®—æ³•æ¦‚è¿°](#431-raftç®—æ³•æ¦‚è¿°)
      - [4.3.2 Raftçš„å½¢å¼åŒ–TLA+è§„çº¦](#432-raftçš„å½¢å¼åŒ–tlaè§„çº¦)
      - [4.3.3 Raftæ­£ç¡®æ€§è¯æ˜](#433-raftæ­£ç¡®æ€§è¯æ˜)
    - [4.4 Paxosç®—æ³•](#44-paxosç®—æ³•)
      - [4.4.1 Basic Paxos](#441-basic-paxos)
    - [4.5 PBFT (Practical Byzantine Fault Tolerance)](#45-pbft-practical-byzantine-fault-tolerance)
      - [4.5.1 æ‹œå åº­å®¹é”™é—®é¢˜](#451-æ‹œå åº­å®¹é”™é—®é¢˜)
  - [ç¬¬äº”éƒ¨åˆ†ï¼šåˆ†å¸ƒå¼äº‹åŠ¡çš„å½¢å¼åŒ–è¯­ä¹‰](#ç¬¬äº”éƒ¨åˆ†åˆ†å¸ƒå¼äº‹åŠ¡çš„å½¢å¼åŒ–è¯­ä¹‰)
    - [5.1 ACID vs BASE](#51-acid-vs-base)
    - [5.2 ä¸¤é˜¶æ®µæäº¤ (2PC)](#52-ä¸¤é˜¶æ®µæäº¤-2pc)
    - [5.3 Sagaæ¨¡å¼](#53-sagaæ¨¡å¼)
  - [ç¬¬å…­éƒ¨åˆ†ï¼šä¸€è‡´æ€§æ¨¡å‹çš„å½¢å¼åŒ–å®šä¹‰](#ç¬¬å…­éƒ¨åˆ†ä¸€è‡´æ€§æ¨¡å‹çš„å½¢å¼åŒ–å®šä¹‰)
    - [6.1 ä¸€è‡´æ€§å±‚æ¬¡ç»“æ„](#61-ä¸€è‡´æ€§å±‚æ¬¡ç»“æ„)
    - [6.2 Sequential Consistency](#62-sequential-consistency)
  - [ç¬¬ä¹éƒ¨åˆ†ï¼šCRDTsä¸æœ€ç»ˆä¸€è‡´æ€§](#ç¬¬ä¹éƒ¨åˆ†crdtsä¸æœ€ç»ˆä¸€è‡´æ€§)
    - [9.1 CRDTs (Conflict-free Replicated Data Types)](#91-crdts-conflict-free-replicated-data-types)
    - [9.2 ç»å…¸CRDTç¤ºä¾‹](#92-ç»å…¸crdtç¤ºä¾‹)
      - [9.2.1 G-Counter (Grow-only Counter)](#921-g-counter-grow-only-counter)
      - [9.2.2 PN-Counter (Positive-Negative Counter)](#922-pn-counter-positive-negative-counter)
      - [9.2.3 LWW-Element-Set (Last-Write-Wins Set)](#923-lww-element-set-last-write-wins-set)
    - [9.3 CRDTçš„ç†è®ºåŸºç¡€](#93-crdtçš„ç†è®ºåŸºç¡€)
  - [ç¬¬åéƒ¨åˆ†ï¼š2025å¹´åˆ†å¸ƒå¼ç³»ç»Ÿå‰æ²¿](#ç¬¬åéƒ¨åˆ†2025å¹´åˆ†å¸ƒå¼ç³»ç»Ÿå‰æ²¿)
    - [10.1 ç¡®å®šæ€§åˆ†å¸ƒå¼ç³»ç»Ÿ](#101-ç¡®å®šæ€§åˆ†å¸ƒå¼ç³»ç»Ÿ)
    - [10.2 åˆ†å¸ƒå¼å¿«ç…§ä¸æ—¶é—´æ—…è¡ŒæŸ¥è¯¢](#102-åˆ†å¸ƒå¼å¿«ç…§ä¸æ—¶é—´æ—…è¡ŒæŸ¥è¯¢)
    - [10.3 Jepsenæµ‹è¯•ä¸å½¢å¼åŒ–éªŒè¯çš„ç»“åˆ](#103-jepsenæµ‹è¯•ä¸å½¢å¼åŒ–éªŒè¯çš„ç»“åˆ)
    - [10.4 è¾¹ç¼˜è®¡ç®—ä¸Geo-åˆ†å¸ƒå¼å…±è¯†](#104-è¾¹ç¼˜è®¡ç®—ä¸geo-åˆ†å¸ƒå¼å…±è¯†)
    - [10.5 é‡å­è®¡ç®—å¯¹åˆ†å¸ƒå¼ç³»ç»Ÿçš„å½±å“](#105-é‡å­è®¡ç®—å¯¹åˆ†å¸ƒå¼ç³»ç»Ÿçš„å½±å“)
  - [æ€»ç»“ä¸å‚è€ƒæ–‡çŒ®](#æ€»ç»“ä¸å‚è€ƒæ–‡çŒ®)
    - [æœ¬æ–‡æ¡£è¦†ç›–çš„æ ¸å¿ƒå†…å®¹](#æœ¬æ–‡æ¡£è¦†ç›–çš„æ ¸å¿ƒå†…å®¹)
    - [å‚è€ƒæ–‡çŒ®](#å‚è€ƒæ–‡çŒ®)
      - [ç»å…¸è®ºæ–‡](#ç»å…¸è®ºæ–‡)
      - [åˆ†å¸ƒå¼ç³»ç»Ÿæ•™æ](#åˆ†å¸ƒå¼ç³»ç»Ÿæ•™æ)
      - [å½¢å¼åŒ–éªŒè¯](#å½¢å¼åŒ–éªŒè¯)
      - [2025å¹´æœ€æ–°ç ”ç©¶](#2025å¹´æœ€æ–°ç ”ç©¶)

---

## ç¬¬ä¸€éƒ¨åˆ†ï¼šåˆ†å¸ƒå¼ç³»ç»Ÿçš„å½¢å¼åŒ–æ¨¡å‹

### 1.1 åˆ†å¸ƒå¼ç³»ç»Ÿçš„åŸºæœ¬å®šä¹‰

**å®šä¹‰1.1 (åˆ†å¸ƒå¼ç³»ç»Ÿ)**:

ä¸€ä¸ªåˆ†å¸ƒå¼ç³»ç»Ÿæ˜¯ä¸€ä¸ªå…ƒç»„ \( DS = (P, C, M, \mathcal{R}) \)ï¼Œå…¶ä¸­ï¼š

- \( P = \{p_1, p_2, \ldots, p_n\} \): è¿›ç¨‹é›†åˆ
- \( C \subseteq P \times P \): é€šä¿¡é“¾è·¯ï¼ˆæœ‰å‘å›¾ï¼‰
- \( M \): æ¶ˆæ¯é›†åˆ
- \( \mathcal{R} \): è¿è¡Œè§„åˆ™ï¼ˆè¿›ç¨‹çŠ¶æ€æœº + æ¶ˆæ¯ä¼ é€’è¯­ä¹‰ï¼‰

**Haskellç±»å‹å®šä¹‰**:

```haskell
-- åˆ†å¸ƒå¼ç³»ç»Ÿçš„ç±»å‹å®šä¹‰
module DistributedSystem where

import Data.Map (Map)
import Data.Set (Set)
import qualified Data.Map as Map
import qualified Data.Set as Set

-- è¿›ç¨‹ID
type ProcessID = Int

-- æ¶ˆæ¯ç±»å‹
data Message msg = Message
    { sender    :: ProcessID
    , receiver  :: ProcessID
    , content   :: msg
    , timestamp :: LogicalTime
    } deriving (Show, Eq)

-- é€»è¾‘æ—¶é’Ÿ
type LogicalTime = Int

-- è¿›ç¨‹çŠ¶æ€
data ProcessState state = ProcessState
    { processId   :: ProcessID
    , localState  :: state
    , clock       :: LogicalTime
    , messageLog  :: [Message String]
    } deriving (Show, Eq)

-- åˆ†å¸ƒå¼ç³»ç»ŸçŠ¶æ€
data DistributedSystem state msg = DistributedSystem
    { processes :: Map ProcessID (ProcessState state)
    , channels  :: Set (ProcessID, ProcessID)
    , inFlight  :: [Message msg]
    } deriving (Show, Eq)

-- ç³»ç»Ÿæ‰§è¡Œçš„äº‹ä»¶
data Event state msg
    = Send ProcessID msg ProcessID
    | Receive ProcessID (Message msg)
    | Internal ProcessID state
    deriving (Show, Eq)

-- ç³»ç»Ÿå†å²ï¼ˆæ‰§è¡Œè½¨è¿¹ï¼‰
type History state msg = [Event state msg]
```

### 1.2 ç³»ç»Ÿæ¨¡å‹åˆ†ç±»

#### 1.2.1 åŒæ­¥ç³»ç»Ÿ vs å¼‚æ­¥ç³»ç»Ÿ

**å®šä¹‰1.2 (åŒæ­¥ç³»ç»Ÿ)**:

ç³»ç»Ÿæ˜¯**åŒæ­¥çš„** âŸº å­˜åœ¨å·²çŸ¥çš„ä¸Šç•Œï¼š

1. **æ¶ˆæ¯å»¶è¿Ÿä¸Šç•Œ**: \( \exists \Delta_{\text{msg}} : \forall m \in M, \text{delay}(m) \leq \Delta_{\text{msg}} \)
2. **è¿›ç¨‹æ‰§è¡Œæ­¥éª¤ä¸Šç•Œ**: \( \exists \Delta_{\text{proc}} : \forall p \in P, \text{step-time}(p) \leq \Delta_{\text{proc}} \)
3. **æ—¶é’Ÿæ¼‚ç§»ä¸Šç•Œ**: \( \exists \epsilon : \forall p_i, p_j, |clock_i - clock_j| \leq \epsilon \)

**å®šä¹‰1.3 (å¼‚æ­¥ç³»ç»Ÿ)**:

ç³»ç»Ÿæ˜¯**å¼‚æ­¥çš„** âŸº ä¸å­˜åœ¨ä¸Šè¿°ä»»ä½•æ—¶é—´ä¸Šç•Œ

- æ¶ˆæ¯å¯ä»¥ä»»æ„å»¶è¿Ÿï¼ˆä½†æœ€ç»ˆä¼šåˆ°è¾¾ï¼‰
- è¿›ç¨‹å¯ä»¥ä»»æ„æ…¢ï¼ˆä½†ä¸ä¼šåœæ­¢ï¼‰
- æ—¶é’Ÿæ— æ³•åŒæ­¥

**Coqå½¢å¼åŒ–**:

```coq
(* åŒæ­¥ç³»ç»Ÿçš„å½¢å¼åŒ–å®šä¹‰ *)
Section SynchronousSystem.

Variable P : Type.  (* è¿›ç¨‹ç±»å‹ *)
Variable M : Type.  (* æ¶ˆæ¯ç±»å‹ *)

(* æ¶ˆæ¯å»¶è¿Ÿ *)
Variable message_delay : M -> nat.

(* åŒæ­¥ç³»ç»Ÿçš„æ—¶é—´ç•Œé™ *)
Parameter Delta_msg : nat.
Parameter Delta_proc : nat.

(* åŒæ­¥æ€§è´¨: æ‰€æœ‰æ¶ˆæ¯å»¶è¿Ÿæœ‰ç•Œ *)
Definition synchronous_message_delivery :=
  forall (m : M), message_delay m <= Delta_msg.

(* è¿›ç¨‹æ‰§è¡Œæ—¶é—´æœ‰ç•Œ *)
Variable process_step_time : P -> nat.

Definition synchronous_process_execution :=
  forall (p : P), process_step_time p <= Delta_proc.

(* åŒæ­¥ç³»ç»Ÿå®šä¹‰ *)
Definition synchronous_system :=
  synchronous_message_delivery /\ synchronous_process_execution.

End SynchronousSystem.

(* å¼‚æ­¥ç³»ç»Ÿçš„å½¢å¼åŒ–å®šä¹‰ *)
Section AsynchronousSystem.

(* å¼‚æ­¥ç³»ç»Ÿ: æ— æ—¶é—´ç•Œé™,ä½†ä¿è¯æœ€ç»ˆæ€§ *)
Definition asynchronous_message_delivery :=
  forall (m : M), exists (t : nat), delivered_at m t.

(* FLPä¸å¯èƒ½æ€§: å¼‚æ­¥ç³»ç»Ÿä¸­æ— æ³•ç¡®å®šæ€§åœ°è§£å†³å…±è¯† *)
Theorem FLP_impossibility :
  forall (consensus_algorithm : Type),
    asynchronous_system ->
    at_least_one_faulty_process ->
    ~ (deterministic_consensus consensus_algorithm).
Proof.
  (* è¯æ˜ç•¥,è§ Fischer, Lynch, Paterson (1985) *)
Admitted.

End AsynchronousSystem.
```

#### 1.2.2 æ•…éšœæ¨¡å‹

**å®šä¹‰1.4 (æ•…éšœç±»å‹)**:

| æ•…éšœç±»å‹ | å½¢å¼åŒ–å®šä¹‰ | ç‰¹å¾ | å®ä¾‹ |
|---------|-----------|------|-----|
| **Crash Fault** (å´©æºƒæ•…éšœ) | \( p \) æ°¸ä¹…åœæ­¢æ‰§è¡Œ | åœæ­¢åä¸å†å‘é€/æ¥æ”¶æ¶ˆæ¯ | è¿›ç¨‹å´©æºƒ, èŠ‚ç‚¹å®•æœº |
| **Omission Fault** (é—æ¼æ•…éšœ) | \( p \) å¶å°”ä¸å‘é€/æ¥æ”¶æ¶ˆæ¯ | \( \text{send-omission} \lor \text{receive-omission} \) | ç½‘ç»œä¸¢åŒ… |
| **Timing Fault** (æ—¶åºæ•…éšœ) | \( p \) è¿åæ—¶é—´çº¦æŸ | \( \text{delay}(m) > \Delta_{\text{msg}} \) | è¶…æ—¶, å“åº”å»¶è¿Ÿ |
| **Byzantine Fault** (æ‹œå åº­æ•…éšœ) | \( p \) å¯ä»¥ä»»æ„è¡Œä¸º | å¯å‘é€é”™è¯¯/çŸ›ç›¾æ¶ˆæ¯ | æ¶æ„èŠ‚ç‚¹, è½¯ä»¶Bug |

**Haskellæ•…éšœæ¨¡å‹**:

```haskell
-- æ•…éšœç±»å‹å®šä¹‰
data FaultType
    = CrashFault ProcessID
    | OmissionFault ProcessID MessageID
    | TimingFault ProcessID Duration
    | ByzantineFault ProcessID ArbitraryBehavior
    deriving (Show, Eq)

-- æ•…éšœæ¨¡å‹
data FaultModel = FaultModel
    { maxCrashFaults     :: Int  -- fä¸ªå´©æºƒæ•…éšœ
    , maxByzantineFaults :: Int  -- f_bä¸ªæ‹œå åº­æ•…éšœ
    , networkPartitions  :: Bool -- æ˜¯å¦å…è®¸ç½‘ç»œåˆ†åŒº
    } deriving (Show, Eq)

-- æ‹œå åº­æ•…éšœå®¹å¿æ¡ä»¶
byzantineFaultTolerance :: Int -> Int -> Bool
byzantineFaultTolerance n f_b = n >= 3 * f_b + 1

-- CFT (Crash Fault Tolerance) æ¡ä»¶
crashFaultTolerance :: Int -> Int -> Bool
crashFaultTolerance n f = n >= 2 * f + 1
```

### 1.3 è¿›ç¨‹é—´é€šä¿¡æ¨¡å‹

#### 1.3.1 æ¶ˆæ¯ä¼ é€’è¯­ä¹‰

**å®šä¹‰1.5 (å¯é æ¶ˆæ¯ä¼ é€’)**:

æ»¡è¶³ä»¥ä¸‹æ€§è´¨çš„æ¶ˆæ¯ä¼ é€’ç§°ä¸º**å¯é ä¼ é€’**:

1. **å®Œæ•´æ€§** (Integrity): æ¯æ¡æ¶ˆæ¯æœ€å¤šè¢«æ¥æ”¶ä¸€æ¬¡
   \[
   \forall m \in M, |\{\text{receive-events}(m)\}| \leq 1
   \]

2. **æœ‰æ•ˆæ€§** (Validity): å¦‚æœ \( p_i \) å‘é€ \( m \) ç»™ \( p_j \)ï¼Œä¸”ä¸¤è€…éƒ½ä¸å´©æºƒï¼Œåˆ™ \( p_j \) æœ€ç»ˆæ”¶åˆ° \( m \)
   \[
   \text{send}(p_i, m, p_j) \land \neg\text{crashed}(p_i) \land \neg\text{crashed}(p_j) \Rightarrow \Diamond \text{receive}(p_j, m)
   \]

**å®šä¹‰1.6 (FIFOé¡ºåº)**:

ä» \( p_i \) åˆ° \( p_j \) çš„æ¶ˆæ¯ä¿æŒ**FIFOé¡ºåº** âŸº
\[
\text{send}(p_i, m_1, p_j) \prec \text{send}(p_i, m_2, p_j) \Rightarrow \text{receive}(p_j, m_1) \prec \text{receive}(p_j, m_2)
\]

**å®šä¹‰1.7 (å› æœé¡ºåº)**:

æ¶ˆæ¯æ»¡è¶³**å› æœé¡ºåº** âŸº Lamportçš„happens-beforeå…³ç³»è¢«ä¿æŒï¼š
\[
\text{send}(m_1) \rightarrow \text{send}(m_2) \Rightarrow \text{receive}(m_1) \prec \text{receive}(m_2)
\]

**TLA+å½¢å¼åŒ–**:

```tla
---- MODULE ReliableChannel ----
EXTENDS Naturals, Sequences

CONSTANT Processes, Messages

VARIABLES
    sent,      \* å·²å‘é€çš„æ¶ˆæ¯ (sender -> receiver -> seq of messages)
    received,  \* å·²æ¥æ”¶çš„æ¶ˆæ¯
    inFlight   \* åœ¨é€”ä¸­çš„æ¶ˆæ¯

vars == <<sent, received, inFlight>>

----

\* åˆå§‹çŠ¶æ€
Init ==
    /\ sent = [p \in Processes |-> [q \in Processes |-> << >>]]
    /\ received = [p \in Processes |-> [q \in Processes |-> << >>]]
    /\ inFlight = {}

\* å‘é€æ¶ˆæ¯
Send(p, q, m) ==
    /\ sent' = [sent EXCEPT ![p][q] = Append(@, m)]
    /\ inFlight' = inFlight \cup {[sender |-> p, receiver |-> q, msg |-> m]}
    /\ UNCHANGED received

\* æ¥æ”¶æ¶ˆæ¯
Receive(p, q, m) ==
    /\ [sender |-> p, receiver |-> q, msg |-> m] \in inFlight
    /\ received' = [received EXCEPT ![q][p] = Append(@, m)]
    /\ inFlight' = inFlight \ {[sender |-> p, receiver |-> q, msg |-> m]}
    /\ UNCHANGED sent

\* ä¸‹ä¸€çŠ¶æ€
Next ==
    \/ \E p, q \in Processes, m \in Messages : Send(p, q, m)
    \/ \E p, q \in Processes, m \in Messages : Receive(p, q, m)

\* è§„çº¦
Spec == Init /\ [][Next]_vars /\ WF_vars(Receive)

----

\* ä¸å˜é‡1: å®Œæ•´æ€§ (æ¯æ¡æ¶ˆæ¯æœ€å¤šæ¥æ”¶ä¸€æ¬¡)
Integrity ==
    \A p, q \in Processes :
        Len(received[q][p]) <= Len(sent[p][q])

\* ä¸å˜é‡2: FIFOé¡ºåºä¿æŒ
FIFOOrdering ==
    \A p, q \in Processes :
        IsPrefix(received[q][p], sent[p][q])

\* æ´»æ€§: æœ‰æ•ˆæ€§ (æ‰€æœ‰å‘é€çš„æ¶ˆæ¯æœ€ç»ˆè¢«æ¥æ”¶)
Validity ==
    \A p, q \in Processes :
        <>[](Len(received[q][p]) = Len(sent[p][q]))

====
```

### 1.4 å…¨å±€çŠ¶æ€ä¸ä¸€è‡´åˆ‡åˆ†

#### 1.4.1 å…¨å±€çŠ¶æ€å®šä¹‰

**å®šä¹‰1.8 (å…¨å±€çŠ¶æ€)**:

åˆ†å¸ƒå¼ç³»ç»Ÿåœ¨æ—¶é—´ \( t \) çš„**å…¨å±€çŠ¶æ€** \( GS(t) \) æ˜¯æ‰€æœ‰è¿›ç¨‹çŠ¶æ€å’Œé€šä¿¡é“¾è·¯çŠ¶æ€çš„ç¬›å¡å°”ç§¯ï¼š

\[
GS(t) = \prod_{p_i \in P} LS_i(t) \times \prod_{(p_i,p_j) \in C} CL_{ij}(t)
\]

å…¶ä¸­ï¼š

- \( LS_i(t) \): è¿›ç¨‹ \( p_i \) åœ¨æ—¶é—´ \( t \) çš„æœ¬åœ°çŠ¶æ€
- \( CL_{ij}(t) \): ä» \( p_i \) åˆ° \( p_j \) çš„é€šä¿¡é“¾è·¯çŠ¶æ€ï¼ˆåœ¨é€”æ¶ˆæ¯ï¼‰

**é—®é¢˜**: åœ¨å¼‚æ­¥ç³»ç»Ÿä¸­ï¼Œ**ä¸å­˜åœ¨å…¨å±€æ—¶é’Ÿ**ï¼Œæ— æ³•ç›´æ¥è§‚å¯Ÿå…¨å±€çŠ¶æ€ï¼

#### 1.4.2 Chandy-Lamportå¿«ç…§ç®—æ³•

**ç›®æ ‡**: åœ¨å¼‚æ­¥ç³»ç»Ÿä¸­æ•è·**ä¸€è‡´æ€§å…¨å±€å¿«ç…§** (Consistent Global Snapshot)

**å®šä¹‰1.9 (ä¸€è‡´æ€§åˆ‡åˆ†)**:

ä¸€ä¸ªå…¨å±€å¿«ç…§ \( S \) æ˜¯**ä¸€è‡´çš„** âŸº å®ƒå¯¹åº”äºç³»ç»Ÿçš„ä¸€ä¸ªå¯èƒ½çš„å…¨å±€çŠ¶æ€ï¼Œå³ï¼š

\[
\forall m \in \text{recorded-as-received}(S), \exists e \in S : e = \text{send}(m)
\]

**ç®—æ³•æè¿°** (Chandy-Lamport, 1985):

```python
# Chandy-Lamportå¿«ç…§ç®—æ³• (Pythonä¼ªä»£ç )

def initiate_snapshot(process):
    """
    ç”±è¿›ç¨‹processå‘èµ·å¿«ç…§
    """
    # 1. è®°å½•æœ¬åœ°çŠ¶æ€
    process.snapshot_state = process.local_state.copy()
    
    # 2. è®°å½•æ‰€æœ‰incomingé€šé“ä¸ºç©º
    process.incoming_channels = {}
    
    # 3. å‘æ‰€æœ‰å‡ºè¾¹å‘é€markeræ¶ˆæ¯
    for neighbor in process.outgoing_neighbors:
        process.send(marker, neighbor)
    
    # 4. å¼€å§‹è®°å½•incomingé€šé“çš„æ¶ˆæ¯
    process.recording_channels = True

def on_receive_marker(process, sender):
    """
    è¿›ç¨‹processä»senderæ¥æ”¶åˆ°markeræ¶ˆæ¯
    """
    if not process.has_recorded_snapshot:
        # é¦–æ¬¡æ”¶åˆ°marker: è®°å½•æœ¬åœ°çŠ¶æ€å¹¶ä¼ æ’­marker
        initiate_snapshot(process)
    
    # åœæ­¢è®°å½•æ¥è‡ªsenderçš„é€šé“
    process.stop_recording(sender)
    
    # å¦‚æœæ‰€æœ‰incomingé€šé“éƒ½æ”¶åˆ°marker,å¿«ç…§å®Œæˆ
    if all_markers_received(process):
        process.snapshot_complete()

def on_receive_normal_message(process, message, sender):
    """
    æ”¶åˆ°æ™®é€šæ¶ˆæ¯
    """
    # æ­£å¸¸å¤„ç†æ¶ˆæ¯
    process.handle_message(message)
    
    # å¦‚æœæ­£åœ¨è®°å½•è¯¥é€šé“,åˆ™è®°å½•æ¶ˆæ¯
    if process.is_recording(sender):
        process.record_message(sender, message)
```

**Coqæ­£ç¡®æ€§è¯æ˜**:

```coq
(* Chandy-Lamportå¿«ç…§ç®—æ³•çš„æ­£ç¡®æ€§è¯æ˜ *)
Section ChandyLamport.

Variable Process : Type.
Variable Message : Type.

(* å…¨å±€çŠ¶æ€ *)
Record GlobalState := {
  process_states : Process -> LocalState;
  channel_states : (Process * Process) -> list Message
}.

(* å¿«ç…§ *)
Record Snapshot := {
  recorded_process_states : Process -> LocalState;
  recorded_channel_states : (Process * Process) -> list Message
}.

(* Happens-beforeå…³ç³» *)
Variable happens_before : Event -> Event -> Prop.

(* ä¸€è‡´æ€§å®šä¹‰: å¿«ç…§ä¸­çš„æ‰€æœ‰æ¥æ”¶äº‹ä»¶,å¯¹åº”çš„å‘é€äº‹ä»¶ä¹Ÿåœ¨å¿«ç…§ä¸­ *)
Definition consistent_snapshot (snap : Snapshot) (history : list Event) :=
  forall (e_recv : Event) (m : Message),
    e_recv \in history ->
    is_receive_event e_recv m ->
    in_snapshot snap e_recv ->
    exists (e_send : Event),
      is_send_event e_send m /\
      happens_before e_send e_recv /\
      in_snapshot snap e_send.

(* Chandy-Lamportç®—æ³•äº§ç”Ÿä¸€è‡´æ€§å¿«ç…§ *)
Theorem chandy_lamport_consistency :
  forall (execution : Execution) (snap : Snapshot),
    chandy_lamport_algorithm execution snap ->
    consistent_snapshot snap execution.(history).
Proof.
  intros execution snap H_algo.
  unfold consistent_snapshot.
  intros e_recv m H_in_hist H_recv H_in_snap.
  
  (* 1. e_recvæ˜¯æ¥æ”¶markerä¹‹å‰çš„äº‹ä»¶ *)
  assert (H_before_marker : before_receive_marker e_recv).
  { apply H_algo. assumption. }
  
  (* 2. å¯¹åº”çš„sendäº‹ä»¶e_sendå¿…å®šå‘ç”Ÿåœ¨markerä¹‹å‰ *)
  destruct (message_causality e_recv m) as [e_send [H_send H_hb]].
  
  (* 3. å› æ­¤e_sendä¹Ÿåœ¨å¿«ç…§ä¸­ *)
  exists e_send.
  split. assumption.
  split. assumption.
  apply H_algo.
  apply H_before_marker.
  assumption.
Qed.

End ChandyLamport.
```

**å®šç†1.1 (Chandy-Lamportæ­£ç¡®æ€§)**:

Chandy-Lamportç®—æ³•äº§ç”Ÿçš„å¿«ç…§æ˜¯**ä¸€è‡´çš„**ï¼Œå³ï¼š

1. å¿«ç…§å¯¹åº”äºç³»ç»Ÿçš„æŸä¸ªå¯è¾¾å…¨å±€çŠ¶æ€
2. å¦‚æœç³»ç»Ÿæ»¡è¶³æŸä¸ªå…¨å±€è°“è¯ \( P \)ï¼Œåˆ™å¿«ç…§ä¹Ÿæ»¡è¶³ \( P \)

---

## ç¬¬äºŒéƒ¨åˆ†ï¼šCAPå®šç†ä¸PACELCå®šç†çš„å½¢å¼åŒ–è¯æ˜

### 2.1 CAPå®šç†

**å®šç†2.1 (CAPå®šç†, Brewer 2000, Gilbert & Lynch 2002)**:

åœ¨å¼‚æ­¥ç½‘ç»œæ¨¡å‹ä¸­ï¼Œä»»ä½•åˆ†å¸ƒå¼æ•°æ®å­˜å‚¨ç³»ç»Ÿ**ä¸å¯èƒ½åŒæ—¶**æä¾›ä»¥ä¸‹ä¸‰ä¸ªä¿è¯ï¼š

- **C (Consistency)**: ä¸€è‡´æ€§ - æ‰€æœ‰èŠ‚ç‚¹åŒæ—¶çœ‹åˆ°ç›¸åŒçš„æ•°æ®
- **A (Availability)**: å¯ç”¨æ€§ - æ¯ä¸ªè¯·æ±‚éƒ½èƒ½å¾—åˆ°å“åº”ï¼ˆæˆåŠŸ/å¤±è´¥ï¼‰
- **P (Partition Tolerance)**: åˆ†åŒºå®¹å¿æ€§ - ç³»ç»Ÿåœ¨ç½‘ç»œåˆ†åŒºæ—¶ä»èƒ½ç»§ç»­è¿è¡Œ

**å½¢å¼åŒ–**:

\[
\neg (C \land A \land P)
\]

æ›´ç²¾ç¡®åœ°è¯´ï¼Œåœ¨ç½‘ç»œåˆ†åŒºå‘ç”Ÿæ—¶ï¼Œå¿…é¡»åœ¨Cå’ŒAä¹‹é—´é€‰æ‹©ï¼š

\[
P \Rightarrow \neg(C \land A)
\]

### 2.2 CAPå®šç†çš„å½¢å¼åŒ–å®šä¹‰

**å®šä¹‰2.1 (ä¸€è‡´æ€§ - Linearizability)**:

ç³»ç»Ÿæ»¡è¶³**çº¿æ€§ä¸€è‡´æ€§** âŸº å­˜åœ¨ä¸€ä¸ªå…¨å±€æ“ä½œåºåˆ—ï¼Œä½¿å¾—ï¼š

1. åºåˆ—ä¸æ¯ä¸ªè¿›ç¨‹çš„æœ¬åœ°å†å²ä¸€è‡´
2. åºåˆ—æ»¡è¶³å®æ—¶é¡ºåºï¼šå¦‚æœæ“ä½œ \( op_1 \) åœ¨å®æ—¶ä¸Šæ—©äº \( op_2 \)ï¼Œåˆ™ \( op_1 \) åœ¨åºåˆ—ä¸­æ’åœ¨ \( op_2 \) ä¹‹å‰

**å½¢å¼åŒ–**:

```coq
(* çº¿æ€§ä¸€è‡´æ€§çš„Coqå®šä¹‰ *)
Section Linearizability.

Variable Operation : Type.
Variable Time : Type.

(* æ“ä½œå†å² *)
Record OpHistory := {
  invocation : Time;
  response   : Time;
  operation  : Operation;
  process    : ProcessID
}.

(* å®æ—¶é¡ºåº *)
Definition real_time_order (op1 op2 : OpHistory) :=
  response op1 < invocation op2.

(* çº¿æ€§åŒ–ç‚¹ *)
Variable linearization_point : OpHistory -> Time.

(* çº¿æ€§ä¸€è‡´æ€§: å­˜åœ¨çº¿æ€§åŒ–,ä½¿å¾—çº¿æ€§åŒ–ç‚¹æ»¡è¶³å®æ—¶é¡ºåº *)
Definition linearizable (history : list OpHistory) :=
  forall op1 op2,
    In op1 history ->
    In op2 history ->
    real_time_order op1 op2 ->
    linearization_point op1 < linearization_point op2.

End Linearizability.
```

**å®šä¹‰2.2 (å¯ç”¨æ€§)**:

ç³»ç»Ÿæ»¡è¶³**å¯ç”¨æ€§** âŸº
\[
\forall \text{request } r \text{ to non-failing node}, \exists \text{response within bounded time}
\]

**å®šä¹‰2.3 (åˆ†åŒºå®¹å¿æ€§)**:

ç³»ç»Ÿæ»¡è¶³**åˆ†åŒºå®¹å¿æ€§** âŸº
\[
\text{ç³»ç»Ÿåœ¨ä»»æ„ç½‘ç»œåˆ†åŒºä¸‹ä»èƒ½æ­£ç¡®è¿è¡Œ}
\]

### 2.3 CAPä¸å¯èƒ½æ€§è¯æ˜

**è¯æ˜æ€è·¯** (Gilbert & Lynch, 2002):

è€ƒè™‘ä¸€ä¸ªç®€å•çš„åˆ†å¸ƒå¼é”®å€¼å­˜å‚¨ç³»ç»Ÿï¼Œæœ‰ä¸¤ä¸ªèŠ‚ç‚¹ \( N_1, N_2 \)ï¼Œåˆå§‹å€¼ \( v_0 \)ã€‚

1. **åœºæ™¯è®¾ç½®**: ç½‘ç»œåˆ†åŒºå°† \( N_1 \) å’Œ \( N_2 \) éš”ç¦»
2. **å†™æ“ä½œ**: å®¢æˆ·ç«¯å‘ \( N_1 \) å†™å…¥æ–°å€¼ \( v_1 \)
3. **è¯»æ“ä½œ**: å®¢æˆ·ç«¯å‘ \( N_2 \) è¯»å–å€¼

**çŸ›ç›¾æ¨å¯¼**:

- **å‡è®¾ç³»ç»ŸåŒæ—¶æ»¡è¶³C, A, P**
- ç”±äº **P (åˆ†åŒºå®¹å¿)**ï¼Œåˆ†åŒºå‘ç”Ÿåï¼Œ\( N_1 \) å’Œ \( N_2 \) æ— æ³•é€šä¿¡
- ç”±äº **A (å¯ç”¨æ€§)**ï¼Œ\( N_2 \) å¿…é¡»å“åº”è¯»è¯·æ±‚
- ç”±äº **C (ä¸€è‡´æ€§)**ï¼Œ\( N_2 \) å¿…é¡»è¿”å›æœ€æ–°å€¼ \( v_1 \)
- **ä½†æ˜¯**ï¼Œ\( N_2 \) æ— æ³•çŸ¥é“ \( v_1 \)ï¼ˆç½‘ç»œåˆ†åŒºé˜»æ­¢äº†åŒæ­¥ï¼‰
- **çŸ›ç›¾ï¼** âˆ

**Coqå½¢å¼åŒ–è¯æ˜**:

```coq
(* CAPä¸å¯èƒ½æ€§å®šç†çš„Coqè¯æ˜ *)
Section CAP_Impossibility.

(* ç³»ç»Ÿæ¨¡å‹ *)
Variable Node : Type.
Variable Value : Type.

(* ç³»ç»ŸçŠ¶æ€ *)
Record SystemState := {
  node_values : Node -> Value;
  network_partitioned : Prop
}.

(* ä¸€è‡´æ€§ *)
Definition consistency (s : SystemState) :=
  forall n1 n2 : Node,
    node_values s n1 = node_values s n2.

(* å¯ç”¨æ€§ *)
Definition availability (s : SystemState) :=
  forall n : Node,
    exists v : Value, can_respond n v.

(* åˆ†åŒºå®¹å¿æ€§ *)
Definition partition_tolerance :=
  forall s : SystemState,
    network_partitioned s -> system_continues s.

(* CAPä¸å¯èƒ½æ€§å®šç† *)
Theorem CAP_impossibility :
  ~ exists (system : DistributedSystem),
      (forall s, consistency s) /\
      (forall s, availability s) /\
      partition_tolerance.
Proof.
  intro H_exists.
  destruct H_exists as [sys [H_C [H_A H_P]]].
  
  (* æ„é€ åä¾‹: ä¸¤èŠ‚ç‚¹ç³»ç»Ÿ N1, N2 *)
  pose (N1 := node1).
  pose (N2 := node2).
  
  (* åˆå§‹çŠ¶æ€: ä¸¤èŠ‚ç‚¹éƒ½å­˜å‚¨ v0 *)
  pose (s0 := initial_state v0).
  
  (* å‘ç”Ÿç½‘ç»œåˆ†åŒº *)
  pose (s1 := partition s0 N1 N2).
  assert (H_partitioned : network_partitioned s1).
  { apply partition_creates_partition. }
  
  (* å‘N1å†™å…¥v1 *)
  pose (s2 := write s1 N1 v1).
  assert (H_N1_updated : node_values s2 N1 = v1).
  { apply write_updates_node. }
  
  (* ä»N2è¯»å– *)
  (* ç”±äºå¯ç”¨æ€§,N2å¿…é¡»å“åº” *)
  specialize (H_A s2 N2).
  destruct H_A as [v_read H_can_respond].
  
  (* ç”±äºä¸€è‡´æ€§,N2åº”è¯¥è¿”å›v1 *)
  specialize (H_C s2 N1 N2).
  rewrite H_N1_updated in H_C.
  
  (* ä½†N2æ— æ³•å¾—çŸ¥v1 (åˆ†åŒºé˜»æ­¢äº†é€šä¿¡) *)
  assert (H_N2_unknown : node_values s2 N2 = v0).
  { apply partition_prevents_sync; assumption. }
  
  (* çŸ›ç›¾! *)
  rewrite H_N2_unknown in H_C.
  discriminate H_C.
Qed.

End CAP_Impossibility.
```

### 2.4 PACELCå®šç†

**å®šç†2.2 (PACELCå®šç†, Abadi 2012)**:

CAPå®šç†çš„æ‰©å±•ç‰ˆæœ¬ï¼Œè€ƒè™‘æ­£å¸¸è¿è¡Œæ—¶çš„æƒè¡¡ï¼š

\[
\text{if } \mathbf{P} \text{artition} \Rightarrow \text{choose } \mathbf{A} \text{vailability or } \mathbf{C} \text{onsistency}
\]
\[
\text{else (no partition)} \Rightarrow \text{choose } \mathbf{L} \text{atency or } \mathbf{C} \text{onsistency}
\]

**ç³»ç»Ÿåˆ†ç±»**:

| ç³»ç»Ÿ | åˆ†åŒºæ—¶ | æ­£å¸¸æ—¶ | ç¤ºä¾‹ |
|------|--------|--------|------|
| PA/EL | é€‰æ‹©A | é€‰æ‹©L (ä½å»¶è¿Ÿ) | Cassandra, DynamoDB |
| PA/EC | é€‰æ‹©A | é€‰æ‹©C (å¼ºä¸€è‡´) | - |
| PC/EL | é€‰æ‹©C | é€‰æ‹©L | - |
| PC/EC | é€‰æ‹©C | é€‰æ‹©C | BigTable, HBase, MongoDB |

**Haskellå»ºæ¨¡**:

```haskell
-- PACELCæƒè¡¡å»ºæ¨¡
module PACELC where

data Tradeoff
    = ChooseAvailability  -- åˆ†åŒºæ—¶é€‰æ‹©å¯ç”¨æ€§
    | ChooseConsistency   -- åˆ†åŒºæ—¶é€‰æ‹©ä¸€è‡´æ€§
    deriving (Show, Eq)

data NormalTradeoff
    = ChooseLatency       -- æ­£å¸¸æ—¶é€‰æ‹©ä½å»¶è¿Ÿ
    | ChooseStrongConsistency  -- æ­£å¸¸æ—¶é€‰æ‹©å¼ºä¸€è‡´æ€§
    deriving (Show, Eq)

data PAC ELC = PACELC
    { partitionTradeoff :: Tradeoff
    , normalTradeoff    :: NormalTradeoff
    } deriving (Show, Eq)

-- ç³»ç»Ÿåˆ†ç±»
cassandra :: PACELC
cassandra = PACELC ChooseAvailability ChooseLatency  -- PA/EL

hbase :: PACELC
hbase = PACELC ChooseConsistency ChooseStrongConsistency  -- PC/EC

-- ä¸€è‡´æ€§çº§åˆ« (ä»¥Cassandraä¸ºä¾‹)
data ConsistencyLevel
    = ONE     -- ä¸€ä¸ªå‰¯æœ¬ç¡®è®¤
    | QUORUM  -- å¤šæ•°å‰¯æœ¬ç¡®è®¤
    | ALL     -- æ‰€æœ‰å‰¯æœ¬ç¡®è®¤
    deriving (Show, Eq, Ord)

-- å¯ç”¨æ€§ä¸ä¸€è‡´æ€§çš„æƒè¡¡
tradeoffAnalysis :: ConsistencyLevel -> (Availability, Consistency)
tradeoffAnalysis ONE    = (High, Eventual)
tradeoffAnalysis QUORUM = (Medium, StrongEventual)
tradeoffAnalysis ALL    = (Low, Linearizable)
```

---

## ç¬¬ä¸‰éƒ¨åˆ†ï¼šæ—¶é’Ÿã€æ—¶é—´ä¸å› æœå…³ç³»

### 3.1 ç‰©ç†æ—¶é’Ÿä¸é€»è¾‘æ—¶é’Ÿ

#### 3.1.1 æ—¶é’ŸåŒæ­¥é—®é¢˜

åœ¨åˆ†å¸ƒå¼ç³»ç»Ÿä¸­ï¼Œ**ç‰©ç†æ—¶é’Ÿ**å­˜åœ¨ä»¥ä¸‹é—®é¢˜ï¼š

1. **æ—¶é’Ÿæ¼‚ç§»** (Clock Drift): ä¸åŒèŠ‚ç‚¹çš„ç‰©ç†æ—¶é’Ÿé€Ÿç‡ä¸åŒ
   \[
   \frac{dC_i}{dt} = 1 + \epsilon_i, \quad |\epsilon_i| \leq \rho
   \]
   å…¶ä¸­ \( \rho \) æ˜¯æ—¶é’Ÿæ¼‚ç§»ç‡ï¼ˆå…¸å‹å€¼ï¼š\( 10^{-6} \) åˆ° \( 10^{-5} \)ï¼‰

2. **æ—¶é’Ÿåç§»** (Clock Skew): ä¸åŒèŠ‚ç‚¹çš„æ—¶é’Ÿå€¼ä¸åŒ
   \[
   |C_i(t) - C_j(t)| \leq \delta
   \]

#### 3.1.2 Lamporté€»è¾‘æ—¶é’Ÿ

**å®šä¹‰3.1 (Happens-Beforeå…³ç³», Lamport 1978)**:

äº‹ä»¶ \( a \) happens-before äº‹ä»¶ \( b \)ï¼ˆè®°ä½œ \( a \rightarrow b \)ï¼‰âŸº æ»¡è¶³ä»¥ä¸‹ä¹‹ä¸€ï¼š

1. **åŒè¿›ç¨‹é¡ºåº**: \( a \) å’Œ \( b \) åœ¨åŒä¸€è¿›ç¨‹ï¼Œä¸” \( a \) åœ¨ \( b \) ä¹‹å‰
2. **æ¶ˆæ¯å› æœ**: \( a \) æ˜¯å‘é€äº‹ä»¶ï¼Œ\( b \) æ˜¯å¯¹åº”çš„æ¥æ”¶äº‹ä»¶
3. **ä¼ é€’æ€§**: \( \exists c : a \rightarrow c \land c \rightarrow b \)

**å®šç†3.1 (Lamportæ—¶é’Ÿæ¡ä»¶)**:

é€»è¾‘æ—¶é’Ÿ \( C \) æ»¡è¶³**æ—¶é’Ÿæ¡ä»¶** âŸº
\[
a \rightarrow b \Rightarrow C(a) < C(b)
\]

**Lamportæ—¶é’Ÿç®—æ³•**:

```python
class LamportClock:
    def __init__(self, process_id):
        self.process_id = process_id
        self.clock = 0
    
    def local_event(self):
        """æœ¬åœ°äº‹ä»¶: æ—¶é’Ÿé€’å¢"""
        self.clock += 1
        return self.clock
    
    def send_event(self, message):
        """å‘é€äº‹ä»¶: æ—¶é’Ÿé€’å¢å¹¶é™„åŠ åˆ°æ¶ˆæ¯"""
        self.clock += 1
        message.timestamp = self.clock
        return message
    
    def receive_event(self, message):
        """æ¥æ”¶äº‹ä»¶: æ—¶é’Ÿæ›´æ–°ä¸ºmax(æœ¬åœ°æ—¶é’Ÿ, æ¶ˆæ¯æ—¶é’Ÿ) + 1"""
        self.clock = max(self.clock, message.timestamp) + 1
        return self.clock

# ç¤ºä¾‹æ‰§è¡Œ
p1 = LamportClock("P1")
p2 = LamportClock("P2")

# P1: æœ¬åœ°äº‹ä»¶ -> clock = 1
p1.local_event()

# P1: å‘é€æ¶ˆæ¯m -> clock = 2, m.timestamp = 2
msg = Message()
p1.send_event(msg)

# P2: æ¥æ”¶æ¶ˆæ¯m -> clock = max(0, 2) + 1 = 3
p2.receive_event(msg)

# P2: æœ¬åœ°äº‹ä»¶ -> clock = 4
p2.local_event()
```

**Coqè¯æ˜Lamportæ—¶é’Ÿæ»¡è¶³æ—¶é’Ÿæ¡ä»¶**:

```coq
(* Lamportæ—¶é’Ÿçš„æ­£ç¡®æ€§è¯æ˜ *)
Section LamportClock.

Variable Event : Type.
Variable Process : Type.

(* Happens-beforeå…³ç³» *)
Variable happens_before : Event -> Event -> Prop.
Notation "a â†’ b" := (happens_before a b) (at level 50).

(* Lamportæ—¶é’Ÿ *)
Variable C : Event -> nat.

(* Lamportæ—¶é’Ÿçš„æ›´æ–°è§„åˆ™ *)
Axiom local_event_rule :
  forall (e1 e2 : Event) (p : Process),
    same_process e1 e2 p ->
    local_order e1 e2 ->
    C e2 = C e1 + 1.

Axiom send_receive_rule :
  forall (e_send e_recv : Event) (m : Message),
    send_event e_send m ->
    receive_event e_recv m ->
    C e_recv = max (C e_recv) (timestamp m) + 1 /\
    timestamp m = C e_send.

(* å®šç†: Lamportæ—¶é’Ÿæ»¡è¶³æ—¶é’Ÿæ¡ä»¶ *)
Theorem lamport_clock_condition :
  forall (a b : Event),
    a â†’ b -> C a < C b.
Proof.
  intros a b H_hb.
  induction H_hb as [a b | a b m | a b c].
  
  - (* Case 1: åŒè¿›ç¨‹é¡ºåº *)
    apply local_event_rule.
    assumption.
  
  - (* Case 2: æ¶ˆæ¯å› æœ *)
    destruct (send_receive_rule a b m) as [H_recv H_send].
    + assumption.
    + assumption.
    + rewrite H_recv, H_send.
      apply Nat.lt_le_trans with (C b).
      * apply Nat.lt_succ_diag_r.
      * apply Nat.le_max_r.
  
  - (* Case 3: ä¼ é€’æ€§ *)
    apply Nat.lt_trans with (C c).
    + apply IHhappens_before1.
    + apply IHhappens_before2.
Qed.

(* æ³¨æ„: æ—¶é’Ÿæ¡ä»¶çš„é€†å‘½é¢˜ä¸æˆç«‹ *)
(* C(a) < C(b) ä¸èƒ½æ¨å‡º a â†’ b *)
Example lamport_clock_not_sufficient :
  exists a b : Event,
    C a < C b /\ ~ (a â†’ b).
Proof.
  (* å¹¶å‘äº‹ä»¶: a || b *)
  exists concurrent_event_a, concurrent_event_b.
  split.
  - (* Lamportæ—¶é’Ÿå¯èƒ½ C(a) < C(b) *)
    apply concurrent_clock_order.
  - (* ä½† a ä¸ happens-before b *)
    intro H_hb.
    apply concurrent_events_contradiction with a b.
    + apply concurrent_a_b.
    + assumption.
Qed.

End LamportClock.
```

### 3.2 Vector Clock (å‘é‡æ—¶é’Ÿ)

**é—®é¢˜**: Lamportæ—¶é’Ÿæ— æ³•åˆ¤æ–­å¹¶å‘æ€§

- \( C(a) < C(b) \not\Rightarrow a \rightarrow b \)
- æ— æ³•åŒºåˆ† \( a \rightarrow b \) å’Œ \( a \parallel b \)ï¼ˆå¹¶å‘ï¼‰

**è§£å†³æ–¹æ¡ˆ**: Vector Clock (Fidge 1988, Mattern 1988)

**å®šä¹‰3.2 (å‘é‡æ—¶é’Ÿ)**:

å¯¹äº \( n \) ä¸ªè¿›ç¨‹çš„ç³»ç»Ÿï¼Œå‘é‡æ—¶é’Ÿ \( VC \) æ˜¯ä¸€ä¸ªé•¿åº¦ä¸º \( n \) çš„å‘é‡ï¼š

\[
VC_i = [c_1, c_2, \ldots, c_n]
\]

å…¶ä¸­ \( c_j \) è¡¨ç¤ºè¿›ç¨‹ \( P_i \) æ‰€çŸ¥çš„è¿›ç¨‹ \( P_j \) çš„é€»è¾‘æ—¶é’Ÿã€‚

**å‘é‡æ—¶é’Ÿæ›´æ–°è§„åˆ™**:

1. **æœ¬åœ°äº‹ä»¶**: \( VC_i[i] \gets VC_i[i] + 1 \)
2. **å‘é€äº‹ä»¶**: \( VC_i[i] \gets VC_i[i] + 1 \); æ¶ˆæ¯æºå¸¦ \( VC_i \)
3. **æ¥æ”¶äº‹ä»¶**:
   \[
   VC_i[j] \gets \max(VC_i[j], VC_{\text{msg}}[j]), \quad \forall j
   \]
   \[
   VC_i[i] \gets VC_i[i] + 1
   \]

**å‘é‡æ—¶é’Ÿæ¯”è¾ƒ**:

\[
VC_a < VC_b \iff \forall i, VC_a[i] \leq VC_b[i] \land \exists j, VC_a[j] < VC_b[j]
\]

**å®šç†3.2 (å‘é‡æ—¶é’Ÿå®šç†)**:

\[
a \rightarrow b \iff VC(a) < VC(b)
\]

**Haskellå®ç°**:

```haskell
-- Vector Clockå®ç°
module VectorClock where

import Data.Map (Map)
import qualified Data.Map as Map

type ProcessID = Int
type VectorClock = Map ProcessID Int

-- åˆ›å»ºåˆå§‹å‘é‡æ—¶é’Ÿ
initial :: [ProcessID] -> VectorClock
initial pids = Map.fromList [(pid, 0) | pid <- pids]

-- æœ¬åœ°äº‹ä»¶: è‡ªå·±çš„æ—¶é’Ÿ+1
tick :: ProcessID -> VectorClock -> VectorClock
tick pid vc = Map.adjust (+1) pid vc

-- å‘é€äº‹ä»¶: å…ˆtick,ç„¶åæ¶ˆæ¯æºå¸¦VC
sendEvent :: ProcessID -> VectorClock -> (VectorClock, VectorClock)
sendEvent pid vc =
    let vc' = tick pid vc
    in (vc', vc')  -- (æ›´æ–°åçš„æœ¬åœ°VC, æ¶ˆæ¯æºå¸¦çš„VC)

-- æ¥æ”¶äº‹ä»¶: merge + tick
receiveEvent :: ProcessID -> VectorClock -> VectorClock -> VectorClock
receiveEvent pid local_vc msg_vc =
    let merged = merge local_vc msg_vc
    in tick pid merged

-- åˆå¹¶ä¸¤ä¸ªå‘é‡æ—¶é’Ÿ (å–å„åˆ†é‡æœ€å¤§å€¼)
merge :: VectorClock -> VectorClock -> VectorClock
merge = Map.unionWith max

-- å‘é‡æ—¶é’Ÿæ¯”è¾ƒ
data Ordering' = LessThan | GreaterThan | Concurrent deriving (Show, Eq)

compareVC :: VectorClock -> VectorClock -> Ordering'
compareVC vc1 vc2
    | all_leq && any_lt  = LessThan
    | all_geq && any_gt  = GreaterThan
    | otherwise          = Concurrent
  where
    all_leq = all (\k -> Map.findWithDefault 0 k vc1 <= Map.findWithDefault 0 k vc2) keys
    any_lt  = any (\k -> Map.findWithDefault 0 k vc1 < Map.findWithDefault 0 k vc2) keys
    all_geq = all (\k -> Map.findWithDefault 0 k vc1 >= Map.findWithDefault 0 k vc2) keys
    any_gt  = any (\k -> Map.findWithDefault 0 k vc1 > Map.findWithDefault 0 k vc2) keys
    keys    = Map.keys vc1 ++ Map.keys vc2

-- åˆ¤æ–­happens-beforeå…³ç³»
happensBefore :: VectorClock -> VectorClock -> Bool
happensBefore vc1 vc2 = compareVC vc1 vc2 == LessThan

-- åˆ¤æ–­å¹¶å‘
concurrent :: VectorClock -> VectorClock -> Bool
concurrent vc1 vc2 = compareVC vc1 vc2 == Concurrent

-- ç¤ºä¾‹
example :: IO ()
example = do
    let pids = [1, 2, 3]
    let vc1 = initial pids
    let vc2 = initial pids
    
    -- P1: æœ¬åœ°äº‹ä»¶
    let vc1' = tick 1 vc1  -- [1,0,0]
    
    -- P1: å‘é€æ¶ˆæ¯åˆ°P2
    let (vc1'', msg_vc) = sendEvent 1 vc1'  -- vc1'' = [2,0,0], msg_vc = [2,0,0]
    
    -- P2: æ¥æ”¶æ¶ˆæ¯
    let vc2' = receiveEvent 2 vc2 msg_vc  -- [2,1,0]
    
    -- P3: æœ¬åœ°äº‹ä»¶ (ä¸P1, P2å¹¶å‘)
    let vc3 = tick 3 (initial pids)  -- [0,0,1]
    
    print $ happensBefore vc1'' vc2'  -- True
    print $ concurrent vc1'' vc3      -- True
    print $ concurrent vc2' vc3       -- True
```

### 3.3 Hybrid Logical Clock (HLC)

**é—®é¢˜**: å‘é‡æ—¶é’Ÿçš„ç©ºé—´å¼€é”€ä¸º \( O(n) \)ï¼Œåœ¨å¤§è§„æ¨¡ç³»ç»Ÿä¸­ä¸å¯æ¥å—

**è§£å†³æ–¹æ¡ˆ**: Hybrid Logical Clock (Kulkarni et al. 2014)

**å®šä¹‰3.3 (HLC)**:

HLCç»“åˆç‰©ç†æ—¶é’Ÿå’Œé€»è¾‘æ—¶é’Ÿï¼š

\[
HLC = (pt, l)
\]

å…¶ä¸­ï¼š

- \( pt \): ç‰©ç†æ—¶é—´æˆ³ (Physical Time)
- \( l \): é€»è¾‘è®¡æ•°å™¨ (Logical Counter)

**HLCæ›´æ–°è§„åˆ™**:

```python
class HybridLogicalClock:
    def __init__(self):
        self.pt = 0  # ç‰©ç†æ—¶é’Ÿ
        self.l = 0   # é€»è¾‘è®¡æ•°å™¨
    
    def get_physical_time(self):
        """è·å–å½“å‰ç‰©ç†æ—¶é—´ (ä¾‹å¦‚System.currentTimeMillis())"""
        return int(time.time() * 1000)
    
    def send_or_local_event(self):
        """å‘é€äº‹ä»¶æˆ–æœ¬åœ°äº‹ä»¶"""
        pt_now = self.get_physical_time()
        
        if pt_now > self.pt:
            self.pt = pt_now
            self.l = 0
        else:  # pt_now == self.pt
            self.l += 1
        
        return (self.pt, self.l)
    
    def receive_event(self, msg_pt, msg_l):
        """æ¥æ”¶äº‹ä»¶"""
        pt_now = self.get_physical_time()
        
        if pt_now > self.pt and pt_now > msg_pt:
            self.pt = pt_now
            self.l = 0
        elif msg_pt > self.pt:
            self.pt = msg_pt
            self.l = msg_l + 1
        else:  # self.pt >= max(pt_now, msg_pt)
            self.l = max(self.l, msg_l) + 1
        
        return (self.pt, self.l)

# HLCæ¯”è¾ƒ
def hlc_less_than(hlc1, hlc2):
    """HLC1 < HLC2 iff (pt1 < pt2) or (pt1 == pt2 and l1 < l2)"""
    pt1, l1 = hlc1
    pt2, l2 = hlc2
    return (pt1 < pt2) or (pt1 == pt2 and l1 < l2)
```

**HLCçš„ä¼˜åŠ¿**:

1. **ç©ºé—´å¤æ‚åº¦**: \( O(1) \)ï¼ˆåªéœ€å­˜å‚¨ä¸¤ä¸ªæ•´æ•°ï¼‰
2. **ä¸ç‰©ç†æ—¶é—´æ¥è¿‘**: \( |HLC - PhysicalTime| \) æœ‰ç•Œ
3. **ä¿æŒå› æœå…³ç³»**: \( a \rightarrow b \Rightarrow HLC(a) < HLC(b) \)

**åº”ç”¨**: CockroachDB, YugabyteDBä½¿ç”¨HLCä½œä¸ºåˆ†å¸ƒå¼æ—¶é—´æˆ³

---

## ç¬¬å››éƒ¨åˆ†ï¼šåˆ†å¸ƒå¼å…±è¯†ç®—æ³•çš„æ·±åº¦åˆ†æ

### 4.1 å…±è¯†é—®é¢˜çš„å½¢å¼åŒ–å®šä¹‰

**å®šä¹‰4.1 (å…±è¯†é—®é¢˜)**:

åœ¨åˆ†å¸ƒå¼ç³»ç»Ÿä¸­ï¼Œ\( n \) ä¸ªè¿›ç¨‹éœ€è¦å¯¹æŸä¸ªå€¼è¾¾æˆä¸€è‡´ã€‚æ¯ä¸ªè¿›ç¨‹ \( p_i \) æœ‰åˆå§‹æè®®å€¼ \( v_i \)ï¼Œç®—æ³•éœ€è¦æ»¡è¶³ï¼š

1. **ç»ˆæ­¢æ€§** (Termination): æ¯ä¸ªæ­£ç¡®è¿›ç¨‹æœ€ç»ˆå†³å®šæŸä¸ªå€¼
   \[
   \forall i \in \text{correct-processes}, \Diamond \text{decided}(i)
   \]

2. **åè®®æ€§** (Agreement): æ‰€æœ‰æ­£ç¡®è¿›ç¨‹å†³å®šç›¸åŒçš„å€¼
   \[
   \forall i, j \in \text{correct-processes}, \text{decision}_i = \text{decision}_j
   \]

3. **å®Œæ•´æ€§** (Integrity): å¦‚æœæ‰€æœ‰è¿›ç¨‹æè®®ç›¸åŒçš„å€¼ \( v \)ï¼Œåˆ™å†³å®šå€¼å¿…é¡»æ˜¯ \( v \)
   \[
   (\forall i, v_i = v) \Rightarrow (\text{decision} = v)
   \]

4. **æœ‰æ•ˆæ€§** (Validity): å†³å®šå€¼å¿…é¡»æ˜¯æŸä¸ªè¿›ç¨‹çš„æè®®å€¼
   \[
   \text{decision} \in \{v_1, v_2, \ldots, v_n\}
   \]

### 4.2 FLPä¸å¯èƒ½æ€§å®šç†

**å®šç†4.1 (FLP Impossibility, Fischer-Lynch-Paterson 1985)**:

åœ¨**å¼‚æ­¥ç³»ç»Ÿ**ä¸­ï¼Œå³ä½¿åªæœ‰**ä¸€ä¸ªè¿›ç¨‹å¯èƒ½å´©æºƒ**ï¼Œä¹Ÿ**ä¸å­˜åœ¨ç¡®å®šæ€§å…±è¯†ç®—æ³•**ã€‚

**å½¢å¼åŒ–é™ˆè¿°**:

\[
\text{Asynchronous} \land (\exists \text{faulty process}) \Rightarrow \neg \text{Deterministic Consensus}
\]

**è¯æ˜æ€è·¯**:

1. **äºŒä»·æ€§** (Bivalency): ç³»ç»Ÿé…ç½®å¯ä»¥æ˜¯0-valentï¼ˆåªèƒ½å†³å®š0ï¼‰ã€1-valentï¼ˆåªèƒ½å†³å®š1ï¼‰æˆ–bivalentï¼ˆå¯èƒ½å†³å®š0æˆ–1ï¼‰
2. **å…³é”®å¼•ç†**: ä»åˆå§‹bivalenté…ç½®å‡ºå‘ï¼Œæ€»èƒ½é€šè¿‡æŸä¸ªæ¶ˆæ¯å»¶è¿Ÿä¿æŒbivalent
3. **ç»“è®º**: å¯èƒ½æ°¸è¿œåœç•™åœ¨bivalenté…ç½®ï¼Œæ— æ³•å†³å®š

**å®è·µå¯ç¤º**:

- å¿…é¡»æ”¾æ¾æŸä¸ªå‡è®¾æ‰èƒ½è§£å†³å…±è¯†ï¼š
  - **åŒæ­¥å‡è®¾** â†’ Paxos, Raftåœ¨æœ€ç»ˆåŒæ­¥ç³»ç»Ÿä¸­å·¥ä½œ
  - **éšæœºåŒ–** â†’ Ben-Orç®—æ³•ä½¿ç”¨éšæœºæ€§
  - **å¤±è´¥æ£€æµ‹å™¨** â†’ Chandra-Touegä½¿ç”¨\( \Diamond S \)

### 4.3 Raftå…±è¯†ç®—æ³•

#### 4.3.1 Raftç®—æ³•æ¦‚è¿°

**è®¾è®¡ç›®æ ‡**: å¯ç†è§£æ€§ä¼˜å…ˆçš„å…±è¯†ç®—æ³•ï¼ˆç›¸æ¯”Paxosï¼‰

**æ ¸å¿ƒæœºåˆ¶**:

1. **Leaderé€‰ä¸¾** (Leader Election)
2. **æ—¥å¿—å¤åˆ¶** (Log Replication)
3. **å®‰å…¨æ€§ä¿è¯** (Safety)

**çŠ¶æ€æœºå¤åˆ¶** (State Machine Replication):

\[
\text{Replicated Log} \xrightarrow{\text{Apply}} \text{State Machine}
\]

#### 4.3.2 Raftçš„å½¢å¼åŒ–TLA+è§„çº¦

```tla
---- MODULE Raft ----
EXTENDS Naturals, Sequences, FiniteSets, TLC

CONSTANTS
    Server,           \* æœåŠ¡å™¨é›†åˆ
    Nil,              \* ç©ºå€¼
    MaxTerm,          \* æœ€å¤§ä»»æœŸ
    MaxLogLength      \* æœ€å¤§æ—¥å¿—é•¿åº¦

VARIABLES
    currentTerm,      \* å½“å‰ä»»æœŸ [Server -> Nat]
    state,            \* çŠ¶æ€: Follower/Candidate/Leader
    votedFor,         \* æŠ•ç¥¨ç»™è° [Server -> Server \cup {Nil}]
    log,              \* æ—¥å¿— [Server -> Seq(LogEntry)]
    commitIndex,      \* å·²æäº¤ç´¢å¼• [Server -> Nat]
    
    messages          \* ç½‘ç»œä¸­çš„æ¶ˆæ¯

vars == <<currentTerm, state, votedFor, log, commitIndex, messages>>

----

\* æœåŠ¡å™¨è§’è‰²
ServerRole == {"Follower", "Candidate", "Leader"}

\* æ—¥å¿—æ¡ç›®
LogEntry == [term : Nat, command : STRING]

\* æ¶ˆæ¯ç±»å‹
Message == 
    [type : {"RequestVote"}, term : Nat, candidateId : Server,
     lastLogTerm : Nat, lastLogIndex : Nat]
  \cup
    [type : {"RequestVoteResponse"}, term : Nat, voteGranted : BOOLEAN, 
     from : Server]
  \cup
    [type : {"AppendEntries"}, term : Nat, leaderId : Server,
     prevLogIndex : Nat, prevLogTerm : Nat, entries : Seq(LogEntry),
     leaderCommit : Nat]
  \cup
    [type : {"AppendEntriesResponse"}, term : Nat, success : BOOLEAN, 
     matchIndex : Nat, from : Server]

----

\* åˆå§‹çŠ¶æ€
Init ==
    /\ currentTerm = [s \in Server |-> 0]
    /\ state = [s \in Server |-> "Follower"]
    /\ votedFor = [s \in Server |-> Nil]
    /\ log = [s \in Server |-> << >>]
    /\ commitIndex = [s \in Server |-> 0]
    /\ messages = {}

----

\* Leaderé€‰ä¸¾

\* é€‰ä¸¾è¶…æ—¶: Followerå˜ä¸ºCandidate
BecomeCandidate(s) ==
    /\ state[s] = "Follower"
    /\ state' = [state EXCEPT ![s] = "Candidate"]
    /\ currentTerm' = [currentTerm EXCEPT ![s] = @ + 1]
    /\ votedFor' = [votedFor EXCEPT ![s] = s]
    /\ messages' = messages \cup {
        [type |-> "RequestVote",
         term |-> currentTerm'[s],
         candidateId |-> s,
         lastLogTerm |-> IF Len(log[s]) > 0 THEN log[s][Len(log[s])].term ELSE 0,
         lastLogIndex |-> Len(log[s])]
       }
    /\ UNCHANGED <<log, commitIndex>>

\* æ”¶åˆ°RequestVoteè¯·æ±‚
HandleRequestVote(s, m) ==
    /\ m.type = "RequestVote"
    /\ m.term >= currentTerm[s]
    /\ LET
        logOk == \/ m.lastLogTerm > (IF Len(log[s]) > 0 THEN log[s][Len(log[s])].term ELSE 0)
                 \/ /\ m.lastLogTerm = (IF Len(log[s]) > 0 THEN log[s][Len(log[s])].term ELSE 0)
                    /\ m.lastLogIndex >= Len(log[s])
        grant == /\ m.term = currentTerm[s]
                 /\ logOk
                 /\ votedFor[s] \in {Nil, m.candidateId}
       IN
        /\ currentTerm' = [currentTerm EXCEPT ![s] = m.term]
        /\ votedFor' = [votedFor EXCEPT ![s] = IF grant THEN m.candidateId ELSE @]
        /\ messages' = messages \cup {
            [type |-> "RequestVoteResponse",
             term |-> m.term,
             voteGranted |-> grant,
             from |-> s]
           }
        /\ UNCHANGED <<state, log, commitIndex>>

\* Candidateæ”¶é›†é€‰ç¥¨,æˆä¸ºLeader
BecomeLeader(s) ==
    /\ state[s] = "Candidate"
    /\ LET votesGranted == {m \in messages : 
                            /\ m.type = "RequestVoteResponse"
                            /\ m.term = currentTerm[s]
                            /\ m.voteGranted}
       IN Cardinality(votesGranted) * 2 > Cardinality(Server)
    /\ state' = [state EXCEPT ![s] = "Leader"]
    /\ UNCHANGED <<currentTerm, votedFor, log, commitIndex, messages>>

----

\* æ—¥å¿—å¤åˆ¶

\* Leaderå‘é€AppendEntries (å¿ƒè·³æˆ–æ—¥å¿—å¤åˆ¶)
AppendEntries(leader, follower) ==
    /\ state[leader] = "Leader"
    /\ LET
        prevLogIndex == Len(log[follower])
        prevLogTerm == IF prevLogIndex > 0 THEN log[follower][prevLogIndex].term ELSE 0
        entries == SubSeq(log[leader], prevLogIndex + 1, Len(log[leader]))
       IN
        /\ messages' = messages \cup {
            [type |-> "AppendEntries",
             term |-> currentTerm[leader],
             leaderId |-> leader,
             prevLogIndex |-> prevLogIndex,
             prevLogTerm |-> prevLogTerm,
             entries |-> entries,
             leaderCommit |-> commitIndex[leader]]
           }
        /\ UNCHANGED <<currentTerm, state, votedFor, log, commitIndex>>

\* Followerå¤„ç†AppendEntries
HandleAppendEntries(s, m) ==
    /\ m.type = "AppendEntries"
    /\ m.term >= currentTerm[s]
    /\ LET
        logOk == \/ m.prevLogIndex = 0
                 \/ /\ m.prevLogIndex <= Len(log[s])
                    /\ log[s][m.prevLogIndex].term = m.prevLogTerm
       IN
        /\ currentTerm' = [currentTerm EXCEPT ![s] = m.term]
        /\ state' = [state EXCEPT ![s] = "Follower"]
        /\ IF logOk THEN
            /\ log' = [log EXCEPT ![s] = SubSeq(@, 1, m.prevLogIndex) \o m.entries]
            /\ commitIndex' = [commitIndex EXCEPT ![s] = 
                               Min(m.leaderCommit, Len(log'[s]))]
           ELSE
            /\ UNCHANGED <<log, commitIndex>>
        /\ messages' = messages \cup {
            [type |-> "AppendEntriesResponse",
             term |-> m.term,
             success |-> logOk,
             matchIndex |-> IF logOk THEN m.prevLogIndex + Len(m.entries) ELSE 0,
             from |-> s]
           }
        /\ UNCHANGED votedFor

----

\* ä¸‹ä¸€çŠ¶æ€
Next ==
    \/ \E s \in Server : BecomeCandidate(s)
    \/ \E s \in Server, m \in messages : HandleRequestVote(s, m)
    \/ \E s \in Server : BecomeLeader(s)
    \/ \E leader, follower \in Server : AppendEntries(leader, follower)
    \/ \E s \in Server, m \in messages : HandleAppendEntries(s, m)

\* è§„çº¦
Spec == Init /\ [][Next]_vars

----

\* å®‰å…¨æ€§ä¸å˜é‡

\* é€‰ä¸¾å®‰å…¨æ€§: æ¯ä¸ªä»»æœŸæœ€å¤šä¸€ä¸ªLeader
ElectionSafety ==
    \A s1, s2 \in Server :
        (state[s1] = "Leader" /\ state[s2] = "Leader" /\ currentTerm[s1] = currentTerm[s2])
        => s1 = s2

\* æ—¥å¿—åŒ¹é…æ€§: å¦‚æœä¸¤ä¸ªæ—¥å¿—åœ¨ç›¸åŒç´¢å¼•å¤„æœ‰ç›¸åŒä»»æœŸ,åˆ™ä¹‹å‰çš„æ—¥å¿—éƒ½ç›¸åŒ
LogMatching ==
    \A s1, s2 \in Server, i \in 1..Min(Len(log[s1]), Len(log[s2])) :
        (log[s1][i].term = log[s2][i].term)
        => (\A j \in 1..i : log[s1][j] = log[s2][j])

\* Leaderå®Œæ•´æ€§: å¦‚æœæ—¥å¿—æ¡ç›®åœ¨æŸä¸ªä»»æœŸè¢«æäº¤,åˆ™å®ƒå‡ºç°åœ¨æ›´é«˜ä»»æœŸLeaderçš„æ—¥å¿—ä¸­
LeaderCompleteness ==
    \A s \in Server, i \in 1..Len(log[s]) :
        (i <= commitIndex[s])
        => (\A leader \in Server :
            (state[leader] = "Leader" /\ currentTerm[leader] > log[s][i].term)
            => (\E j \in 1..Len(log[leader]) : log[leader][j] = log[s][i]))

\* çŠ¶æ€æœºå®‰å…¨æ€§: å¦‚æœæœåŠ¡å™¨å°†ç´¢å¼•iåº”ç”¨åˆ°çŠ¶æ€æœº,åˆ™æ²¡æœ‰å…¶ä»–æœåŠ¡å™¨åº”ç”¨ä¸åŒçš„å‘½ä»¤åˆ°ç´¢å¼•i
StateMachineSafety ==
    \A s1, s2 \in Server, i \in 1..Min(commitIndex[s1], commitIndex[s2]) :
        log[s1][i].command = log[s2][i].command

====
```

#### 4.3.3 Raftæ­£ç¡®æ€§è¯æ˜

**å®šç†4.2 (Raftå®‰å…¨æ€§)**:

Raftç®—æ³•æ»¡è¶³ä»¥ä¸‹å®‰å…¨æ€§è´¨ï¼š

1. **é€‰ä¸¾å®‰å…¨æ€§**: æ¯ä¸ªä»»æœŸæœ€å¤šä¸€ä¸ªLeader
2. **æ—¥å¿—åŒ¹é…æ€§**: ç›¸åŒç´¢å¼•å¤„ä»»æœŸç›¸åŒçš„æ—¥å¿—æ¡ç›®ä¹‹å‰çš„æ‰€æœ‰æ—¥å¿—éƒ½ç›¸åŒ
3. **Leaderå®Œæ•´æ€§**: å·²æäº¤çš„æ—¥å¿—æ¡ç›®ä¼šå‡ºç°åœ¨æ‰€æœ‰åç»­Leaderçš„æ—¥å¿—ä¸­
4. **çŠ¶æ€æœºå®‰å…¨æ€§**: ä¸åŒæœåŠ¡å™¨åœ¨ç›¸åŒç´¢å¼•å¤„åº”ç”¨ç›¸åŒçš„æ—¥å¿—æ¡ç›®

**è¯æ˜** (Ongaro & Ousterhout, 2014):

**å¼•ç†1 (é€‰ä¸¾å®‰å…¨æ€§)**:

*è¯æ˜*: é€šè¿‡æŠ•ç¥¨æœºåˆ¶ä¿è¯

- æ¯ä¸ªæœåŠ¡å™¨åœ¨æ¯ä¸ªä»»æœŸæœ€å¤šæŠ•ä¸€ç¥¨
- æˆä¸ºLeaderéœ€è¦å¤šæ•°ç¥¨
- å¤šæ•°é›†åˆå¿…å®šç›¸äº¤
âˆ´ æ¯ä¸ªä»»æœŸæœ€å¤šä¸€ä¸ªLeader âˆ

**å¼•ç†2 (Leaderå®Œæ•´æ€§)**:

*è¯æ˜*: é€šè¿‡å½’çº³æ³•

- **Base case**: Term 1çš„LeaderåŒ…å«æ‰€æœ‰Term 1çš„å·²æäº¤æ¡ç›®ï¼ˆæ˜¾ç„¶ï¼‰
- **Inductive step**: å‡è®¾å¯¹Term \( t \) æˆç«‹ï¼Œè¯æ˜å¯¹Term \( t+1 \) ä¹Ÿæˆç«‹
  - Term \( t+1 \) çš„Leaderå¿…é¡»å¾—åˆ°å¤šæ•°æŠ•ç¥¨
  - æŠ•ç¥¨è§„åˆ™ç¡®ä¿Candidateçš„æ—¥å¿—è‡³å°‘å’ŒæŠ•ç¥¨è€…ä¸€æ ·æ–°
  - ç”±å½’çº³å‡è®¾ï¼Œå¤šæ•°æŠ•ç¥¨è€…åŒ…å«æ‰€æœ‰Term â‰¤ \( t \) çš„å·²æäº¤æ¡ç›®
  âˆ´ Term \( t+1 \) çš„Leaderä¹ŸåŒ…å«è¿™äº›æ¡ç›® âˆ

### 4.4 Paxosç®—æ³•

#### 4.4.1 Basic Paxos

**è§’è‰²**:

- **Proposer**: æè®®å€¼
- **Acceptor**: æ¥å—æè®®
- **Learner**: å­¦ä¹ å·²å†³å®šçš„å€¼

**ä¸¤é˜¶æ®µåè®®**:

**Phase 1 (Prepare)**:

1. Proposeré€‰æ‹©æè®®ç¼–å· \( n \)ï¼Œå‘é€ `Prepare(n)` ç»™å¤šæ•°Acceptor
2. Acceptoræ”¶åˆ° `Prepare(n)`ï¼š
   - å¦‚æœ \( n \) å¤§äºä¹‹å‰è§è¿‡çš„æ‰€æœ‰æè®®ç¼–å·ï¼Œæ‰¿è¯ºä¸å†æ¥å—ç¼–å· < \( n \) çš„æè®®
   - è¿”å› `Promise(n, accepted_value, accepted_number)`ï¼ˆå¦‚æœä¹‹å‰æ¥å—è¿‡æè®®ï¼‰

**Phase 2 (Accept)**:

1. Proposeræ”¶åˆ°å¤šæ•° `Promise` åï¼š
   - å¦‚æœæœ‰Acceptorè¿”å›äº†accepted_valueï¼Œé€‰æ‹©ç¼–å·æœ€å¤§çš„accepted_value
   - å¦åˆ™é€‰æ‹©è‡ªå·±çš„å€¼
   - å‘é€ `Accept(n, value)` ç»™Acceptor
2. Acceptoræ”¶åˆ° `Accept(n, value)`ï¼š
   - å¦‚æœæ²¡æœ‰æ‰¿è¯ºè¿‡æ›´å¤§çš„ç¼–å·ï¼Œæ¥å—è¯¥æè®®
   - è¿”å› `Accepted(n, value)`

**Haskellå®ç°**:

```haskell
-- Paxosç®—æ³•å®ç°
module Paxos where

import Data.Map (Map)
import qualified Data.Map as Map
import Data.Set (Set)
import qualified Data.Set as Set

type ProposalNumber = Int
type Value = String
type AcceptorID = Int

-- ProposerçŠ¶æ€
data ProposerState v = ProposerState
    { proposalNumber :: ProposalNumber
    , proposedValue  :: Maybe v
    , promises       :: Set AcceptorID
    , highestSeen    :: Maybe (ProposalNumber, v)
    } deriving (Show, Eq)

-- AcceptorçŠ¶æ€
data AcceptorState v = AcceptorState
    { minProposal     :: ProposalNumber  -- æ‰¿è¯ºçš„æœ€å°æè®®ç¼–å·
    , acceptedProposal :: Maybe (ProposalNumber, v)
    } deriving (Show, Eq)

-- æ¶ˆæ¯ç±»å‹
data Message v
    = Prepare ProposalNumber
    | Promise ProposalNumber (Maybe (ProposalNumber, v))
    | Accept ProposalNumber v
    | Accepted ProposalNumber v
    | Nack ProposalNumber  -- æ‹’ç»(å·²æ‰¿è¯ºæ›´å¤§ç¼–å·)
    deriving (Show, Eq)

-- Proposer: å‘èµ·Prepareè¯·æ±‚
initiateProposal :: v -> ProposerState v -> (ProposerState v, [Message v])
initiateProposal value state =
    let n = proposalNumber state + 1
        newState = state { proposalNumber = n
                         , proposedValue = Just value
                         , promises = Set.empty
                         , highestSeen = Nothing }
    in (newState, [Prepare n])

-- Acceptor: å¤„ç†Prepareè¯·æ±‚
handlePrepare :: ProposalNumber -> AcceptorState v -> (AcceptorState v, Message v)
handlePrepare n state
    | n > minProposal state =
        let newState = state { minProposal = n }
        in (newState, Promise n (acceptedProposal state))
    | otherwise =
        (state, Nack n)

-- Proposer: æ”¶é›†Promiseå“åº”
handlePromise :: ProposalNumber -> Maybe (ProposalNumber, v) -> AcceptorID
              -> ProposerState v -> ProposerState v
handlePromise n accepted_info acceptor_id state
    | n == proposalNumber state =
        let state' = state { promises = Set.insert acceptor_id (promises state) }
            state'' = case accepted_info of
                Just (accepted_n, accepted_v) ->
                    case highestSeen state' of
                        Nothing -> state' { highestSeen = Just (accepted_n, accepted_v) }
                        Just (highest_n, _) | accepted_n > highest_n ->
                            state' { highestSeen = Just (accepted_n, accepted_v) }
                        _ -> state'
                Nothing -> state'
        in state''
    | otherwise = state

-- Proposer: å½“æ”¶é›†åˆ°å¤šæ•°Promiseå,å‘é€Acceptè¯·æ±‚
sendAccept :: Int -> ProposerState v -> Maybe (Message v)
sendAccept majority state
    | Set.size (promises state) >= majority =
        let value = case highestSeen state of
                Just (_, v) -> v
                Nothing -> case proposedValue state of
                    Just v -> v
                    Nothing -> error "No value to propose"
        in Just (Accept (proposalNumber state) value)
    | otherwise = Nothing

-- Acceptor: å¤„ç†Acceptè¯·æ±‚
handleAccept :: ProposalNumber -> v -> AcceptorState v -> (AcceptorState v, Message v)
handleAccept n value state
    | n >= minProposal state =
        let newState = state { acceptedProposal = Just (n, value) }
        in (newState, Accepted n value)
    | otherwise =
        (state, Nack n)
```

**å®šç†4.3 (Paxosæ­£ç¡®æ€§)**:

Paxosç®—æ³•æ»¡è¶³å…±è¯†çš„æ‰€æœ‰æ€§è´¨ï¼š

1. **å®‰å…¨æ€§**: åªæœ‰ä¸€ä¸ªå€¼è¢«å†³å®š
2. **æ´»æ€§**: å¦‚æœå¤šæ•°Acceptorå¯è¾¾ï¼Œæœ€ç»ˆæŸä¸ªå€¼ä¼šè¢«å†³å®š

**è¯æ˜æ ¸å¿ƒæ€æƒ³**:

- å¤šæ•°é›†åˆå¿…å®šç›¸äº¤ â†’ ä¿è¯ä¸€è‡´æ€§
- é€‰æ‹©ç¼–å·æœ€å¤§çš„accepted_value â†’ ä¿è¯å·²å†³å®šçš„å€¼ä¸ä¼šæ”¹å˜

### 4.5 PBFT (Practical Byzantine Fault Tolerance)

#### 4.5.1 æ‹œå åº­å®¹é”™é—®é¢˜

åœ¨å­˜åœ¨æ¶æ„èŠ‚ç‚¹çš„æƒ…å†µä¸‹è¾¾æˆå…±è¯†ï¼Œéœ€è¦ \( n \geq 3f + 1 \) ä¸ªèŠ‚ç‚¹æ‰èƒ½å®¹å¿ \( f \) ä¸ªæ‹œå åº­æ•…éšœã€‚

**PBFTä¸‰é˜¶æ®µåè®®**:

1. **Pre-Prepare**: Primaryå‘é€æè®®
2. **Prepare**: å‰¯æœ¬å¹¿æ’­Prepareæ¶ˆæ¯
3. **Commit**: æ”¶é›†åˆ° \( 2f + 1 \) ä¸ªPrepareåå¹¿æ’­Commit

**å…³é”®æ€æƒ³**: é€šè¿‡å¤šè½®æŠ•ç¥¨ç¡®ä¿å³ä½¿Primaryæ˜¯æ¶æ„çš„ï¼Œè¯šå®èŠ‚ç‚¹ä¹Ÿèƒ½è¾¾æˆä¸€è‡´

---

## ç¬¬äº”éƒ¨åˆ†ï¼šåˆ†å¸ƒå¼äº‹åŠ¡çš„å½¢å¼åŒ–è¯­ä¹‰

### 5.1 ACID vs BASE

| å±æ€§ | ACID (ä¼ ç»Ÿæ•°æ®åº“) | BASE (åˆ†å¸ƒå¼ç³»ç»Ÿ) |
|------|------------------|------------------|
| **A**tomicity | åŸå­æ€§ - å…¨éƒ¨æˆåŠŸæˆ–å…¨éƒ¨å¤±è´¥ | **B**asically Available - åŸºæœ¬å¯ç”¨ |
| **C**onsistency | ä¸€è‡´æ€§ - æ»¡è¶³æ‰€æœ‰çº¦æŸ | **S**oft state - è½¯çŠ¶æ€ |
| **I**solation | éš”ç¦»æ€§ - äº‹åŠ¡äº’ä¸å½±å“ | **E**ventual consistency - æœ€ç»ˆä¸€è‡´ |
| **D**urability | æŒä¹…æ€§ - æäº¤åæ°¸ä¹…ä¿å­˜ | |

### 5.2 ä¸¤é˜¶æ®µæäº¤ (2PC)

**åè®®æµç¨‹**:

```text
Coordinator                 Participant1      Participant2
    |                            |                 |
    |---- PREPARE ------------->|                 |
    |---- PREPARE ------------------------------>|
    |                            |                 |
    |<--- VOTE-COMMIT -----------|                 |
    |<--- VOTE-COMMIT ---------------------------|
    |                            |                 |
    |---- COMMIT ---------------->|                 |
    |---- COMMIT --------------------------------->|
    |                            |                 |
    |<--- ACK --------------------|                 |
    |<--- ACK ------------------------------------|
```

**å½¢å¼åŒ–å®šä¹‰**:

```coq
(* ä¸¤é˜¶æ®µæäº¤çš„Coqå½¢å¼åŒ– *)
Section TwoPhaseCommit.

Variable Participant : Type.

(* æŠ•ç¥¨ *)
Inductive Vote := VoteCommit | VoteAbort.

(* äº‹åŠ¡çŠ¶æ€ *)
Inductive TxnState := Init | Prepared | Committed | Aborted.

(* åè°ƒè€…å†³ç­– *)
Definition coordinator_decision (votes : list (Participant * Vote)) : TxnState :=
  if forall_votes_commit votes
  then Committed
  else Aborted.

(* 2PCå®‰å…¨æ€§: å¦‚æœä»»ä½•å‚ä¸è€…æäº¤,åˆ™æ‰€æœ‰å‚ä¸è€…éƒ½æŠ•ç¥¨æäº¤ *)
Theorem two_phase_commit_safety :
  forall (votes : list (Participant * Vote)),
    coordinator_decision votes = Committed ->
    forall p v, In (p, v) votes -> v = VoteCommit.
Proof.
  intros votes H_commit p v H_in.
  unfold coordinator_decision in H_commit.
  destruct (forall_votes_commit votes) eqn:H_all.
  - (* æ‰€æœ‰æŠ•ç¥¨éƒ½æ˜¯commit *)
    apply forall_votes_commit_spec; assumption.
  - (* çŸ›ç›¾: æœ‰abortæŠ•ç¥¨ä½†å†³ç­–ä¸ºcommit *)
    discriminate H_commit.
Qed.

(* 2PCé—®é¢˜: é˜»å¡æ€§ *)
(* å¦‚æœåè°ƒè€…å´©æºƒ,å‚ä¸è€…å¯èƒ½æ°¸è¿œé˜»å¡åœ¨PreparedçŠ¶æ€ *)
Example two_phase_commit_blocking :
  exists (system_state : SystemState),
    coordinator_crashed system_state /\
    exists p, participant_state system_state p = Prepared /\
              ~ can_make_progress p system_state.
Proof.
  (* æ„é€ åä¾‹ç•¥ *)
Admitted.

End TwoPhaseCommit.
```

**2PCçš„é—®é¢˜**:

1. **é˜»å¡æ€§**: åè°ƒè€…å´©æºƒå¯¼è‡´å‚ä¸è€…é˜»å¡
2. **æ€§èƒ½**: ä¸¤è½®é€šä¿¡,å»¶è¿Ÿé«˜

### 5.3 Sagaæ¨¡å¼

**å®šä¹‰5.1 (Saga)**:

Sagaæ˜¯ä¸€ç³»åˆ—æœ¬åœ°äº‹åŠ¡ \( T_1, T_2, \ldots, T_n \)ï¼Œæ¯ä¸ªäº‹åŠ¡æœ‰å¯¹åº”çš„è¡¥å¿äº‹åŠ¡ \( C_i \):

\[
\text{Saga} = (T_1, C_1), (T_2, C_2), \ldots, (T_n, C_n)
\]

**ä¿è¯**:

- **æˆåŠŸè·¯å¾„**: \( T_1 \rightarrow T_2 \rightarrow \cdots \rightarrow T_n \)
- **å¤±è´¥è¡¥å¿**: \( T_1 \rightarrow \cdots \rightarrow T_k \rightarrow C_k \rightarrow C_{k-1} \rightarrow \cdots \rightarrow C_1 \)

**å½¢å¼åŒ–**:

\[
\text{Saga-Guarantee} = T_1; T_2; \ldots; T_n \lor T_1; \ldots; T_k; C_k; \ldots; C_1
\]

---

## ç¬¬å…­éƒ¨åˆ†ï¼šä¸€è‡´æ€§æ¨¡å‹çš„å½¢å¼åŒ–å®šä¹‰

### 6.1 ä¸€è‡´æ€§å±‚æ¬¡ç»“æ„

```text
Strong Consistency
    |
    â”œâ”€ Linearizability (æœ€å¼º)
    |   â””â”€ æ‰€æœ‰æ“ä½œæœ‰å®æ—¶å…¨åº
    |
    â”œâ”€ Sequential Consistency
    |   â””â”€ æ‰€æœ‰æ“ä½œæœ‰å…¨åº(ä¸ä¿è¯å®æ—¶)
    |
    â”œâ”€ Causal Consistency
    |   â””â”€ ä¿æŒå› æœé¡ºåº
    |
    â”œâ”€ PRAM/FIFO Consistency
    |   â””â”€ ä¿æŒå•ä¸ªè¿›ç¨‹çš„æ“ä½œé¡ºåº
    |
    â””â”€ Eventual Consistency (æœ€å¼±)
        â””â”€ æ— å†²çªä¸‹æœ€ç»ˆæ”¶æ•›
```

### 6.2 Sequential Consistency

**å®šä¹‰6.1 (é¡ºåºä¸€è‡´æ€§, Lamport 1979)**:

ç³»ç»Ÿæ»¡è¶³**é¡ºåºä¸€è‡´æ€§** âŸº å­˜åœ¨ä¸€ä¸ªæ‰€æœ‰æ“ä½œçš„å…¨åº \( S \)ï¼Œä½¿å¾—ï¼š

1. \( S \) ä¸æ¯ä¸ªè¿›ç¨‹çš„ç¨‹åºé¡ºåºä¸€è‡´
2. æ¯ä¸ªè¯»æ“ä½œè¿”å›è¯¥åºåˆ—ä¸­æœ€åä¸€æ¬¡å†™çš„å€¼

**ä¸Linearizabilityçš„åŒºåˆ«**:

- **Linearizability**: ä¿æŒå®æ—¶é¡ºåº
- **Sequential Consistency**: ä¸ä¿è¯å®æ—¶é¡ºåº

**ç¤ºä¾‹**:

```python
# é¡ºåºä¸€è‡´ä½†ä¸æ»¡è¶³çº¿æ€§ä¸€è‡´æ€§çš„æ‰§è¡Œ

# è¿›ç¨‹P1:
x = 1         # W(x)1  at time t1
print(y)  # R(y)0  at time t2

# è¿›ç¨‹P2:
y = 1         # W(y)1  at time t3
print(x)  # R(x)0  at time t4

# å¦‚æœ t1 < t3 < t2 < t4,åˆ™:
# - é¡ºåºä¸€è‡´: å¯ä»¥æœ‰åºåˆ— W(y)1, R(y)0, W(x)1, R(x)0
# - ä¸æ»¡è¶³çº¿æ€§ä¸€è‡´æ€§: å®æ—¶ä¸Š W(x)1 åœ¨ W(y)1 ä¹‹å‰,
#   ä½† R(y)0 å‘ç”Ÿåœ¨ W(y)1 ä¹‹å(å®æ—¶),å´è¯»åˆ°0
```

---

## ç¬¬ä¹éƒ¨åˆ†ï¼šCRDTsä¸æœ€ç»ˆä¸€è‡´æ€§

### 9.1 CRDTs (Conflict-free Replicated Data Types)

**å®šä¹‰9.1 (CRDT)**:

ä¸€ä¸ªæ•°æ®ç±»å‹æ˜¯**CRDT** âŸº æ»¡è¶³ä»¥ä¸‹ä¹‹ä¸€ï¼š

1. **CvRDT (State-based)**: åˆå¹¶æ“ä½œæ»¡è¶³äº¤æ¢å¾‹ã€ç»“åˆå¾‹ã€å¹‚ç­‰æ€§
   \[
   \text{merge}(S_1, S_2) = \text{merge}(S_2, S_1) \quad (\text{äº¤æ¢å¾‹})
   \]
   \[
   \text{merge}(\text{merge}(S_1, S_2), S_3) = \text{merge}(S_1, \text{merge}(S_2, S_3)) \quad (\text{ç»“åˆå¾‹})
   \]
   \[
   \text{merge}(S, S) = S \quad (\text{å¹‚ç­‰æ€§})
   \]

2. **CmRDT (Operation-based)**: æ“ä½œå¯äº¤æ¢
   \[
   \text{apply}(op_1, \text{apply}(op_2, S)) = \text{apply}(op_2, \text{apply}(op_1, S))
   \]

### 9.2 ç»å…¸CRDTç¤ºä¾‹

#### 9.2.1 G-Counter (Grow-only Counter)

**Haskellå®ç°**:

```haskell
-- G-Counter: åªå¢é•¿çš„è®¡æ•°å™¨
module GCounter where

import Data.Map (Map)
import qualified Data.Map as Map

type ReplicaID = Int
type GCounter = Map ReplicaID Int

-- åˆå§‹åŒ–
initial :: GCounter
initial = Map.empty

-- æœ¬åœ°å¢åŠ 
increment :: ReplicaID -> GCounter -> GCounter
increment replica counter =
    Map.insertWith (+) replica 1 counter

-- è¯»å–æ€»å€¼
value :: GCounter -> Int
value counter = sum (Map.elems counter)

-- åˆå¹¶ (å–å„å‰¯æœ¬çš„æœ€å¤§å€¼)
merge :: GCounter -> GCounter -> GCounter
merge = Map.unionWith max

-- éªŒè¯CRDTæ€§è´¨
-- äº¤æ¢å¾‹: merge a b == merge b a
commutative :: GCounter -> GCounter -> Bool
commutative a b = merge a b == merge b a

-- ç»“åˆå¾‹: merge (merge a b) c == merge a (merge b c)
associative :: GCounter -> GCounter -> GCounter -> Bool
associative a b c = merge (merge a b) c == merge a (merge b c)

-- å¹‚ç­‰æ€§: merge a a == a
idempotent :: GCounter -> Bool
idempotent a = merge a a == a
```

#### 9.2.2 PN-Counter (Positive-Negative Counter)

```haskell
-- PN-Counter: å¯å¢å¯å‡çš„è®¡æ•°å™¨
module PNCounter where

import qualified GCounter

data PNCounter = PNCounter
    { positive :: GCounter.GCounter
    , negative :: GCounter.GCounter
    } deriving (Show, Eq)

-- åˆå§‹åŒ–
initial :: PNCounter
initial = PNCounter GCounter.initial GCounter.initial

-- å¢åŠ 
increment :: ReplicaID -> PNCounter -> PNCounter
increment replica counter =
    counter { positive = GCounter.increment replica (positive counter) }

-- å‡å°‘
decrement :: ReplicaID -> PNCounter -> PNCounter
decrement replica counter =
    counter { negative = GCounter.increment replica (negative counter) }

-- è¯»å–å€¼
value :: PNCounter -> Int
value counter = GCounter.value (positive counter) - GCounter.value (negative counter)

-- åˆå¹¶
merge :: PNCounter -> PNCounter -> PNCounter
merge c1 c2 = PNCounter
    { positive = GCounter.merge (positive c1) (positive c2)
    , negative = GCounter.merge (negative c1) (negative c2)
    }
```

#### 9.2.3 LWW-Element-Set (Last-Write-Wins Set)

```haskell
-- LWW-Element-Set: æœ€åå†™å…¥è€…èƒœå‡ºé›†åˆ
module LWWElementSet where

import Data.Map (Map)
import qualified Data.Map as Map
import Data.Set (Set)
import qualified Data.Set as Set

type Timestamp = Int
type Element = String

data LWWSet = LWWSet
    { addSet    :: Map Element Timestamp  -- æ·»åŠ é›†åˆ(å…ƒç´  -> æ·»åŠ æ—¶é—´æˆ³)
    , removeSet :: Map Element Timestamp  -- åˆ é™¤é›†åˆ(å…ƒç´  -> åˆ é™¤æ—¶é—´æˆ³)
    } deriving (Show, Eq)

-- åˆå§‹åŒ–
initial :: LWWSet
initial = LWWSet Map.empty Map.empty

-- æ·»åŠ å…ƒç´ 
add :: Element -> Timestamp -> LWWSet -> LWWSet
add elem ts set =
    set { addSet = Map.insert elem ts (addSet set) }

-- åˆ é™¤å…ƒç´ 
remove :: Element -> Timestamp -> LWWSet -> LWWSet
remove elem ts set =
    set { removeSet = Map.insert elem ts (removeSet set) }

-- æŸ¥è¯¢å…ƒç´ æ˜¯å¦å­˜åœ¨
lookup :: Element -> LWWSet -> Bool
lookup elem set =
    case (Map.lookup elem (addSet set), Map.lookup elem (removeSet set)) of
        (Just add_ts, Just remove_ts) -> add_ts >= remove_ts  -- LWWè§„åˆ™: æ—¶é—´æˆ³ç›¸ç­‰æ—¶addèƒœå‡º
        (Just _, Nothing)             -> True
        _                             -> False

-- åˆå¹¶ (å–æ¯ä¸ªå…ƒç´ çš„æœ€å¤§æ—¶é—´æˆ³)
merge :: LWWSet -> LWWSet -> LWWSet
merge s1 s2 = LWWSet
    { addSet = Map.unionWith max (addSet s1) (addSet s2)
    , removeSet = Map.unionWith max (removeSet s1) (removeSet s2)
    }
```

### 9.3 CRDTçš„ç†è®ºåŸºç¡€

**å®šç†9.1 (CRDTæ”¶æ•›æ€§)**:

å¦‚æœæ•°æ®ç±»å‹æ»¡è¶³CRDTæ€§è´¨ï¼Œåˆ™åœ¨æ— å†²çªæ›´æ–°ä¸‹ï¼Œæ‰€æœ‰å‰¯æœ¬æœ€ç»ˆæ”¶æ•›åˆ°ç›¸åŒçŠ¶æ€ã€‚

**è¯æ˜**:

- é€šè¿‡join-semilatticeç†è®º
- åˆå¹¶æ“ä½œæ˜¯joinæ“ä½œ
- çŠ¶æ€ç©ºé—´å½¢æˆååºé›†
- æœ€ç»ˆæ‰€æœ‰å‰¯æœ¬è¾¾åˆ°æœ€å°ä¸Šç•Œ(LUB) âˆ

---

## ç¬¬åéƒ¨åˆ†ï¼š2025å¹´åˆ†å¸ƒå¼ç³»ç»Ÿå‰æ²¿

### 10.1 ç¡®å®šæ€§åˆ†å¸ƒå¼ç³»ç»Ÿ

**æ¦‚å¿µ**: ç›¸åŒçš„è¾“å…¥åºåˆ— â†’ ç›¸åŒçš„çŠ¶æ€è½¬æ¢ â†’ æ›´å®¹æ˜“éªŒè¯å’Œè°ƒè¯•

**ä»£è¡¨ç³»ç»Ÿ**:

- **FoundationDB** (2013-2025): ä½¿ç”¨ç¡®å®šæ€§æ¨¡æ‹Ÿæµ‹è¯•
- **Calvin** (Yale, 2012): ç¡®å®šæ€§æ•°æ®åº“
- **Deterministic Simulation Testing** (DST): Dropbox, Antithesis

**æ ¸å¿ƒæ€æƒ³**:

```python
# ç¡®å®šæ€§æ¨¡æ‹Ÿå™¨
class DeterministicSimulator:
    def __init__(self, seed):
        self.rng = Random(seed)  # ç¡®å®šæ€§éšæœºæ•°ç”Ÿæˆå™¨
        self.time = 0
        self.event_queue = PriorityQueue()
    
    def schedule_event(self, delay, callback):
        """è°ƒåº¦äº‹ä»¶ (ç¡®å®šæ€§å»¶è¿Ÿ)"""
        event_time = self.time + delay
        self.event_queue.put((event_time, callback))
    
    def run(self):
        """è¿è¡Œæ¨¡æ‹Ÿ (å®Œå…¨ç¡®å®šæ€§)"""
        while not self.event_queue.empty():
            self.time, callback = self.event_queue.get()
            callback()
    
    # ç›¸åŒç§å­ â†’ ç›¸åŒæ‰§è¡Œ â†’ å¯é‡ç°Bug
```

**ä¼˜åŠ¿**:

- **å¯é‡ç°æ€§**: ç›¸åŒè¾“å…¥äº§ç”Ÿç›¸åŒè¾“å‡ºï¼ŒBugå¯é‡ç°
- **æ—¶é—´æ—…è¡Œè°ƒè¯•**: å¯ä»¥å›æº¯åˆ°ä»»æ„æ—¶é—´ç‚¹
- **ç©·ä¸¾æµ‹è¯•**: å¯ä»¥æµ‹è¯•æ‰€æœ‰å¯èƒ½çš„æ‰§è¡Œé¡ºåº

### 10.2 åˆ†å¸ƒå¼å¿«ç…§ä¸æ—¶é—´æ—…è¡ŒæŸ¥è¯¢

**Temporal Queries** (2025è¶‹åŠ¿):

```sql
-- æŸ¥è¯¢å†å²æ•°æ® (AS OFè¯­æ³•)
SELECT * FROM orders
AS OF SYSTEM TIME '2025-01-01 00:00:00';

-- æŸ¥è¯¢æ—¶é—´èŒƒå›´å†…çš„å˜åŒ–
SELECT * FROM orders
FOR SYSTEM_TIME BETWEEN '2025-01-01' AND '2025-01-31';

-- å®ç°: åŸºäºMVCC + Hybrid Logical Clock
```

**ç³»ç»Ÿ**: CockroachDB, TiDB, YugabyteDB

### 10.3 Jepsenæµ‹è¯•ä¸å½¢å¼åŒ–éªŒè¯çš„ç»“åˆ

**Jepsen** (Kyle Kingsbury, 2013-2025):

- åˆ†å¸ƒå¼ç³»ç»Ÿçš„é»‘ç›’ä¸€è‡´æ€§æµ‹è¯•æ¡†æ¶
- å‘ç°äº†å¤§é‡çŸ¥åç³»ç»Ÿçš„Bug (MongoDB, Elasticsearch, Cassandra, etc.)

**2025å¹´è¶‹åŠ¿**: Jepsen + TLA+ ç»“åˆ

```clojure
; Jepsenæµ‹è¯• + TLA+è§„çº¦éªŒè¯
(deftest raft-linearizability-test
  (let [spec (tla/load-spec "Raft.tla")
        history (jepsen/run-test raft-test)]
    ; 1. Jepsené»‘ç›’æµ‹è¯•
    (is (linearizable? history))
    
    ; 2. TLA+è§„çº¦éªŒè¯
    (is (tla/check-spec spec history))
    
    ; 3. åä¾‹æœ€å°åŒ–
    (when-let [bug (find-bug history)]
      (tla/minimize-counterexample spec bug))))
```

### 10.4 è¾¹ç¼˜è®¡ç®—ä¸Geo-åˆ†å¸ƒå¼å…±è¯†

**æŒ‘æˆ˜**:

- è·¨å¤§é™†å»¶è¿Ÿ (100-300ms)
- ä¸å¯¹ç§°ç½‘ç»œ (ä¸Šè¡Œ << ä¸‹è¡Œ)
- ç§»åŠ¨èŠ‚ç‚¹

**è§£å†³æ–¹æ¡ˆ**:

1. **EPaxos** (Egalitarian Paxos): æ— Leaderçš„Paxoså˜ç§
2. **Geo-Replication**: å¤šåŒºåŸŸå¤åˆ¶
3. **Edge Consensus**: è¾¹ç¼˜èŠ‚ç‚¹æœ¬åœ°å…±è¯†

**ç¤ºä¾‹: Cloudflare Durable Objects** (2025):

- æ¯ä¸ªå¯¹è±¡æœ‰å•ä¸€çš„å…¨å±€åè°ƒè€…
- è‡ªåŠ¨è¿ç§»åˆ°æœ€è¿‘çš„ç”¨æˆ·
- å¼ºä¸€è‡´æ€§ + ä½å»¶è¿Ÿ

### 10.5 é‡å­è®¡ç®—å¯¹åˆ†å¸ƒå¼ç³»ç»Ÿçš„å½±å“

**æ½œåœ¨å½±å“**:

1. **å¯†ç å­¦**: é‡å­è®¡ç®—ç ´è§£RSA â†’ éœ€è¦åé‡å­å¯†ç å­¦
2. **å…±è¯†ç®—æ³•**: é‡å­çº ç¼ å¯èƒ½åŠ é€Ÿå…±è¯†ï¼Ÿ(ç†è®ºç ”ç©¶ä¸­)
3. **Byzantineå®¹é”™**: é‡å­ç­¾åå¯ä»¥æ›´é«˜æ•ˆåœ°æ£€æµ‹æ‹œå åº­èŠ‚ç‚¹

**2025ç°çŠ¶**: ä»å¤„äºæ—©æœŸç ”ç©¶é˜¶æ®µ

---

## æ€»ç»“ä¸å‚è€ƒæ–‡çŒ®

### æœ¬æ–‡æ¡£è¦†ç›–çš„æ ¸å¿ƒå†…å®¹

1. **åˆ†å¸ƒå¼ç³»ç»Ÿå½¢å¼åŒ–æ¨¡å‹**: è¿›ç¨‹ã€æ¶ˆæ¯ã€æ—¶é—´
2. **CAP/PACELCå®šç†**: ä¸€è‡´æ€§ä¸å¯ç”¨æ€§çš„æƒè¡¡
3. **æ—¶é’Ÿç†è®º**: Lamport Clock, Vector Clock, HLC
4. **å…±è¯†ç®—æ³•**: Raft, Paxos, PBFTçš„TLA+è§„çº¦ä¸Coqè¯æ˜
5. **åˆ†å¸ƒå¼äº‹åŠ¡**: 2PC, Saga, ä¸€è‡´æ€§æ¨¡å‹
6. **CRDTs**: æ— å†²çªå¤åˆ¶æ•°æ®ç±»å‹çš„ç†è®ºä¸å®ç°
7. **2025å‰æ²¿**: ç¡®å®šæ€§ç³»ç»Ÿ, Jepsen+TLA+, è¾¹ç¼˜è®¡ç®—

### å‚è€ƒæ–‡çŒ®

#### ç»å…¸è®ºæ–‡

1. **Lamport, L.** (1978). "Time, Clocks, and the Ordering of Events in a Distributed System". *CACM*.
2. **Fischer, M., Lynch, N., Paterson, M.** (1985). "Impossibility of Distributed Consensus with One Faulty Process". *JACM*.
3. **Lamport, L.** (1998). "The Part-Time Parliament" (Paxos). *ACM TOCS*.
4. **Brewer, E.** (2000). "Towards Robust Distributed Systems" (CAP Theorem). *PODC Keynote*.
5. **Gilbert, S., Lynch, N.** (2002). "Brewer's Conjecture and the Feasibility of Consistent, Available, Partition-Tolerant Web Services". *ACM SIGACT News*.
6. **Ongaro, D., Ousterhout, J.** (2014). "In Search of an Understandable Consensus Algorithm" (Raft). *USENIX ATC*.
7. **Shapiro, M., et al.** (2011). "CRDTs: Consistency without Concurrency Control". *RR-7687, INRIA*.

#### åˆ†å¸ƒå¼ç³»ç»Ÿæ•™æ

1. **Tanenbaum, A., Van Steen, M.** (2017). *Distributed Systems*. 3rd Edition.
2. **Kleppmann, M.** (2017). *Designing Data-Intensive Applications*. O'Reilly.
3. **Cachin, C., Guerraoui, R., Rodrigues, L.** (2011). *Introduction to Reliable and Secure Distributed Programming*. Springer.

#### å½¢å¼åŒ–éªŒè¯

1. **Newcombe, C., et al.** (2015). "How Amazon Web Services Uses Formal Methods". *CACM*.
2. **Hawblitzel, C., et al.** (2015). "IronFleet: Proving Practical Distributed Systems Correct". *SOSP*.
3. **Wilcox, J., et al.** (2015). "Verdi: A Framework for Implementing and Formally Verifying Distributed Systems". *PLDI*.

#### 2025å¹´æœ€æ–°ç ”ç©¶

1. **Kulkarni, S., et al.** (2014). "Logical Physical Clocks and Consistent Snapshots in Globally Distributed Databases". *SSS*.
2. **Kingsbury, K.** (2013-2025). *Jepsen: Distributed Systems Safety Analysis*. https://jepsen.io/
3. **FoundationDB Team** (2025). "Deterministic Simulation Testing at Scale". *Technical Report*.
4. **Cloudflare** (2025). "Durable Objects: Strong Consistency at the Edge". *Technical Report*.

---

**æ–‡æ¡£ç‰ˆæœ¬**: v1.0  
**æœ€åæ›´æ–°**: 2025å¹´10æœˆ20æ—¥  
**ä½œè€…**: Distributed Systems Theory Research Group  
**License**: CC-BY-4.0

---

**ğŸ‰ æœ¬æ–‡æ¡£æä¾›äº†åˆ†å¸ƒå¼ç³»ç»Ÿä»åŸºç¡€ç†è®ºåˆ°2025å¹´å‰æ²¿æŠ€æœ¯çš„å®Œæ•´å½¢å¼åŒ–åˆ†æï¼**
