# è™šæ‹ŸåŒ–ä¸å®¹å™¨åŒ–çš„è®¡ç®—æœºä½“ç³»ç»“æ„ç†è®º

> **æœ¬æ–‡æ¡£å®šä½**: ä»è®¡ç®—æœºä½“ç³»ç»“æ„ã€æ“ä½œç³»ç»ŸåŸç†ã€å½¢å¼åŒ–æ–¹æ³•è§’åº¦ï¼Œæ·±å…¥é˜è¿°è™šæ‹ŸåŒ–å’Œå®¹å™¨åŒ–æŠ€æœ¯çš„ç†è®ºåŸºç¡€

---

## ğŸ“‹ ç›®å½•

- [è™šæ‹ŸåŒ–ä¸å®¹å™¨åŒ–çš„è®¡ç®—æœºä½“ç³»ç»“æ„ç†è®º](#è™šæ‹ŸåŒ–ä¸å®¹å™¨åŒ–çš„è®¡ç®—æœºä½“ç³»ç»“æ„ç†è®º)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [ç¬¬ä¸€éƒ¨åˆ†ï¼šè®¡ç®—æœºä½“ç³»ç»“æ„å¯¹è™šæ‹ŸåŒ–çš„æ”¯æŒ](#ç¬¬ä¸€éƒ¨åˆ†è®¡ç®—æœºä½“ç³»ç»“æ„å¯¹è™šæ‹ŸåŒ–çš„æ”¯æŒ)
    - [1.1 CPUè™šæ‹ŸåŒ–çš„ç¡¬ä»¶æ”¯æŒ](#11-cpuè™šæ‹ŸåŒ–çš„ç¡¬ä»¶æ”¯æŒ)
      - [1.1.1 CPUç‰¹æƒçº§ä¸ä¿æŠ¤ç¯](#111-cpuç‰¹æƒçº§ä¸ä¿æŠ¤ç¯)
      - [1.1.2 Intel VT-x (Virtualization Technology)](#112-intel-vt-x-virtualization-technology)
      - [1.1.3 AMD-V (AMD Virtualization)](#113-amd-v-amd-virtualization)
      - [1.1.4 ARMè™šæ‹ŸåŒ–æ‰©å±•](#114-armè™šæ‹ŸåŒ–æ‰©å±•)
    - [1.2 å†…å­˜è™šæ‹ŸåŒ–çš„ç¡¬ä»¶æ”¯æŒ](#12-å†…å­˜è™šæ‹ŸåŒ–çš„ç¡¬ä»¶æ”¯æŒ)
      - [1.2.1 ä¼ ç»Ÿè½¯ä»¶MMU (Shadow Page Table)](#121-ä¼ ç»Ÿè½¯ä»¶mmu-shadow-page-table)
      - [1.2.2 Intel EPT (Extended Page Tables)](#122-intel-ept-extended-page-tables)
      - [1.2.3 AMD NPT (Nested Page Tables)](#123-amd-npt-nested-page-tables)
      - [1.2.4 å†…å­˜è™šæ‹ŸåŒ–çš„å½¢å¼åŒ–æ¨¡å‹](#124-å†…å­˜è™šæ‹ŸåŒ–çš„å½¢å¼åŒ–æ¨¡å‹)
    - [1.3 I/Oè™šæ‹ŸåŒ–çš„ç¡¬ä»¶æ”¯æŒ](#13-ioè™šæ‹ŸåŒ–çš„ç¡¬ä»¶æ”¯æŒ)
      - [1.3.1 ä¼ ç»ŸI/Oè™šæ‹ŸåŒ– (è½¯ä»¶æ¨¡æ‹Ÿ)](#131-ä¼ ç»Ÿioè™šæ‹ŸåŒ–-è½¯ä»¶æ¨¡æ‹Ÿ)
      - [1.3.2 Intel VT-d (Virtualization Technology for Directed I/O)](#132-intel-vt-d-virtualization-technology-for-directed-io)
      - [1.3.3 SR-IOV (Single Root I/O Virtualization)](#133-sr-iov-single-root-io-virtualization)
      - [1.3.4 VFIO (Virtual Function I/O)](#134-vfio-virtual-function-io)
    - [1.4 ç¡¬ä»¶è™šæ‹ŸåŒ–çš„å½¢å¼åŒ–æ¨¡å‹](#14-ç¡¬ä»¶è™šæ‹ŸåŒ–çš„å½¢å¼åŒ–æ¨¡å‹)
      - [1.4.1 è™šæ‹ŸåŒ–çš„æŠ½è±¡çŠ¶æ€æœº](#141-è™šæ‹ŸåŒ–çš„æŠ½è±¡çŠ¶æ€æœº)
      - [1.4.2 EPTçš„å½¢å¼åŒ–å®šä¹‰](#142-eptçš„å½¢å¼åŒ–å®šä¹‰)
  - [ç¬¬äºŒéƒ¨åˆ†ï¼šæ“ä½œç³»ç»Ÿå±‚é¢çš„å®¹å™¨åŒ–æŠ€æœ¯ç»“æ„](#ç¬¬äºŒéƒ¨åˆ†æ“ä½œç³»ç»Ÿå±‚é¢çš„å®¹å™¨åŒ–æŠ€æœ¯ç»“æ„)
    - [2.1 Linux Namespaceçš„å†…æ ¸å®ç°](#21-linux-namespaceçš„å†…æ ¸å®ç°)
      - [2.1.1 Namespaceçš„å†…æ ¸æ•°æ®ç»“æ„](#211-namespaceçš„å†…æ ¸æ•°æ®ç»“æ„)
      - [2.1.2 PID Namespaceçš„å®ç°](#212-pid-namespaceçš„å®ç°)
      - [2.1.3 Network Namespaceçš„å®ç°](#213-network-namespaceçš„å®ç°)
      - [2.1.4 Mount Namespaceçš„å®ç°](#214-mount-namespaceçš„å®ç°)
      - [2.1.5 Namespaceåˆ›å»ºä¸åˆ‡æ¢çš„ç³»ç»Ÿè°ƒç”¨](#215-namespaceåˆ›å»ºä¸åˆ‡æ¢çš„ç³»ç»Ÿè°ƒç”¨)
    - [2.2 Cgroupsçš„èµ„æºéš”ç¦»æœºåˆ¶](#22-cgroupsçš„èµ„æºéš”ç¦»æœºåˆ¶)
      - [2.2.1 Cgroup v1æ¶æ„](#221-cgroup-v1æ¶æ„)
      - [2.2.2 CPUæ§åˆ¶å™¨ (cpu, cpuacct)](#222-cpuæ§åˆ¶å™¨-cpu-cpuacct)
      - [2.2.3 Memoryæ§åˆ¶å™¨](#223-memoryæ§åˆ¶å™¨)
      - [2.2.4 Block I/Oæ§åˆ¶å™¨](#224-block-ioæ§åˆ¶å™¨)
      - [2.2.5 Cgroup v2 (ç»Ÿä¸€å±‚çº§)](#225-cgroup-v2-ç»Ÿä¸€å±‚çº§)
      - [2.2.6 Cgroupçš„å½¢å¼åŒ–æ¨¡å‹](#226-cgroupçš„å½¢å¼åŒ–æ¨¡å‹)
    - [2.3 æ–‡ä»¶ç³»ç»Ÿéš”ç¦»ä¸Union FS](#23-æ–‡ä»¶ç³»ç»Ÿéš”ç¦»ä¸union-fs)
      - [2.3.1 UnionFSåŸç†](#231-unionfsåŸç†)
      - [2.3.2 OverlayFSå®ç°](#232-overlayfså®ç°)
      - [2.3.3 AUFS vs OverlayFS vs Btrfs](#233-aufs-vs-overlayfs-vs-btrfs)
    - [2.4 å®¹å™¨åŒ–çš„å†…æ ¸å®‰å…¨æœºåˆ¶](#24-å®¹å™¨åŒ–çš„å†…æ ¸å®‰å…¨æœºåˆ¶)
      - [2.4.1 Capabilities](#241-capabilities)
      - [2.4.2 Seccomp (Secure Computing Mode)](#242-seccomp-secure-computing-mode)
      - [2.4.3 AppArmor / SELinux](#243-apparmor--selinux)
      - [2.4.4 User Namespace](#244-user-namespace)
  - [ç¬¬ä¸‰éƒ¨åˆ†ï¼šå®¹å™¨åŒ–çš„ç¡¬ä»¶è§„èŒƒä¸æ¥å£](#ç¬¬ä¸‰éƒ¨åˆ†å®¹å™¨åŒ–çš„ç¡¬ä»¶è§„èŒƒä¸æ¥å£)
    - [3.1 OCI (Open Container Initiative) è§„èŒƒ](#31-oci-open-container-initiative-è§„èŒƒ)
      - [3.1.1 OCI Runtime Specification](#311-oci-runtime-specification)
      - [3.1.2 OCI Image Specification](#312-oci-image-specification)
    - [3.2 CRI (Container Runtime Interface) è§„èŒƒ](#32-cri-container-runtime-interface-è§„èŒƒ)
    - [3.3 CNI (Container Network Interface) è§„èŒƒ](#33-cni-container-network-interface-è§„èŒƒ)
    - [3.4 CSI (Container Storage Interface) è§„èŒƒ](#34-csi-container-storage-interface-è§„èŒƒ)
  - [ç¬¬å››éƒ¨åˆ†ï¼šå½¢å¼åŒ–å®šä¹‰ä¸æ•°å­¦æ¨¡å‹](#ç¬¬å››éƒ¨åˆ†å½¢å¼åŒ–å®šä¹‰ä¸æ•°å­¦æ¨¡å‹)
    - [4.1 è™šæ‹ŸåŒ–çš„å½¢å¼åŒ–å®šä¹‰](#41-è™šæ‹ŸåŒ–çš„å½¢å¼åŒ–å®šä¹‰)
      - [4.1.1 Popek-Goldbergè™šæ‹ŸåŒ–å®šç†](#411-popek-goldbergè™šæ‹ŸåŒ–å®šç†)
      - [4.1.2 ç±»å‹ç³»ç»Ÿè§†è§’ä¸‹çš„è™šæ‹ŸåŒ–](#412-ç±»å‹ç³»ç»Ÿè§†è§’ä¸‹çš„è™šæ‹ŸåŒ–)
    - [4.2 å®¹å™¨çš„å½¢å¼åŒ–å®šä¹‰](#42-å®¹å™¨çš„å½¢å¼åŒ–å®šä¹‰)
      - [4.2.1 å®¹å™¨çš„ä»£æ•°å®šä¹‰](#421-å®¹å™¨çš„ä»£æ•°å®šä¹‰)
      - [4.2.2 å®¹å™¨ç»„åˆçš„èŒƒç•´è®ºè§†è§’](#422-å®¹å™¨ç»„åˆçš„èŒƒç•´è®ºè§†è§’)
    - [4.3 éš”ç¦»æ€§çš„å½¢å¼åŒ–è¯æ˜](#43-éš”ç¦»æ€§çš„å½¢å¼åŒ–è¯æ˜)
      - [4.3.1 å†…å­˜éš”ç¦»çš„å½¢å¼åŒ–](#431-å†…å­˜éš”ç¦»çš„å½¢å¼åŒ–)
      - [4.3.2 è¿›ç¨‹éš”ç¦»çš„å½¢å¼åŒ–](#432-è¿›ç¨‹éš”ç¦»çš„å½¢å¼åŒ–)
      - [4.3.3 æ–‡ä»¶ç³»ç»Ÿéš”ç¦»çš„å½¢å¼åŒ–](#433-æ–‡ä»¶ç³»ç»Ÿéš”ç¦»çš„å½¢å¼åŒ–)
    - [4.4 å®‰å…¨è¾¹ç•Œçš„ç†è®ºæ¨¡å‹](#44-å®‰å…¨è¾¹ç•Œçš„ç†è®ºæ¨¡å‹)
      - [4.4.1 ä¿¡æ¯æµå®‰å…¨æ¨¡å‹](#441-ä¿¡æ¯æµå®‰å…¨æ¨¡å‹)
      - [4.4.2 èƒ½åŠ›å®‰å…¨æ¨¡å‹](#442-èƒ½åŠ›å®‰å…¨æ¨¡å‹)
  - [ç¬¬äº”éƒ¨åˆ†ï¼šæŠ€æœ¯çŸ¥è¯†å›¾è°±](#ç¬¬äº”éƒ¨åˆ†æŠ€æœ¯çŸ¥è¯†å›¾è°±)
    - [5.1 æ¦‚å¿µå±‚æ¬¡ç»“æ„](#51-æ¦‚å¿µå±‚æ¬¡ç»“æ„)
    - [5.2 æŠ€æœ¯ä¾èµ–å…³ç³»](#52-æŠ€æœ¯ä¾èµ–å…³ç³»)
    - [5.3 å±æ€§ä¸çº¦æŸæ¨¡å‹](#53-å±æ€§ä¸çº¦æŸæ¨¡å‹)
    - [5.4 æ¼”åŒ–è·¯å¾„å›¾](#54-æ¼”åŒ–è·¯å¾„å›¾)
  - [ç¬¬å…­éƒ¨åˆ†ï¼šè®ºè¯ä¸å½¢å¼åŒ–éªŒè¯](#ç¬¬å…­éƒ¨åˆ†è®ºè¯ä¸å½¢å¼åŒ–éªŒè¯)
    - [6.1 Popek-Goldbergè™šæ‹ŸåŒ–å®šç†](#61-popek-goldbergè™šæ‹ŸåŒ–å®šç†)
    - [6.2 å®¹å™¨éš”ç¦»çš„å¯è¯æ˜å®‰å…¨æ€§](#62-å®¹å™¨éš”ç¦»çš„å¯è¯æ˜å®‰å…¨æ€§)
    - [6.3 æ€§èƒ½æ¨¡å‹ä¸ç†è®ºç•Œé™](#63-æ€§èƒ½æ¨¡å‹ä¸ç†è®ºç•Œé™)
    - [6.4 å½¢å¼åŒ–éªŒè¯å·¥å…·ä¸æ–¹æ³•](#64-å½¢å¼åŒ–éªŒè¯å·¥å…·ä¸æ–¹æ³•)
  - [ç¬¬ä¸ƒéƒ¨åˆ†ï¼šç†è®ºä¸å®è·µçš„æ¡¥æ¥](#ç¬¬ä¸ƒéƒ¨åˆ†ç†è®ºä¸å®è·µçš„æ¡¥æ¥)
    - [7.1 ä»ç†è®ºåˆ°å®ç°çš„æ˜ å°„](#71-ä»ç†è®ºåˆ°å®ç°çš„æ˜ å°„)
    - [7.2 ç†è®ºæŒ‡å¯¼ä¸‹çš„ç³»ç»Ÿè®¾è®¡](#72-ç†è®ºæŒ‡å¯¼ä¸‹çš„ç³»ç»Ÿè®¾è®¡)
    - [7.3 æ€§èƒ½ä¼˜åŒ–çš„ç†è®ºåŸºç¡€](#73-æ€§èƒ½ä¼˜åŒ–çš„ç†è®ºåŸºç¡€)
  - [å‚è€ƒæ–‡çŒ®](#å‚è€ƒæ–‡çŒ®)
    - [ç»å…¸è®ºæ–‡](#ç»å…¸è®ºæ–‡)
    - [å½¢å¼åŒ–éªŒè¯](#å½¢å¼åŒ–éªŒè¯)
    - [å®‰å…¨](#å®‰å…¨)
    - [æ€§èƒ½](#æ€§èƒ½)
    - [æ ‡å‡†ä¸è§„èŒƒ](#æ ‡å‡†ä¸è§„èŒƒ)
    - [ä¹¦ç±](#ä¹¦ç±)

---

## ç¬¬ä¸€éƒ¨åˆ†ï¼šè®¡ç®—æœºä½“ç³»ç»“æ„å¯¹è™šæ‹ŸåŒ–çš„æ”¯æŒ

### 1.1 CPUè™šæ‹ŸåŒ–çš„ç¡¬ä»¶æ”¯æŒ

#### 1.1.1 CPUç‰¹æƒçº§ä¸ä¿æŠ¤ç¯

**x86/x64æ¶æ„çš„ç‰¹æƒçº§**:

```text
Ring 0 (æœ€é«˜ç‰¹æƒçº§)
  â”œâ”€â”€ æ“ä½œç³»ç»Ÿå†…æ ¸ (Kernel Mode)
  â”œâ”€â”€ è®¾å¤‡é©±åŠ¨ç¨‹åº
  â””â”€â”€ Hypervisor (Type 1)

Ring 1 (ä¸­ç­‰ç‰¹æƒçº§)
  â””â”€â”€ ä¼ ç»ŸOS (åœ¨è™šæ‹ŸåŒ–ç¯å¢ƒä¸­)

Ring 2 (ä¸­ç­‰ç‰¹æƒçº§)
  â””â”€â”€ I/Oé©±åŠ¨ç¨‹åº

Ring 3 (æœ€ä½ç‰¹æƒçº§)
  â”œâ”€â”€ ç”¨æˆ·åº”ç”¨ç¨‹åº
  â””â”€â”€ å®¹å™¨è¿›ç¨‹
```

**è™šæ‹ŸåŒ–é¢ä¸´çš„æŒ‘æˆ˜**:

åœ¨æ²¡æœ‰ç¡¬ä»¶è¾…åŠ©è™šæ‹ŸåŒ–çš„æƒ…å†µä¸‹ï¼Œ**Ring Compression Problem**:

```text
ç‰©ç†æœº:
  Ring 0: OS Kernel
  Ring 3: Applications

è™šæ‹ŸåŒ– (æ— ç¡¬ä»¶æ”¯æŒ):
  Ring 0: Hypervisor
  Ring 1: Guest OS Kernel (åŸæœ¬Ring 0æŒ‡ä»¤æ— æ³•æ‰§è¡Œ)
  Ring 3: Guest Applications
```

**æ•æ„ŸæŒ‡ä»¤ (Sensitive Instructions)**:

æ ¹æ®Popek-Goldbergå®šç†ï¼Œx86æ¶æ„å­˜åœ¨**19æ¡æ•æ„Ÿä½†éç‰¹æƒæŒ‡ä»¤**ï¼š

```assembly
; ç¤ºä¾‹ï¼šæ•æ„Ÿä½†éç‰¹æƒæŒ‡ä»¤
SGDT  ; Store Global Descriptor Table Register
SIDT  ; Store Interrupt Descriptor Table Register
SLDT  ; Store Local Descriptor Table Register
SMSW  ; Store Machine Status Word
PUSHF ; Push Flags (åœ¨æŸäº›æƒ…å†µä¸‹)
POPF  ; Pop Flags (åœ¨æŸäº›æƒ…å†µä¸‹)
```

è¿™äº›æŒ‡ä»¤åœ¨Ring 1/3æ‰§è¡Œæ—¶**ä¸ä¼šè§¦å‘å¼‚å¸¸**ï¼Œä½†ä¼šæš´éœ²ç‰¹æƒä¿¡æ¯ï¼Œå¯¼è‡´è™šæ‹ŸåŒ–ä¸é€æ˜ã€‚

#### 1.1.2 Intel VT-x (Virtualization Technology)

**VMX (Virtual Machine Extensions) æ¨¡å¼**:

```text
+-----------------------+
|   VMX Root Mode       | <-- Hypervisorè¿è¡Œæ¨¡å¼
|   (Ring -1)           |
+-----------------------+
          |
          | VM Entry / VM Exit
          v
+-----------------------+
|   VMX Non-Root Mode   | <-- Guest OSè¿è¡Œæ¨¡å¼
|   (Ring 0-3)          |
+-----------------------+
```

**VMCS (Virtual Machine Control Structure)**:

```c
struct vmcs {
    // Guest State Area (å®¢æˆ·æœºçŠ¶æ€)
    struct {
        uint64_t cr0, cr3, cr4;          // æ§åˆ¶å¯„å­˜å™¨
        uint64_t rip, rsp, rflags;       // æŒ‡ä»¤æŒ‡é’ˆã€æ ˆæŒ‡é’ˆã€æ ‡å¿—
        uint64_t gdtr_base, idtr_base;  // æè¿°ç¬¦è¡¨
        uint16_t cs, ds, es, fs, gs, ss; // æ®µé€‰æ‹©å™¨
        // ...
    } guest_state;
    
    // Host State Area (å®¿ä¸»æœºçŠ¶æ€)
    struct {
        uint64_t cr0, cr3, cr4;
        uint64_t rip, rsp;
        // ...
    } host_state;
    
    // VM-Execution Control Fields (VMæ‰§è¡Œæ§åˆ¶)
    struct {
        uint32_t pin_based_controls;     // Pin-Basedæ§åˆ¶
        uint32_t proc_based_controls;    // Processor-Basedæ§åˆ¶
        uint32_t exception_bitmap;       // å¼‚å¸¸ä½å›¾
        uint32_t io_bitmap_a, io_bitmap_b;  // I/Oä½å›¾
        // ...
    } exec_controls;
    
    // VM-Exit Control Fields (VMé€€å‡ºæ§åˆ¶)
    struct {
        uint32_t exit_controls;
        uint32_t exit_msr_store_count;
        uint64_t exit_msr_store_addr;
        // ...
    } exit_controls;
    
    // VM-Entry Control Fields (VMè¿›å…¥æ§åˆ¶)
    struct {
        uint32_t entry_controls;
        uint32_t entry_msr_load_count;
        uint64_t entry_msr_load_addr;
        // ...
    } entry_controls;
    
    // VM-Exit Information Fields (VMé€€å‡ºä¿¡æ¯)
    struct {
        uint32_t exit_reason;            // é€€å‡ºåŸå› 
        uint32_t exit_qualification;     // é€€å‡ºé™å®š
        uint64_t guest_physical_address; // å®¢æˆ·æœºç‰©ç†åœ°å€
        // ...
    } exit_info;
};
```

**VM Entry/Exit æµç¨‹**:

```text
VM Entry (VMLAUNCH/VMRESUME):
  1. ä¿å­˜HostçŠ¶æ€ -> VMCS.host_state
  2. åŠ è½½GuestçŠ¶æ€ <- VMCS.guest_state
  3. åˆ‡æ¢åˆ°VMX Non-Root Mode
  4. ä»Guest RIPå¼€å§‹æ‰§è¡Œ

VM Exit (æ•æ„ŸæŒ‡ä»¤/ä¸­æ–­/å¼‚å¸¸):
  1. ä¿å­˜GuestçŠ¶æ€ -> VMCS.guest_state
  2. è®°å½•ExitåŸå›  -> VMCS.exit_info
  3. åŠ è½½HostçŠ¶æ€ <- VMCS.host_state
  4. åˆ‡æ¢åˆ°VMX Root Mode
  5. è·³è½¬åˆ°Hypervisorå¤„ç†ç¨‹åº
```

**è§¦å‘VM Exitçš„äº‹ä»¶**:

```c
// VM Exit Reasons (éƒ¨åˆ†)
#define EXIT_REASON_EXCEPTION_NMI       0
#define EXIT_REASON_EXTERNAL_INTERRUPT  1
#define EXIT_REASON_TRIPLE_FAULT        2
#define EXIT_REASON_CPUID               10
#define EXIT_REASON_HLT                 12
#define EXIT_REASON_INVD                13
#define EXIT_REASON_INVLPG              14
#define EXIT_REASON_RDPMC               15
#define EXIT_REASON_RDTSC               16
#define EXIT_REASON_VMCALL              18
#define EXIT_REASON_CR_ACCESS           28
#define EXIT_REASON_IO_INSTRUCTION      30
#define EXIT_REASON_MSR_READ            31
#define EXIT_REASON_MSR_WRITE           32
#define EXIT_REASON_EPT_VIOLATION       48
#define EXIT_REASON_EPT_MISCONFIG       49
```

#### 1.1.3 AMD-V (AMD Virtualization)

**SVM (Secure Virtual Machine) æ¶æ„**:

AMD-Vä½¿ç”¨**VMCB (Virtual Machine Control Block)**æ›¿ä»£Intelçš„VMCS:

```c
struct vmcb {
    // Control Area
    struct {
        uint32_t intercept_cr;        // CRè®¿é—®æ‹¦æˆª
        uint32_t intercept_dr;        // DRè®¿é—®æ‹¦æˆª
        uint32_t intercept_exceptions; // å¼‚å¸¸æ‹¦æˆª
        uint32_t intercept_misc;      // æ‚é¡¹æ‹¦æˆª
        uint64_t iopm_base_pa;        // I/Oè®¸å¯ä½å›¾åŸºå€
        uint64_t msrpm_base_pa;       // MSRè®¸å¯ä½å›¾åŸºå€
        uint64_t tsc_offset;          // TSCåç§»
        uint32_t guest_asid;          // å®¢æˆ·æœºASID
        uint8_t  tlb_control;         // TLBæ§åˆ¶
        uint64_t np_enable;           // åµŒå¥—åˆ†é¡µä½¿èƒ½
        uint64_t ncr3;                // åµŒå¥—CR3
        // ...
    } control;
    
    // State Save Area
    struct {
        uint64_t rip, rsp, rflags;
        uint64_t rax, cr0, cr2, cr3, cr4;
        uint64_t dr6, dr7;
        // ...
    } save_state;
};
```

**å…³é”®æŒ‡ä»¤**:

```assembly
VMRUN  ; è¿›å…¥Guestæ¨¡å¼ (ç±»ä¼¼Intelçš„VMRESUME)
VMEXIT ; é€€å‡ºåˆ°Host (è‡ªåŠ¨è§¦å‘)
VMLOAD ; åŠ è½½GuestçŠ¶æ€
VMSAVE ; ä¿å­˜GuestçŠ¶æ€
STGI   ; Set Global Interrupt Flag
CLGI   ; Clear Global Interrupt Flag
```

#### 1.1.4 ARMè™šæ‹ŸåŒ–æ‰©å±•

**ARMv8-A Virtualization Extensions**:

ARMå¼•å…¥**EL (Exception Level)**:

```text
EL3 (Secure Monitor)
  â””â”€â”€ TrustZone Firmware

EL2 (Hypervisor)
  â””â”€â”€ KVMã€Xenç­‰Hypervisor

EL1 (Kernel)
  â””â”€â”€ Guest OS Kernel

EL0 (User)
  â””â”€â”€ Applicationsã€Containers
```

**å…³é”®ç‰¹æ€§**:

- **Stage 2 Translation**: Guestç‰©ç†åœ°å€ -> Hostç‰©ç†åœ°å€
- **Virtual Interrupts**: VGIC (Virtual Generic Interrupt Controller)
- **Trap and Emulate**: æ•æ„ŸæŒ‡ä»¤è‡ªåŠ¨è§¦å‘å¼‚å¸¸åˆ°EL2

### 1.2 å†…å­˜è™šæ‹ŸåŒ–çš„ç¡¬ä»¶æ”¯æŒ

#### 1.2.1 ä¼ ç»Ÿè½¯ä»¶MMU (Shadow Page Table)

**ä¸‰å±‚åœ°å€è½¬æ¢**:

```text
Guest Virtual Address (GVA)
          |
          | Guest Page Table (ç”±Guest OSç®¡ç†)
          v
Guest Physical Address (GPA)
          |
          | Shadow Page Table (ç”±Hypervisorç®¡ç†)
          v
Host Physical Address (HPA)
```

**Shadow Page Tableç»´æŠ¤å¼€é”€**:

```c
// Guestä¿®æ”¹é¡µè¡¨æ—¶è§¦å‘VM Exit
void handle_cr3_write(uint64_t new_cr3) {
    // 1. éå†Guest Page Table
    for (int i = 0; i < NUM_ENTRIES; i++) {
        uint64_t gpa = guest_pt[i].address;
        
        // 2. GPA -> HPAè½¬æ¢
        uint64_t hpa = gpa_to_hpa(gpa);
        
        // 3. æ›´æ–°Shadow Page Table
        shadow_pt[i].address = hpa;
        shadow_pt[i].flags = guest_pt[i].flags;
    }
    
    // 4. åŠ è½½Shadow Page Tableåˆ°CR3
    __write_cr3(shadow_pt_base);
}
```

**æ€§èƒ½é—®é¢˜**:

- **æ¯æ¬¡Guestä¿®æ”¹é¡µè¡¨** -> VM Exit
- **HypervisoråŒæ­¥Shadow Page Table** -> é«˜å¼€é”€
- **TLB Flushé¢‘ç¹** -> æ€§èƒ½ä¸‹é™

#### 1.2.2 Intel EPT (Extended Page Tables)

**ç¡¬ä»¶è¾…åŠ©çš„äºŒç»´é¡µè¡¨**:

```text
Guest Virtual Address (GVA)
          |
          | Guest Page Table (Guest CR3)
          v
Guest Physical Address (GPA)
          |
          | Extended Page Table (EPT, ç”±Hypervisoré…ç½®)
          v
Host Physical Address (HPA)
```

**EPTç»“æ„ (4-Level)**:

```c
// EPT Page Table Entry (64-bit)
struct ept_entry {
    uint64_t read     : 1;   // Bit 0: Read access
    uint64_t write    : 1;   // Bit 1: Write access
    uint64_t execute  : 1;   // Bit 2: Execute access
    uint64_t memory_type : 3; // Bits 3-5: Memory type
    uint64_t ignore_pat : 1;  // Bit 6: Ignore PAT
    uint64_t large_page : 1;  // Bit 7: Large page (2MB/1GB)
    uint64_t accessed   : 1;  // Bit 8: Accessed
    uint64_t dirty      : 1;  // Bit 9: Dirty
    uint64_t user_exec  : 1;  // Bit 10: User-mode execute
    uint64_t reserved1  : 1;  // Bit 11: Reserved
    uint64_t address    : 40; // Bits 12-51: Physical address
    uint64_t reserved2  : 11; // Bits 52-62: Reserved
    uint64_t suppress_ve : 1; // Bit 63: Suppress #VE
};

// EPT 4-Level ç»“æ„
struct ept {
    struct ept_entry pml4[512];   // Page Map Level 4
    struct ept_entry pdpt[512];   // Page Directory Pointer Table
    struct ept_entry pd[512];     // Page Directory
    struct ept_entry pt[512];     // Page Table
};
```

**EPT Walkè¿‡ç¨‹**:

```text
GPA (48-bit)
  â”œâ”€â”€ Bits 47-39: PML4 Index (9 bits)
  â”œâ”€â”€ Bits 38-30: PDPT Index (9 bits)
  â”œâ”€â”€ Bits 29-21: PD Index (9 bits)
  â”œâ”€â”€ Bits 20-12: PT Index (9 bits)
  â””â”€â”€ Bits 11-0:  Page Offset (12 bits)

EPT Walk:
  1. EPTP (EPT Pointer) -> PML4 Base
  2. PML4[Bits 47-39] -> PDPT Base
  3. PDPT[Bits 38-30] -> PD Base
  4. PD[Bits 29-21] -> PT Base
  5. PT[Bits 20-12] -> HPA Frame
  6. HPA = Frame + Offset
```

**EPT Violationå¤„ç†**:

```c
void handle_ept_violation(struct vmcs *vmcs) {
    uint64_t gpa = vmcs->exit_info.guest_physical_address;
    uint32_t qualification = vmcs->exit_info.exit_qualification;
    
    // è§£æè¿è§„ç±»å‹
    bool read_violation = qualification & (1 << 0);
    bool write_violation = qualification & (1 << 1);
    bool exec_violation = qualification & (1 << 2);
    bool ept_readable = qualification & (1 << 3);
    bool ept_writable = qualification & (1 << 4);
    bool ept_executable = qualification & (1 << 5);
    
    if (!ept_readable) {
        // æ˜ å°„ç¼ºå¤±ï¼Œåˆ†é…ç‰©ç†é¡µ
        uint64_t hpa = allocate_physical_page();
        ept_map(gpa, hpa, EPT_READ | EPT_WRITE | EPT_EXEC);
    } else if (write_violation && !ept_writable) {
        // å†™æ—¶å¤åˆ¶ (Copy-on-Write)
        uint64_t old_hpa = ept_lookup(gpa);
        uint64_t new_hpa = copy_page(old_hpa);
        ept_map(gpa, new_hpa, EPT_READ | EPT_WRITE | EPT_EXEC);
    }
}
```

#### 1.2.3 AMD NPT (Nested Page Tables)

AMDçš„NPTä¸Intel EPTåŠŸèƒ½ç±»ä¼¼ï¼Œä½†ç»†èŠ‚æœ‰æ‰€ä¸åŒï¼š

```c
// NPT Page Table Entry
struct npt_entry {
    uint64_t present    : 1;  // Bit 0
    uint64_t writable   : 1;  // Bit 1
    uint64_t user       : 1;  // Bit 2
    uint64_t pwt        : 1;  // Bit 3: Page Write-Through
    uint64_t pcd        : 1;  // Bit 4: Page Cache Disable
    uint64_t accessed   : 1;  // Bit 5
    uint64_t dirty      : 1;  // Bit 6
    uint64_t page_size  : 1;  // Bit 7
    uint64_t ignored    : 4;  // Bits 8-11
    uint64_t address    : 40; // Bits 12-51
    uint64_t reserved   : 11; // Bits 52-62
    uint64_t no_execute : 1;  // Bit 63
};
```

**æ€§èƒ½æ¯”è¾ƒ**:

| ç‰¹æ€§ | Shadow PT | EPT/NPT |
|------|-----------|---------|
| **Guesté¡µè¡¨ä¿®æ”¹** | VM Exit (é«˜å¼€é”€) | æ— éœ€VM Exit |
| **é¡µè¡¨åŒæ­¥** | Hypervisoræ‰‹åŠ¨åŒæ­¥ | ç¡¬ä»¶è‡ªåŠ¨Walk |
| **TLBæ ‡è®°** | éœ€è¦VPID/ASID | ç¡¬ä»¶æ”¯æŒ |
| **å†…å­˜å¼€é”€** | Shadow PTå ç”¨å†…å­˜ | EPT/NPTå ç”¨å†…å­˜ |
| **æ€§èƒ½** | è¾ƒå·® (é¢‘ç¹VM Exit) | ä¼˜ç§€ (ç¡¬ä»¶åŠ é€Ÿ) |

#### 1.2.4 å†…å­˜è™šæ‹ŸåŒ–çš„å½¢å¼åŒ–æ¨¡å‹

**åœ°å€ç©ºé—´çš„æŠ½è±¡**:

```haskell
-- åœ°å€ç©ºé—´çš„ç±»å‹å®šä¹‰
data AddressSpace = AS {
    mapping :: Address -> Maybe PhysicalFrame,
    permissions :: Address -> Permissions
}

data Permissions = Perms {
    readable :: Bool,
    writable :: Bool,
    executable :: Bool
}

-- è™šæ‹ŸåŒ–ç¯å¢ƒçš„åœ°å€ç©ºé—´å±‚æ¬¡
data VirtualizedSystem = VirtSys {
    host_as :: AddressSpace,           -- Hoståœ°å€ç©ºé—´
    guest_as :: [AddressSpace],        -- Gueståœ°å€ç©ºé—´åˆ—è¡¨
    ept :: GPA -> Maybe HPA            -- EPTæ˜ å°„å‡½æ•°
}

-- EPTæ˜ å°„çš„æ­£ç¡®æ€§çº¦æŸ
ept_correctness :: VirtualizedSystem -> Bool
ept_correctness sys =
    -- 1. EPTæ˜ å°„çš„å•å°„æ€§ (Injectivity)
    injective (ept sys) &&
    -- 2. Guestç‰©ç†åœ°å€ä¸é‡å 
    disjoint_guest_physical_spaces (guest_as sys) &&
    -- 3. Hostç‰©ç†åœ°å€åœ¨æœ‰æ•ˆèŒƒå›´å†…
    all (in_host_range (host_as sys)) (range (ept sys))
```

### 1.3 I/Oè™šæ‹ŸåŒ–çš„ç¡¬ä»¶æ”¯æŒ

#### 1.3.1 ä¼ ç»ŸI/Oè™šæ‹ŸåŒ– (è½¯ä»¶æ¨¡æ‹Ÿ)

**è®¾å¤‡æ¨¡æ‹Ÿæµç¨‹**:

```text
Guest Driver
     |
     | I/OæŒ‡ä»¤ (OUT/IN) æˆ– MMIOè®¿é—®
     v
   VM Exit  <-- è§¦å‘é€€å‡ºåˆ°Hypervisor
     |
     v
Hypervisor Device Emulation
     |
     | æ¨¡æ‹Ÿè®¾å¤‡è¡Œä¸º
     v
Physical Device Driver
     |
     v
Physical Device
```

**æ€§èƒ½å¼€é”€**:

```c
// æ¯æ¬¡I/Oæ“ä½œçš„å¼€é”€
uint32_t emulated_io_read(uint16_t port) {
    vm_exit();                    // ~1000 cycles
    hypervisor_emulate_device();  // ~500 cycles
    physical_device_access();     // ~100 cycles
    vm_entry();                   // ~1000 cycles
    return value;
}
// Total: ~2600 cycles per I/O operation
```

#### 1.3.2 Intel VT-d (Virtualization Technology for Directed I/O)

**IOMMU (I/O Memory Management Unit) æ¶æ„**:

```text
Device
  |
  | DMAè¯·æ±‚ (ä½¿ç”¨Bus/Device/Functionæ ‡è¯†)
  v
IOMMU
  |
  | åœ°å€è½¬æ¢: Device Address -> Host Physical Address
  | æƒé™æ£€æŸ¥: è®¾å¤‡æ˜¯å¦å…è®¸è®¿é—®è¯¥å†…å­˜åŒºåŸŸ
  v
Physical Memory
```

**DMA Remapping Tableç»“æ„**:

```c
// Root Table (256 entries, æ¯ä¸ªBusä¸€ä¸ª)
struct dmar_root_entry {
    uint64_t context_table_ptr : 52;  // Context Tableç‰©ç†åœ°å€
    uint64_t reserved          : 11;
    uint64_t present           : 1;
};

// Context Table (256 entries, æ¯ä¸ªDeviceä¸€ä¸ª)
struct dmar_context_entry {
    uint64_t present           : 1;
    uint64_t fault_processing_disable : 1;
    uint64_t translation_type  : 2;   // 0: ç¦ç”¨, 1: ä»…è½¬æ¢, 2: ç›´é€š
    uint64_t address_width     : 3;   // Gueståœ°å€å®½åº¦
    uint64_t ignored           : 5;
    uint64_t second_level_ptr  : 52;  // é¡µè¡¨åŸºå€ (ç±»ä¼¼EPT)
    // Second Entry...
    uint64_t address_space_root : 52; // åœ°å€ç©ºé—´æ ¹
    uint64_t reserved2         : 11;
    uint64_t domain_id         : 1;   // åŸŸæ ‡è¯†
};

// Second-Level Page Table (ç±»ä¼¼EPTç»“æ„)
struct dmar_pte {
    uint64_t read      : 1;
    uint64_t write     : 1;
    uint64_t execute   : 1;  // æŸäº›IOMMUæ”¯æŒ
    uint64_t reserved  : 9;
    uint64_t address   : 40;
    uint64_t reserved2 : 12;
};
```

**VT-då…³é”®ç‰¹æ€§**:

1. **DMA Remapping**: è®¾å¤‡DMAåœ°å€éš”ç¦»
2. **Interrupt Remapping**: ä¸­æ–­é‡æ˜ å°„ï¼Œé˜²æ­¢ä¸­æ–­æ³¨å…¥æ”»å‡»
3. **Fault Recording**: DMAè®¿é—®è¿è§„è®°å½•
4. **Device Assignment**: è®¾å¤‡ç›´æ¥åˆ†é…ç»™VM (PCI Passthrough)

#### 1.3.3 SR-IOV (Single Root I/O Virtualization)

**æ¶æ„**:

```text
Physical Function (PF)
  â”œâ”€â”€ Virtual Function 1 (VF1) -> VM1
  â”œâ”€â”€ Virtual Function 2 (VF2) -> VM2
  â”œâ”€â”€ Virtual Function 3 (VF3) -> VM3
  â””â”€â”€ ...

æ¯ä¸ªVFæœ‰ç‹¬ç«‹çš„:
  - PCIé…ç½®ç©ºé—´
  - BAR (Base Address Registers)
  - MSI-Xä¸­æ–­å‘é‡
  - DMAå¼•æ“
```

**SR-IOVé…ç½®æµç¨‹**:

```c
// å¯ç”¨SR-IOV
void enable_sriov(struct pci_dev *pf_dev, int num_vfs) {
    // 1. è¯»å–SR-IOV Capability
    int pos = pci_find_ext_capability(pf_dev, PCI_EXT_CAP_ID_SRIOV);
    
    // 2. é…ç½®VFæ•°é‡
    pci_write_config_word(pf_dev, pos + PCI_SRIOV_NUM_VF, num_vfs);
    
    // 3. é…ç½®VF BAR
    pci_write_config_dword(pf_dev, pos + PCI_SRIOV_BAR, vf_bar_address);
    
    // 4. å¯ç”¨SR-IOV
    uint16_t ctrl;
    pci_read_config_word(pf_dev, pos + PCI_SRIOV_CTRL, &ctrl);
    ctrl |= PCI_SRIOV_CTRL_VFE | PCI_SRIOV_CTRL_MSE;
    pci_write_config_word(pf_dev, pos + PCI_SRIOV_CTRL, ctrl);
    
    // 5. VFç°åœ¨å¯ä»¥åˆ†é…ç»™VM
    for (int i = 0; i < num_vfs; i++) {
        struct pci_dev *vf = get_vf_device(pf_dev, i);
        assign_device_to_vm(vf, vm_list[i]);
    }
}
```

**æ€§èƒ½æå‡**:

```text
ä¼ ç»Ÿæ¨¡æ‹Ÿç½‘å¡:
  ~1 Gbps, ~50% CPUå¼€é”€

Para-virtualized (virtio):
  ~10 Gbps, ~20% CPUå¼€é”€

SR-IOV:
  ~40+ Gbps, <5% CPUå¼€é”€
  æ¥è¿‘ç‰©ç†è®¾å¤‡æ€§èƒ½
```

#### 1.3.4 VFIO (Virtual Function I/O)

**ç”¨æˆ·æ€è®¾å¤‡é©±åŠ¨æ¡†æ¶**:

```c
// VFIOä½¿ç”¨æµç¨‹ (åœ¨QEMU/KVMä¸­)
int vfio_setup(const char *device_id) {
    // 1. æ‰“å¼€VFIOå®¹å™¨
    int container = open("/dev/vfio/vfio", O_RDWR);
    
    // 2. æ‰“å¼€IOMMUç»„
    char group_path[64];
    snprintf(group_path, sizeof(group_path), "/dev/vfio/%s", device_id);
    int group = open(group_path, O_RDWR);
    
    // 3. æ·»åŠ ç»„åˆ°å®¹å™¨
    ioctl(group, VFIO_GROUP_SET_CONTAINER, &container);
    
    // 4. è®¾ç½®IOMMUç±»å‹
    ioctl(container, VFIO_SET_IOMMU, VFIO_TYPE1_IOMMU);
    
    // 5. è·å–è®¾å¤‡æ–‡ä»¶æè¿°ç¬¦
    int device = ioctl(group, VFIO_GROUP_GET_DEVICE_FD, device_id);
    
    // 6. æ˜ å°„è®¾å¤‡BARåˆ°ç”¨æˆ·ç©ºé—´
    struct vfio_region_info region_info = {
        .argsz = sizeof(region_info),
        .index = VFIO_PCI_BAR0_REGION_INDEX
    };
    ioctl(device, VFIO_DEVICE_GET_REGION_INFO, &region_info);
    
    void *bar = mmap(NULL, region_info.size, PROT_READ | PROT_WRITE,
                     MAP_SHARED, device, region_info.offset);
    
    // 7. è®¾ç½®DMAæ˜ å°„
    struct vfio_iommu_type1_dma_map dma_map = {
        .argsz = sizeof(dma_map),
        .vaddr = guest_virtual_address,
        .iova = device_address,
        .size = dma_size,
        .flags = VFIO_DMA_MAP_FLAG_READ | VFIO_DMA_MAP_FLAG_WRITE
    };
    ioctl(container, VFIO_IOMMU_MAP_DMA, &dma_map);
    
    return device;
}
```

### 1.4 ç¡¬ä»¶è™šæ‹ŸåŒ–çš„å½¢å¼åŒ–æ¨¡å‹

#### 1.4.1 è™šæ‹ŸåŒ–çš„æŠ½è±¡çŠ¶æ€æœº

```haskell
-- ç‰©ç†æœºçŠ¶æ€
data PhysicalMachine = PM {
    cpu_state :: CPUState,
    memory :: Memory,
    devices :: [Device]
}

data CPUState = CPUState {
    registers :: Registers,
    privilege_level :: PrivilegeLevel,
    control_registers :: ControlRegs
}

-- HypervisorçŠ¶æ€
data Hypervisor = HV {
    physical_machine :: PhysicalMachine,
    virtual_machines :: [VirtualMachine],
    vmcs_list :: [VMCS]
}

-- è™šæ‹ŸæœºçŠ¶æ€
data VirtualMachine = VM {
    vcpu_state :: CPUState,
    guest_memory :: AddressSpace,
    virtual_devices :: [VirtualDevice],
    vmcs :: VMCS
}

-- çŠ¶æ€è½¬æ¢
data Transition =
    VmEntry VMCS          -- VM Entryè½¬æ¢
  | VmExit ExitReason VMCS -- VM Exitè½¬æ¢
  | GuestInstruction Instruction -- Guestæ‰§è¡ŒæŒ‡ä»¤
  | HostInstruction Instruction  -- Hostæ‰§è¡ŒæŒ‡ä»¤

-- è½¬æ¢å‡½æ•°
transition :: Hypervisor -> Transition -> Hypervisor
transition hv (VmEntry vmcs) =
    hv { physical_machine = load_guest_state vmcs }
transition hv (VmExit reason vmcs) =
    hv { physical_machine = load_host_state vmcs,
         vmcs_list = update_exit_info vmcs reason }
transition hv (GuestInstruction inst) =
    if is_sensitive inst
    then transition hv (VmExit (SensitiveInstruction inst) current_vmcs)
    else execute_instruction hv inst
```

#### 1.4.2 EPTçš„å½¢å¼åŒ–å®šä¹‰

```coq
(* Coqå½¢å¼åŒ–å®šä¹‰ *)

(* åœ°å€ç±»å‹ *)
Definition GVA := nat.  (* Guest Virtual Address *)
Definition GPA := nat.  (* Guest Physical Address *)
Definition HPA := nat.  (* Host Physical Address *)

(* é¡µè¡¨ç±»å‹ *)
Definition PageTable := GVA -> option GPA.
Definition EPT := GPA -> option HPA.

(* å®Œæ•´çš„åœ°å€è½¬æ¢ *)
Definition full_translation (pt: PageTable) (ept: EPT) (gva: GVA) : option HPA :=
  match pt gva with
  | None => None
  | Some gpa => ept gpa
  end.

(* EPTçš„æ­£ç¡®æ€§æ€§è´¨ *)

(* 1. EPTå¿…é¡»æ˜¯å•å°„çš„ (ä¸åŒGPAæ˜ å°„åˆ°ä¸åŒHPA) *)
Definition ept_injective (ept: EPT) : Prop :=
  forall gpa1 gpa2 hpa,
    ept gpa1 = Some hpa ->
    ept gpa2 = Some hpa ->
    gpa1 = gpa2.

(* 2. EPTæ˜ å°„çš„HPAå¿…é¡»åœ¨æœ‰æ•ˆç‰©ç†å†…å­˜èŒƒå›´å†… *)
Definition ept_valid_range (ept: EPT) (max_hpa: HPA) : Prop :=
  forall gpa hpa,
    ept gpa = Some hpa ->
    hpa < max_hpa.

(* 3. VMä¹‹é—´çš„EPTéš”ç¦»æ€§ *)
Definition ept_isolation (ept1 ept2: EPT) : Prop :=
  forall gpa1 gpa2 hpa,
    ept1 gpa1 = Some hpa ->
    ept2 gpa2 = Some hpa ->
    False.  (* ä¸å¯èƒ½æœ‰ç›¸åŒçš„HPA *)

(* å®šç†ï¼šå¦‚æœEPTæ»¡è¶³ä¸Šè¿°æ€§è´¨ï¼Œåˆ™å†…å­˜éš”ç¦»å¾—åˆ°ä¿è¯ *)
Theorem ept_guarantees_isolation :
  forall (ept1 ept2: EPT) (max_hpa: HPA),
    ept_injective ept1 ->
    ept_injective ept2 ->
    ept_valid_range ept1 max_hpa ->
    ept_valid_range ept2 max_hpa ->
    ept_isolation ept1 ept2 ->
    (* å†…å­˜éš”ç¦»æ€§è´¨å¾—åˆ°æ»¡è¶³ *)
    True.
Proof.
  (* è¯æ˜çœç•¥ï¼Œä½†å¯ä»¥é€šè¿‡æ„é€ æ€§è¯æ˜å®Œæˆ *)
Admitted.
```

---

## ç¬¬äºŒéƒ¨åˆ†ï¼šæ“ä½œç³»ç»Ÿå±‚é¢çš„å®¹å™¨åŒ–æŠ€æœ¯ç»“æ„

### 2.1 Linux Namespaceçš„å†…æ ¸å®ç°

#### 2.1.1 Namespaceçš„å†…æ ¸æ•°æ®ç»“æ„

```c
// include/linux/nsproxy.h
struct nsproxy {
    atomic_t count;
    struct uts_namespace *uts_ns;      // UTS: hostnameå’Œdomainname
    struct ipc_namespace *ipc_ns;      // IPC: System V IPCå’ŒPOSIXæ¶ˆæ¯é˜Ÿåˆ—
    struct mnt_namespace *mnt_ns;      // Mount: æ–‡ä»¶ç³»ç»ŸæŒ‚è½½ç‚¹
    struct pid_namespace *pid_ns_for_children; // PID: è¿›ç¨‹ID
    struct net *net_ns;                // Network: ç½‘ç»œæ ˆ
    struct cgroup_namespace *cgroup_ns; // Cgroup: cgroupæ ¹ç›®å½•
    struct time_namespace *time_ns;    // Time: æ—¶é’Ÿå’Œå®šæ—¶å™¨
    struct time_namespace *time_ns_for_children;
};

// include/linux/sched.h
struct task_struct {
    // ...
    struct nsproxy *nsproxy;  // æŒ‡å‘å½“å‰è¿›ç¨‹çš„namespaceé›†åˆ
    // ...
};
```

#### 2.1.2 PID Namespaceçš„å®ç°

```c
// include/linux/pid_namespace.h
struct pid_namespace {
    struct kref kref;
    struct idr idr;                   // PIDåˆ†é…å™¨
    struct rcu_head rcu;
    unsigned int pid_allocated;       // å·²åˆ†é…çš„PIDæ•°é‡
    struct task_struct *child_reaper; // initè¿›ç¨‹ (PID 1)
    struct kmem_cache *pid_cachep;    // PIDå¯¹è±¡ç¼“å­˜
    unsigned int level;               // Namespaceå±‚çº§
    struct pid_namespace *parent;     // çˆ¶Namespace
    struct vfsmount *proc_mnt;        // /procæŒ‚è½½ç‚¹
    // ...
};

// PIDç»“æ„ (æ”¯æŒå¤šå±‚Namespace)
struct pid {
    atomic_t count;
    unsigned int level;               // æ‰€åœ¨çš„namespaceå±‚çº§
    struct hlist_head tasks[PIDTYPE_MAX];
    struct rcu_head rcu;
    struct upid numbers[1];           // æ¯å±‚namespaceä¸­çš„PID
};

struct upid {
    int nr;                           // åœ¨è¯¥namespaceä¸­çš„PID
    struct pid_namespace *ns;         // æ‰€å±namespace
    struct hlist_node pid_chain;      // å“ˆå¸Œé“¾è¡¨èŠ‚ç‚¹
};
```

**PIDè½¬æ¢ç¤ºä¾‹**:

```text
Host Namespace (level 0)
  PID 1000 -> Container Init Process
      |
      | spawn
      v
Container Namespace (level 1)
  PID 1 (init) -> å¯¹åº”Hostçš„PID 1000
  PID 2 (bash) -> å¯¹åº”Hostçš„PID 1001
  PID 3 (app) -> å¯¹åº”Hostçš„PID 1002
```

```c
// è·å–è¿›ç¨‹åœ¨ç‰¹å®šnamespaceä¸­çš„PID
pid_t pid_nr_ns(struct pid *pid, struct pid_namespace *ns) {
    struct upid *upid;
    pid_t nr = 0;
    
    if (pid && ns->level <= pid->level) {
        upid = &pid->numbers[ns->level];
        if (upid->ns == ns)
            nr = upid->nr;
    }
    return nr;
}

// å½“å‰è¿›ç¨‹çœ‹åˆ°çš„PID (åœ¨å½“å‰namespaceä¸­)
static inline pid_t task_pid_vnr(struct task_struct *tsk) {
    return pid_nr_ns(task_pid(tsk), task_active_pid_ns(tsk));
}
```

#### 2.1.3 Network Namespaceçš„å®ç°

```c
// include/net/net_namespace.h
struct net {
    atomic_t passive;
    atomic_t count;
    spinlock_t rules_mod_lock;
    
    struct list_head list;              // æ‰€æœ‰namespaceçš„é“¾è¡¨
    struct list_head cleanup_list;
    struct list_head exit_list;
    
    struct user_namespace *user_ns;     // å…³è”çš„user namespace
    struct idr netns_ids;
    
    struct ns_common ns;
    
    // ç½‘ç»œåè®®æ ˆç»„ä»¶
    struct net_device *loopback_dev;    // loè®¾å¤‡
    struct netns_ipv4 ipv4;             // IPv4åè®®æ ˆ
    struct netns_ipv6 ipv6;             // IPv6åè®®æ ˆ
    struct netns_packet packet;         // packetåè®®
    struct netns_unix unix_sockets;     // Unix domain socket
    struct netns_xt xt;                 // iptables/netfilter
    
    // è·¯ç”±è¡¨
    struct netns_frags frags;
    struct fib_table *fib_table_hash[RT_TABLE_MAX];
    
    // å¥—æ¥å­—
    struct sock *rtnl;                  // rtnetlinkå¥—æ¥å­—
    struct sock *genl_sock;             // Generic netlinkå¥—æ¥å­—
    
    // ... æ›´å¤šç½‘ç»œç»„ä»¶
};
```

**åˆ›å»ºæ–°çš„Network Namespace**:

```c
// net/core/net_namespace.c
static struct net *net_alloc(void) {
    struct net *net = kmalloc(sizeof(struct net), GFP_KERNEL);
    if (!net)
        return NULL;
    
    // åˆå§‹åŒ–ç½‘ç»œå‘½åç©ºé—´
    net->dev_base_seq = 1;
    INIT_LIST_HEAD(&net->dev_base_head);
    
    // åˆ›å»ºloopbackè®¾å¤‡
    net->loopback_dev = alloc_netdev(0, "lo", NET_NAME_UNKNOWN, loopback_setup);
    
    // åˆå§‹åŒ–IPv4
    if (ipv4_sysctl_register(net) < 0)
        goto out_free;
    
    // åˆå§‹åŒ–è·¯ç”±è¡¨
    if (ip_rt_init(net) < 0)
        goto out_ipv4;
    
    // åˆå§‹åŒ–iptables
    if (netfilter_net_init(net) < 0)
        goto out_rt;
    
    return net;
}
```

#### 2.1.4 Mount Namespaceçš„å®ç°

```c
// fs/mount.h
struct mnt_namespace {
    atomic_t count;
    struct ns_common ns;
    struct mount *root;               // æ ¹æŒ‚è½½ç‚¹
    struct list_head list;            // æ‰€æœ‰æŒ‚è½½ç‚¹åˆ—è¡¨
    struct user_namespace *user_ns;
    struct ucounts *ucounts;
    u64 seq;                          // åºåˆ—å·
    wait_queue_head_t poll;
    u64 event;
};

struct mount {
    struct hlist_node mnt_hash;
    struct mount *mnt_parent;         // çˆ¶æŒ‚è½½ç‚¹
    struct dentry *mnt_mountpoint;    // æŒ‚è½½ç‚¹ç›®å½•é¡¹
    struct vfsmount mnt;
    union {
        struct rcu_head mnt_rcu;
        struct llist_node mnt_llist;
    };
    struct list_head mnt_mounts;      // å­æŒ‚è½½ç‚¹åˆ—è¡¨
    struct list_head mnt_child;       // å…„å¼ŸæŒ‚è½½ç‚¹é“¾è¡¨
    struct list_head mnt_instance;
    const char *mnt_devname;          // è®¾å¤‡å
    struct list_head mnt_list;
    // ...
};
```

**æŒ‚è½½ä¼ æ’­** (Mount Propagation):

```c
// æŒ‚è½½ä¼ æ’­ç±»å‹
#define MS_SHARED       (1<<20)  // å…±äº«æŒ‚è½½
#define MS_PRIVATE      (1<<18)  // ç§æœ‰æŒ‚è½½
#define MS_SLAVE        (1<<19)  // ä»å±æŒ‚è½½
#define MS_UNBINDABLE   (1<<17)  // ä¸å¯ç»‘å®šæŒ‚è½½

// è®¾ç½®æŒ‚è½½ä¼ æ’­ç±»å‹
long do_mount(const char *dev_name, const char *dir_name,
              const char *type_page, unsigned long flags, void *data_page) {
    // ...
    if (flags & MS_SHARED)
        change_mnt_propagation(real_mount(path.mnt), MS_SHARED);
    else if (flags & MS_PRIVATE)
        change_mnt_propagation(real_mount(path.mnt), MS_PRIVATE);
    // ...
}
```

**ç¤ºä¾‹**:

```bash
# Hostä¸Šçš„æŒ‚è½½
mount --make-shared /mnt/shared

# åœ¨å®¹å™¨ä¸­
unshare --mount /bin/bash
# å®¹å™¨å†…çš„æŒ‚è½½ä¼šä¼ æ’­åˆ°Host (å¦‚æœæ˜¯shared)
# æˆ–è€…ä¸ä¼ æ’­ (å¦‚æœæ˜¯private)
```

#### 2.1.5 Namespaceåˆ›å»ºä¸åˆ‡æ¢çš„ç³»ç»Ÿè°ƒç”¨

```c
// ç³»ç»Ÿè°ƒç”¨æ¥å£

// 1. clone() - åˆ›å»ºæ–°è¿›ç¨‹å¹¶å¯é€‰åœ°åˆ›å»ºæ–°namespace
long sys_clone(unsigned long clone_flags, unsigned long newsp,
               int __user *parent_tidptr, int __user *child_tidptr,
               unsigned long tls) {
    // clone_flagså¯åŒ…å«:
    // CLONE_NEWNS   - æ–°çš„Mount namespace
    // CLONE_NEWPID  - æ–°çš„PID namespace
    // CLONE_NEWNET  - æ–°çš„Network namespace
    // CLONE_NEWUTS  - æ–°çš„UTS namespace
    // CLONE_NEWIPC  - æ–°çš„IPC namespace
    // CLONE_NEWUSER - æ–°çš„User namespace
    // CLONE_NEWCGROUP - æ–°çš„Cgroup namespace
    // CLONE_NEWTIME - æ–°çš„Time namespace
    
    return _do_fork(clone_flags, newsp, 0, parent_tidptr,
                    child_tidptr, tls);
}

// 2. unshare() - åœ¨å½“å‰è¿›ç¨‹ä¸­åˆ›å»ºæ–°namespace
long sys_unshare(unsigned long unshare_flags) {
    struct nsproxy *new_nsproxy;
    int err;
    
    // ä¸èƒ½unshareçš„flags
    if (unshare_flags & ~(CLONE_THREAD|CLONE_FS|CLONE_NEWNS|
                          CLONE_NEWUTS|CLONE_NEWIPC|CLONE_NEWNET|
                          CLONE_NEWUSER|CLONE_NEWPID|CLONE_NEWCGROUP|
                          CLONE_NEWTIME))
        return -EINVAL;
    
    // å¤åˆ¶nsproxy
    err = unshare_nsproxy_namespaces(unshare_flags, &new_nsproxy,
                                     current_cred(), current->files);
    if (err)
        return err;
    
    // åˆ‡æ¢åˆ°æ–°çš„nsproxy
    switch_task_namespaces(current, new_nsproxy);
    
    return 0;
}

// 3. setns() - åŠ å…¥ç°æœ‰çš„namespace
long sys_setns(int fd, int nstype) {
    struct fd f = fdget(fd);
    struct ns_common *ns;
    int err;
    
    if (!f.file)
        return -EBADF;
    
    ns = get_proc_ns(file_inode(f.file));
    
    // éªŒè¯namespaceç±»å‹
    if (nstype && (ns->ops->type != nstype)) {
        err = -EINVAL;
        goto out;
    }
    
    // åŠ å…¥namespace
    err = ns->ops->install(current, ns);
    
out:
    fdput(f);
    return err;
}
```

**ä½¿ç”¨ç¤ºä¾‹**:

```c
// åˆ›å»ºå®¹å™¨è¿›ç¨‹
int create_container() {
    // å‡†å¤‡flags
    int flags = CLONE_NEWNS | CLONE_NEWPID | CLONE_NEWNET |
                CLONE_NEWUTS | CLONE_NEWIPC | CLONE_NEWUSER;
    
    // åˆ›å»ºå­è¿›ç¨‹å¹¶è¿›å…¥æ–°çš„namespace
    pid_t pid = clone(container_init, stack + STACK_SIZE, flags | SIGCHLD, NULL);
    
    return pid;
}

int container_init(void *arg) {
    // ç°åœ¨åœ¨æ–°çš„namespaceä¸­
    
    // æŒ‚è½½æ–°çš„/proc
    mount("proc", "/proc", "proc", 0, NULL);
    
    // è®¾ç½®hostname
    sethostname("container", 9);
    
    // å¯åŠ¨initè¿›ç¨‹
    exec("/sbin/init");
}
```

### 2.2 Cgroupsçš„èµ„æºéš”ç¦»æœºåˆ¶

#### 2.2.1 Cgroup v1æ¶æ„

```c
// include/linux/cgroup-defs.h

// Cgroupç»“æ„
struct cgroup {
    struct cgroup_subsys_state self;  // cgroupè‡ªèº«çš„çŠ¶æ€
    
    unsigned long flags;
    int id;
    int level;                        // åœ¨å±‚çº§ä¸­çš„æ·±åº¦
    
    int populated_cnt;
    struct kernfs_node *kn;           // kernfsèŠ‚ç‚¹ (å¯¹åº”/sys/fs/cgroupä¸‹çš„ç›®å½•)
    struct kernfs_node *procs_kn;     // cgroup.procsæ–‡ä»¶
    struct kernfs_node *populated_kn;
    
    // çˆ¶å­å…³ç³»
    struct cgroup *parent;
    struct list_head sibling;
    struct list_head children;
    
    // å…³è”çš„task
    struct list_head tasks;
    
    // subsystemçŠ¶æ€
    struct cgroup_subsys_state *subsys[CGROUP_SUBSYS_COUNT];
    
    struct cgroup_root *root;
    // ...
};

// Subsystem (å­ç³»ç»Ÿ)
struct cgroup_subsys {
    struct cgroup_subsys_state *(*css_alloc)(struct cgroup_subsys_state *parent_css);
    int (*css_online)(struct cgroup_subsys_state *css);
    void (*css_offline)(struct cgroup_subsys_state *css);
    void (*css_free)(struct cgroup_subsys_state *css);
    
    int (*can_attach)(struct cgroup_taskset *tset);
    void (*attach)(struct cgroup_taskset *tset);
    void (*fork)(struct task_struct *task);
    void (*exit)(struct task_struct *task);
    
    // ...
};
```

**Cgroup v1çš„Subsystems**:

```text
/sys/fs/cgroup/
  â”œâ”€â”€ cpu/            # CPUæ—¶é—´åˆ†é…
  â”œâ”€â”€ cpuacct/        # CPUä½¿ç”¨ç»Ÿè®¡
  â”œâ”€â”€ cpuset/         # CPUå’Œå†…å­˜èŠ‚ç‚¹åˆ†é…
  â”œâ”€â”€ memory/         # å†…å­˜é™åˆ¶
  â”œâ”€â”€ blkio/          # å—è®¾å¤‡I/Oé™åˆ¶
  â”œâ”€â”€ devices/        # è®¾å¤‡è®¿é—®æ§åˆ¶
  â”œâ”€â”€ freezer/        # å†»ç»“/è§£å†»cgroup
  â”œâ”€â”€ net_cls/        # ç½‘ç»œåˆ†ç±»æ ‡è®°
  â”œâ”€â”€ net_prio/       # ç½‘ç»œä¼˜å…ˆçº§
  â”œâ”€â”€ pids/           # è¿›ç¨‹æ•°é‡é™åˆ¶
  â””â”€â”€ ...
```

#### 2.2.2 CPUæ§åˆ¶å™¨ (cpu, cpuacct)

```c
// kernel/sched/core.c

// CPU cgroupçŠ¶æ€
struct task_group {
    struct cgroup_subsys_state css;
    
    // CFS (Completely Fair Scheduler)
    struct sched_entity **se;          // è°ƒåº¦å®ä½“ (æ¯CPUä¸€ä¸ª)
    struct cfs_rq **cfs_rq;            // CFSè¿è¡Œé˜Ÿåˆ—
    unsigned long shares;              // CPUä»½é¢ (æƒé‡)
    
    // Real-Time
    struct sched_rt_entity **rt_se;
    struct rt_rq **rt_rq;
    struct rt_bandwidth rt_bandwidth;  // RTå¸¦å®½é™åˆ¶
    
    // Bandwidth Control (CFSå¸¦å®½æ§åˆ¶)
    struct cfs_bandwidth cfs_bandwidth;
    
    struct rcu_head rcu;
    struct list_head list;
    
    struct task_group *parent;
    struct list_head siblings;
    struct list_head children;
    // ...
};

// CFSå¸¦å®½æ§åˆ¶
struct cfs_bandwidth {
    raw_spinlock_t lock;
    ktime_t period;                    // å‘¨æœŸ (é»˜è®¤100ms)
    u64 quota;                         // é…é¢ (us)
    u64 runtime;                       // å‰©ä½™è¿è¡Œæ—¶é—´
    s64 hierarchical_quota;
    
    u8 idle, period_active, slack_started;
    struct hrtimer period_timer;       // å‘¨æœŸå®šæ—¶å™¨
    struct hrtimer slack_timer;
    struct list_head throttled_cfs_rq; // è¢«é™æµçš„é˜Ÿåˆ—
    
    int nr_periods;                    // ç»Ÿè®¡ï¼šå‘¨æœŸæ•°
    int nr_throttled;                  // ç»Ÿè®¡ï¼šè¢«é™æµæ¬¡æ•°
    u64 throttled_time;                // ç»Ÿè®¡ï¼šé™æµæ—¶é—´
};
```

**CPUä»½é¢è®¡ç®—**:

```text
è¿›ç¨‹çš„CPUæ—¶é—´ = (cgroupçš„shares / æ€»shares) Ã— æ€»CPUæ—¶é—´

ç¤ºä¾‹:
  cgroup A: shares=1024, 1ä¸ªè¿›ç¨‹
  cgroup B: shares=512,  2ä¸ªè¿›ç¨‹
  cgroup C: shares=2048, 1ä¸ªè¿›ç¨‹
  
  æ€»shares = 1024 + 512 + 2048 = 3584
  
  å•æ ¸CPU:
    A: (1024/3584) Ã— 100% â‰ˆ 28.6%
    B: (512/3584) Ã— 100% â‰ˆ 14.3%
    C: (2048/3584) Ã— 100% â‰ˆ 57.1%
```

**CPUé…é¢ç¤ºä¾‹**:

```bash
# é™åˆ¶cgroupæœ€å¤šä½¿ç”¨50% CPU (å•æ ¸)
echo 50000 > /sys/fs/cgroup/cpu/mycontainer/cpu.cfs_quota_us
echo 100000 > /sys/fs/cgroup/cpu/mycontainer/cpu.cfs_period_us
# quota/period = 50000/100000 = 0.5 = 50%

# æˆ–è€…è®¾ç½®CPUä»½é¢
echo 512 > /sys/fs/cgroup/cpu/mycontainer/cpu.shares
```

#### 2.2.3 Memoryæ§åˆ¶å™¨

```c
// mm/memcontrol.c

struct mem_cgroup {
    struct cgroup_subsys_state css;
    
    // å†…å­˜é™åˆ¶
    struct page_counter memory;        // å†…å­˜é™åˆ¶è®¡æ•°å™¨
    struct page_counter swap;          // swapé™åˆ¶
    struct page_counter memsw;         // memory+swapé™åˆ¶
    struct page_counter kmem;          // å†…æ ¸å†…å­˜é™åˆ¶
    struct page_counter tcpmem;        // TCPç¼“å†²åŒºé™åˆ¶
    
    // OOM (Out-of-Memory) æ§åˆ¶
    unsigned long soft_limit;          // è½¯é™åˆ¶
    atomic_t oom_lock;
    int oom_kill_disable;
    
    // ç»Ÿè®¡ä¿¡æ¯
    struct mem_cgroup_stat_cpu __percpu *stat_cpu;
    atomic_long_t stat[MEMCG_NR_STAT];
    atomic_long_t events[MEMCG_NR_EVENTS];
    
    // å›æ”¶
    unsigned long low, high;           // ä½/é«˜æ°´ä½çº¿
    struct work_struct high_work;
    
    // LRU (Least Recently Used)
    struct mem_cgroup_lru_info lru_info;
    
    // çˆ¶å­å…³ç³»
    struct mem_cgroup *parent;
    // ...
};

// é¡µé¢è®¡æ•°å™¨
struct page_counter {
    atomic_long_t usage;               // å½“å‰ä½¿ç”¨é‡
    unsigned long max;                 // æœ€å¤§é™åˆ¶
    struct page_counter *parent;
    
    unsigned long watermark;           // æ°´ä½çº¿
    unsigned long failcnt;             // å¤±è´¥æ¬¡æ•°
};
```

**å†…å­˜åˆ†é…æ—¶çš„æ£€æŸ¥**:

```c
// å°è¯•å……ç”µ (charge) å†…å­˜
int mem_cgroup_try_charge(struct page *page, struct mm_struct *mm,
                          gfp_t gfp_mask, struct mem_cgroup **memcgp) {
    struct mem_cgroup *memcg;
    unsigned int nr_pages = 1;
    int ret;
    
    // è·å–å½“å‰è¿›ç¨‹çš„memcg
    memcg = get_mem_cgroup_from_mm(mm);
    
retry:
    // å°è¯•å¢åŠ è®¡æ•°å™¨
    ret = page_counter_try_charge(&memcg->memory, nr_pages, &counter);
    if (ret == 0) {
        // å……ç”µæˆåŠŸ
        *memcgp = memcg;
        return 0;
    }
    
    // è¾¾åˆ°é™åˆ¶ï¼Œå°è¯•å›æ”¶
    if (gfp_mask & __GFP_WAIT) {
        mem_cgroup_reclaim(memcg, gfp_mask, flags);
        goto retry;
    }
    
    // æ— æ³•å›æ”¶ï¼Œè§¦å‘OOM
    if (!mem_cgroup_oom_trylock(memcg))
        goto nomem;
    
    mem_cgroup_oom(memcg, gfp_mask, order);
    
nomem:
    css_put(&memcg->css);
    return -ENOMEM;
}
```

**Memoryé…ç½®ç¤ºä¾‹**:

```bash
# é™åˆ¶å†…å­˜ä¸º512MB
echo 536870912 > /sys/fs/cgroup/memory/mycontainer/memory.limit_in_bytes

# è®¾ç½®è½¯é™åˆ¶ä¸º256MB (ä»…åœ¨å†…å­˜ç´§å¼ æ—¶ç”Ÿæ•ˆ)
echo 268435456 > /sys/fs/cgroup/memory/mycontainer/memory.soft_limit_in_bytes

# è®¾ç½®swapé™åˆ¶ä¸º512MB
echo 536870912 > /sys/fs/cgroup/memory/mycontainer/memory.memsw.limit_in_bytes

# æŸ¥çœ‹å½“å‰ä½¿ç”¨é‡
cat /sys/fs/cgroup/memory/mycontainer/memory.usage_in_bytes

# æŸ¥çœ‹ç»Ÿè®¡ä¿¡æ¯
cat /sys/fs/cgroup/memory/mycontainer/memory.stat
```

#### 2.2.4 Block I/Oæ§åˆ¶å™¨

```c
// block/blk-cgroup.h

struct blkcg {
    struct cgroup_subsys_state css;
    spinlock_t lock;
    
    struct radix_tree_root blkg_tree;  // blkg (block cgroup) æ ‘
    struct blkcg_gq *blkg_hint;
    struct hlist_head blkg_list;
    
    struct blkcg_policy_data *pd[BLKCG_MAX_POLS];
    
    struct list_head cgwb_list;        // writeback list
};

// æ¯ä¸ªblock deviceçš„cgroupçŠ¶æ€
struct blkcg_gq {
    struct request_queue *q;           // å…³è”çš„è¯·æ±‚é˜Ÿåˆ—
    struct blkcg *blkcg;
    
    // ç­–ç•¥ç‰¹å®šçš„æ•°æ®
    struct blkg_policy_data *pd[BLKCG_MAX_POLS];
    
    struct blkcg_gq *parent;
    struct list_head q_node;
    struct list_head blkcg_node;
    // ...
};
```

**CFQ (Completely Fair Queuing) I/Oè°ƒåº¦å™¨**:

```c
// block/cfq-iosched.c

struct cfq_group {
    struct blkg_policy_data pd;
    
    unsigned int weight;               // I/Oæƒé‡
    unsigned int new_weight;
    unsigned int dev_weight;
    
    unsigned int nr_active;
    unsigned int nr_idle;
    
    // Serviceæ ‘ (æŒ‰è™šæ‹Ÿæ—¶é—´æ’åº)
    struct cfq_rb_root service_trees[2][3];
    struct cfq_rb_root service_tree_idle;
    
    // ç»Ÿè®¡
    uint64_t dispatched;
    uint64_t nr_sectors;
    
    struct cfq_group *parent;
    // ...
};
```

**Blkioé…ç½®ç¤ºä¾‹**:

```bash
# è®¾ç½®I/Oæƒé‡ (100-1000, é»˜è®¤500)
echo 500 > /sys/fs/cgroup/blkio/mycontainer/blkio.weight

# é™åˆ¶è¯»å†™é€Ÿç‡ (bytes per second)
# æ ¼å¼: <major>:<minor> <bytes_per_second>
echo "8:0 10485760" > /sys/fs/cgroup/blkio/mycontainer/blkio.throttle.read_bps_device   # 10MB/sè¯»
echo "8:0 5242880" > /sys/fs/cgroup/blkio/mycontainer/blkio.throttle.write_bps_device  # 5MB/så†™

# é™åˆ¶IOPS
echo "8:0 1000" > /sys/fs/cgroup/blkio/mycontainer/blkio.throttle.read_iops_device   # 1000 IOPSè¯»

# æŸ¥çœ‹ç»Ÿè®¡
cat /sys/fs/cgroup/blkio/mycontainer/blkio.throttle.io_serviced
```

#### 2.2.5 Cgroup v2 (ç»Ÿä¸€å±‚çº§)

**ä¸v1çš„å…³é”®å·®å¼‚**:

```text
Cgroup v1:
  /sys/fs/cgroup/cpu/container1/
  /sys/fs/cgroup/memory/container1/
  /sys/fs/cgroup/blkio/container1/
  (æ¯ä¸ªsubsystemç‹¬ç«‹å±‚çº§)

Cgroup v2:
  /sys/fs/cgroup/container1/
    â”œâ”€â”€ cpu.max
    â”œâ”€â”€ cpu.weight
    â”œâ”€â”€ memory.max
    â”œâ”€â”€ memory.current
    â”œâ”€â”€ io.max
    â””â”€â”€ ...
  (ç»Ÿä¸€å±‚çº§ï¼Œæ‰€æœ‰æ§åˆ¶å™¨åœ¨ä¸€ä¸ªæ ‘ä¸­)
```

**Cgroup v2æ ¸å¿ƒåŸåˆ™**:

1. **ç»Ÿä¸€å±‚çº§** (Unified Hierarchy): æ‰€æœ‰æ§åˆ¶å™¨å…±äº«ä¸€ä¸ªå±‚çº§æ ‘
2. **No Internal Processes**: å†…éƒ¨èŠ‚ç‚¹ä¸èƒ½ç›´æ¥åŒ…å«è¿›ç¨‹(åªèƒ½åŒ…å«å­cgroup)
3. **Delegation**: æ¸…æ™°çš„å§”æ‰˜æ¨¡å‹,æ”¯æŒå®¹å™¨åµŒå¥—

**Cgroup v2 API**:

```c
// Cgroup v2æ¥å£æ–‡ä»¶
struct cftype {
    char name[MAX_CFTYPE_NAME];
    unsigned long private;
    
    // è¯»å–æ–¹æ³•
    u64 (*read_u64)(struct cgroup_subsys_state *css, struct cftype *cft);
    s64 (*read_s64)(struct cgroup_subsys_state *css, struct cftype *cft);
    int (*seq_show)(struct seq_file *sf, void *v);
    
    // å†™å…¥æ–¹æ³•
    int (*write_u64)(struct cgroup_subsys_state *css, struct cftype *cft, u64 val);
    int (*write_s64)(struct cgroup_subsys_state *css, struct cftype *cft, s64 val);
    ssize_t (*write)(struct kernfs_open_file *of, char *buf, size_t nbytes, loff_t off);
    
    // ...
};

// æ§åˆ¶å™¨ç‰¹å®šçš„æ¥å£
// CPUæ§åˆ¶å™¨
static struct cftype cpu_files[] = {
    {
        .name = "max",             // cpu.max: "quota period"
        .flags = CFTYPE_NOT_ON_ROOT,
        .seq_show = cpu_max_show,
        .write = cpu_max_write,
    },
    {
        .name = "weight",          // cpu.weight: 1-10000 (é»˜è®¤100)
        .flags = CFTYPE_NOT_ON_ROOT,
        .read_u64 = cpu_weight_read_u64,
        .write_u64 = cpu_weight_write_u64,
    },
    {
        .name = "stat",            // cpu.stat: usageç»Ÿè®¡
        .seq_show = cpu_stat_show,
    },
    { }  // ç»ˆæ­¢ç¬¦
};

// Memoryæ§åˆ¶å™¨
static struct cftype memory_files[] = {
    {
        .name = "current",         // memory.current: å½“å‰ä½¿ç”¨
        .read_u64 = memory_current_read_u64,
    },
    {
        .name = "min",             // memory.min: ç¡¬ä¿ç•™
        .flags = CFTYPE_NOT_ON_ROOT,
        .read_u64 = memory_min_read_u64,
        .write_u64 = memory_min_write_u64,
    },
    {
        .name = "low",             // memory.low: è½¯ä¿ç•™ (best-effort)
        .flags = CFTYPE_NOT_ON_ROOT,
        .read_u64 = memory_low_read_u64,
        .write_u64 = memory_low_write_u64,
    },
    {
        .name = "high",            // memory.high: é«˜æ°´ä½
        .flags = CFTYPE_NOT_ON_ROOT,
        .read_u64 = memory_high_read_u64,
        .write_u64 = memory_high_write_u64,
    },
    {
        .name = "max",             // memory.max: ç¡¬é™åˆ¶
        .flags = CFTYPE_NOT_ON_ROOT,
        .read_u64 = memory_max_read_u64,
        .write_u64 = memory_max_write_u64,
    },
    {
        .name = "stat",            // memory.stat: è¯¦ç»†ç»Ÿè®¡
        .seq_show = memory_stat_show,
    },
    { }
};

// I/Oæ§åˆ¶å™¨
static struct cftype io_files[] = {
    {
        .name = "max",             // io.max: IOPS/BPSé™åˆ¶
        .seq_show = tg_print_limit,
        .write = tg_set_limit,
    },
    {
        .name = "weight",          // io.weight: I/Oæƒé‡
        .flags = CFTYPE_NOT_ON_ROOT,
        .seq_show = io_weight_show,
        .write = io_weight_write,
    },
    {
        .name = "stat",            // io.stat: I/Oç»Ÿè®¡
        .seq_show = io_stat_show,
    },
    { }
};
```

**Cgroup v2ä½¿ç”¨ç¤ºä¾‹**:

```bash
# æŒ‚è½½cgroup v2
mount -t cgroup2 none /sys/fs/cgroup

# åˆ›å»ºcgroup
mkdir /sys/fs/cgroup/mycontainer

# å¯ç”¨æ§åˆ¶å™¨
echo "+cpu +memory +io" > /sys/fs/cgroup/cgroup.subtree_control

# é…ç½®CPU
echo "100000 100000" > /sys/fs/cgroup/mycontainer/cpu.max  # 100ms/100ms = 100%
echo "200" > /sys/fs/cgroup/mycontainer/cpu.weight         # æƒé‡200

# é…ç½®å†…å­˜
echo "512M" > /sys/fs/cgroup/mycontainer/memory.max
echo "256M" > /sys/fs/cgroup/mycontainer/memory.high

# é…ç½®I/O
echo "8:0 rbps=10485760 wbps=5242880" > /sys/fs/cgroup/mycontainer/io.max  # 10MB/sè¯», 5MB/så†™

# æ·»åŠ è¿›ç¨‹
echo $PID > /sys/fs/cgroup/mycontainer/cgroup.procs

# æŸ¥çœ‹ç»Ÿè®¡
cat /sys/fs/cgroup/mycontainer/cpu.stat
cat /sys/fs/cgroup/mycontainer/memory.stat
cat /sys/fs/cgroup/mycontainer/io.stat
```

#### 2.2.6 Cgroupçš„å½¢å¼åŒ–æ¨¡å‹

```haskell
-- Cgroupçš„èµ„æºåˆ†é…æ¨¡å‹

-- èµ„æºç±»å‹
data Resource = CPU | Memory | BlkIO | Network

-- èµ„æºé…é¢
data Quota = Quota {
    limit :: Maybe Integer,      -- ç¡¬é™åˆ¶ (Nothingè¡¨ç¤ºæ— é™åˆ¶)
    guarantee :: Integer,        -- ä¿è¯é‡ (æœ€ä½ä¿è¯)
    weight :: Integer            -- æƒé‡ (ç”¨äºæ¯”ä¾‹åˆ†é…)
}

-- Cgroupæ ‘ç»“æ„
data CgroupTree = Node {
    cgroup_id :: String,
    quotas :: Resource -> Quota,
    children :: [CgroupTree],
    processes :: [ProcessID]
}

-- èµ„æºåˆ†é…ç®—æ³• (ç®€åŒ–ç‰ˆ)
allocate_resource :: CgroupTree -> Resource -> Integer -> [(CgroupTree, Integer)]
allocate_resource root res total_available =
    let
        -- 1. æ»¡è¶³æ‰€æœ‰guarantee
        total_guarantee = sum [get_guarantee c res | c <- children root]
        remaining = total_available - total_guarantee
        
        -- 2. æŒ‰weightæ¯”ä¾‹åˆ†é…å‰©ä½™èµ„æº
        total_weight = sum [get_weight c res | c <- children root]
        allocations = [(c, guarantee c + weight_share c remaining total_weight) 
                      | c <- children root]
        
        -- 3. åº”ç”¨limité™åˆ¶
        capped = [(c, min alloc (get_limit c res)) | (c, alloc) <- allocations]
    in
        capped

-- èµ„æºéš”ç¦»çš„å½¢å¼åŒ–æ€§è´¨
resource_isolation_property :: CgroupTree -> Resource -> Bool
resource_isolation_property tree res =
    -- æ€§è´¨1: å­cgroupçš„èµ„æºæ€»å’Œä¸è¶…è¿‡çˆ¶cgroupçš„limit
    forall [child in children tree] (
        allocated_to child res <= limit (quotas tree res)
    ) &&
    -- æ€§è´¨2: æ¯ä¸ªcgroupè‡³å°‘è·å¾—å…¶guarantee
    forall [child in children tree] (
        allocated_to child res >= guarantee (quotas tree res)
    )
```

### 2.3 æ–‡ä»¶ç³»ç»Ÿéš”ç¦»ä¸Union FS

#### 2.3.1 UnionFSåŸç†

**åˆ†å±‚æ–‡ä»¶ç³»ç»Ÿæ¶æ„**:

```text
Container View:
  /
  â”œâ”€â”€ bin/
  â”œâ”€â”€ etc/
  â”œâ”€â”€ home/
  â””â”€â”€ ...

å®é™…åˆ†å±‚ (ä»ä¸Šåˆ°ä¸‹):
  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
  â”‚  Container Layer    â”‚ <-- Read-Write (å®¹å™¨ä¿®æ”¹)
  â”‚  (upperdir)         â”‚
  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
  â”‚  Image Layer 3      â”‚ <-- Read-Only
  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
  â”‚  Image Layer 2      â”‚ <-- Read-Only
  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
  â”‚  Image Layer 1      â”‚ <-- Read-Only (Base Image)
  â”‚  (lowerdir)         â”‚
  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

#### 2.3.2 OverlayFSå®ç°

**OverlayFSæ¶æ„**:

```c
// fs/overlayfs/overlayfs.h

struct ovl_fs {
    struct vfsmount *upper_mnt;        // ä¸Šå±‚æ–‡ä»¶ç³»ç»Ÿ (è¯»å†™å±‚)
    struct ovl_dir_cache *cache;
    unsigned int numlower;             // ä¸‹å±‚æ•°é‡
    struct ovl_layer *lower_layers;    // ä¸‹å±‚æ•°ç»„
    
    // Inodeç¼“å­˜
    struct inode *workbasedir;
    struct inode *indexdir;
    struct inode *workdir;
    
    // ç‰¹æ€§æ ‡å¿—
    bool noxattr;                      // ç¦ç”¨xattr
    bool redirect_dir;                 // ç›®å½•é‡å®šå‘
    bool index;                        // ç´¢å¼•åŠŸèƒ½
    bool metacopy;                     // å…ƒæ•°æ®å¤åˆ¶
    // ...
};

struct ovl_layer {
    struct vfsmount *mnt;              // æŒ‚è½½ç‚¹
    int idx;                           // å±‚ç´¢å¼•
    bool is_lower;                     // æ˜¯å¦æ˜¯ä¸‹å±‚
};

struct ovl_entry {
    union {
        struct {
            unsigned long flags;       // æ ‡å¿—
        };
        struct rcu_head rcu;
    };
    unsigned numlower;
    struct ovl_path lowerstack[];      // ä¸‹å±‚è·¯å¾„æ ˆ
};

struct ovl_path {
    struct ovl_layer *layer;
    struct dentry *dentry;
};
```

**OverlayFSçš„å…³é”®æ“ä½œ**:

1. **æŸ¥æ‰¾ (Lookup)**:

    ```c
    // fs/overlayfs/namei.c
    struct dentry *ovl_lookup(struct inode *dir, struct dentry *dentry,
                            unsigned int flags) {
        struct ovl_entry *oe;
        struct ovl_entry *poe = dir->i_private;
        struct ovl_path *stack = NULL;
        struct dentry *upperdir, *upperdentry = NULL;
        int err;
        
        // 1. åœ¨upperå±‚æŸ¥æ‰¾
        upperdir = ovl_dentry_upper(parent);
        if (upperdir) {
            upperdentry = lookup_one_len(name, upperdir, len);
            if (IS_ERR(upperdentry))
                goto out;
        }
        
        // 2. åœ¨lowerå±‚æŸ¥æ‰¾
        for (int i = 0; i < poe->numlower; i++) {
            struct dentry *this = lookup_one_len(name, poe->lowerstack[i].dentry, len);
            if (!IS_ERR(this) && this->d_inode) {
                // æ‰¾åˆ°äº†ï¼Œæ·»åŠ åˆ°stack
                stack = kzalloc(...);
                stack[i].dentry = this;
                stack[i].layer = poe->lowerstack[i].layer;
            }
        }
        
        // 3. åˆå¹¶ç»“æœ
        oe = ovl_alloc_entry(numlower);
        oe->lowerstack = stack;
        oe->__upperdentry = upperdentry;
        
        inode = ovl_get_inode(dentry->d_sb, upperdentry ?: stack[0].dentry);
        
    out:
        return d_splice_alias(inode, dentry);
    }
    ```

2. **å†™æ—¶å¤åˆ¶ (Copy-up)**:

    ```c
    // fs/overlayfs/copy_up.c
    int ovl_copy_up(struct dentry *dentry) {
        struct ovl_fs *ofs = dentry->d_sb->s_fs_info;
        struct dentry *parent, *upper;
        struct path lowerpath, upperpath;
        int err;
        
        // 1. ç¡®ä¿çˆ¶ç›®å½•å·²copy-up
        parent = dget_parent(dentry);
        err = ovl_copy_up(parent);
        if (err)
            goto out_dput;
        
        // 2. è·å–lowerè·¯å¾„
        ovl_path_lower(dentry, &lowerpath);
        
        // 3. åœ¨upperå±‚åˆ›å»º
        upper = ovl_dentry_upper(parent);
        err = ovl_create_or_link(dentry, &lowerpath, upper);
        if (err)
            goto out;
        
        // 4. å¤åˆ¶æ•°æ®å’Œå…ƒæ•°æ®
        if (S_ISREG(lowerpath.dentry->d_inode->i_mode)) {
            err = ovl_copy_up_data(&lowerpath, &upperpath);
            if (err)
                goto out_cleanup;
        }
        
        // 5. å¤åˆ¶xattr
        err = ovl_copy_xattr(lowerpath.dentry, upperdentry);
        
        // 6. è®¾ç½®opaqueæ ‡å¿— (å¦‚æœæ˜¯ç›®å½•)
        if (S_ISDIR(d_inode(dentry)->i_mode))
            err = ovl_set_opaque(upperdentry);
        
    out_cleanup:
        if (err)
            ovl_cleanup(upper, upperdentry);
    out:
        path_put(&lowerpath);
    out_dput:
        dput(parent);
        return err;
    }

    // å®é™…æ–‡ä»¶å¤åˆ¶
    static int ovl_copy_up_data(struct path *old, struct path *new) {
        struct file *old_file, *new_file;
        char *buf;
        loff_t pos = 0;
        ssize_t len;
        int error = 0;
        
        // æ‰“å¼€æºæ–‡ä»¶å’Œç›®æ ‡æ–‡ä»¶
        old_file = ovl_path_open(old, O_RDONLY);
        new_file = ovl_path_open(new, O_WRONLY);
        
        // åˆ†é…ç¼“å†²åŒº
        buf = kmalloc(PAGE_SIZE, GFP_KERNEL);
        
        // å¾ªç¯å¤åˆ¶
        while ((len = kernel_read(old_file, buf, PAGE_SIZE, &pos)) > 0) {
            if (kernel_write(new_file, buf, len, &pos) != len) {
                error = -EIO;
                break;
            }
        }
        
        kfree(buf);
        fput(new_file);
        fput(old_file);
        
        return error;
    }
    ```

3. **Whiteoutæœºåˆ¶** (åˆ é™¤æ–‡ä»¶çš„å¤„ç†):

```c
// åœ¨upperå±‚åˆ›å»ºwhiteoutæ ‡è®°
int ovl_whiteout(struct dentry *workdir, struct dentry *dentry) {
    int err;
    struct dentry *whiteout;
    struct inode *dir = workdir->d_inode;
    
    // åˆ›å»ºå­—ç¬¦è®¾å¤‡èŠ‚ç‚¹ (major=0, minor=0)
    whiteout = lookup_one_len(dentry->d_name.name, workdir,
                              dentry->d_name.len);
    if (IS_ERR(whiteout))
        return PTR_ERR(whiteout);
    
    err = vfs_mknod(dir, whiteout, S_IFCHR | 0, makedev(0, 0));
    
    dput(whiteout);
    return err;
}

// æŸ¥æ‰¾æ—¶è¯†åˆ«whiteout
static bool ovl_is_whiteout(struct dentry *dentry) {
    struct inode *inode = dentry->d_inode;
    
    return inode && S_ISCHR(inode->i_mode) &&
           inode->i_rdev == makedev(0, 0);
}
```

**OverlayFSç¤ºä¾‹**:

```bash
# åˆ›å»ºç›®å½•ç»“æ„
mkdir -p /tmp/overlay/{lower,upper,work,merged}

# å‡†å¤‡lowerå±‚å†…å®¹
echo "Base content" > /tmp/overlay/lower/file1.txt
mkdir /tmp/overlay/lower/dir1

# æŒ‚è½½OverlayFS
mount -t overlay overlay \
  -o lowerdir=/tmp/overlay/lower,\
     upperdir=/tmp/overlay/upper,\
     workdir=/tmp/overlay/work \
  /tmp/overlay/merged

# åœ¨mergedä¸­ä¿®æ”¹æ–‡ä»¶ (ä¼šè§¦å‘copy-up)
echo "Modified content" > /tmp/overlay/merged/file1.txt

# æŸ¥çœ‹ç»“æœ
ls -la /tmp/overlay/upper/    # ä¼šçœ‹åˆ°copy-upçš„file1.txt

# åˆ é™¤æ–‡ä»¶ (ä¼šåˆ›å»ºwhiteout)
rm /tmp/overlay/merged/dir1/somefile

# æŸ¥çœ‹whiteout
ls -la /tmp/overlay/upper/dir1/  # ä¼šçœ‹åˆ°å­—ç¬¦è®¾å¤‡èŠ‚ç‚¹
```

#### 2.3.3 AUFS vs OverlayFS vs Btrfs

| ç‰¹æ€§ | AUFS | OverlayFS | Btrfs |
|------|------|-----------|-------|
| **å†…æ ¸ä¸»çº¿** | âŒ (è¡¥ä¸) | âœ… | âœ… |
| **æ€§èƒ½** | ä¸­ | é«˜ | é«˜ |
| **å±‚æ•°é™åˆ¶** | æ— é™åˆ¶ | 128å±‚ | N/A (å¿«ç…§) |
| **Copy-upå¼€é”€** | ä¸­ | ä½ (ä»…å…ƒæ•°æ®) | ä½ (CoW) |
| **Inodeæ¶ˆè€—** | é«˜ | ä¸­ | ä½ |
| **Renameæ€§èƒ½** | å·® | å·® | å¥½ |
| **Dockeræ”¯æŒ** | æ—©æœŸ | ä¸»æµ | æ”¯æŒ |
| **ç”Ÿäº§æ¨è** | âŒ | âœ… | âœ… |

### 2.4 å®¹å™¨åŒ–çš„å†…æ ¸å®‰å…¨æœºåˆ¶

#### 2.4.1 Capabilities

**Linux Capabilities** (å°†rootæƒé™ç»†åˆ†ä¸ºç‹¬ç«‹èƒ½åŠ›):

```c
// include/uapi/linux/capability.h

// Capabilityå®šä¹‰ (éƒ¨åˆ†)
#define CAP_CHOWN            0   // æ›´æ”¹æ–‡ä»¶æ‰€æœ‰æƒ
#define CAP_DAC_OVERRIDE     1   // ç»•è¿‡æ–‡ä»¶è¯»å†™æ‰§è¡Œæƒé™æ£€æŸ¥
#define CAP_DAC_READ_SEARCH  2   // ç»•è¿‡æ–‡ä»¶è¯»å’Œç›®å½•æœç´¢æƒé™æ£€æŸ¥
#define CAP_FOWNER           3   // ç»•è¿‡æ–‡ä»¶æ‰€æœ‰æƒæ£€æŸ¥
#define CAP_FSETID           4   // è®¾ç½®æ–‡ä»¶çš„setuid/setgidä½
#define CAP_KILL             5   // ç»•è¿‡å‘é€ä¿¡å·çš„æƒé™æ£€æŸ¥
#define CAP_SETGID           6   // è®¾ç½®è¿›ç¨‹GID
#define CAP_SETUID           7   // è®¾ç½®è¿›ç¨‹UID
#define CAP_SETPCAP          8   // ä¿®æ”¹è¿›ç¨‹capabilities
#define CAP_NET_BIND_SERVICE 10  // ç»‘å®šç‰¹æƒç«¯å£ (<1024)
#define CAP_NET_RAW          13  // ä½¿ç”¨RAWå’ŒPACKET socket
#define CAP_SYS_CHROOT       18  // ä½¿ç”¨chroot()
#define CAP_SYS_ADMIN        21  // ç³»ç»Ÿç®¡ç†æ“ä½œ
#define CAP_SYS_TIME         25  // è®¾ç½®ç³»ç»Ÿæ—¶é’Ÿ
#define CAP_MKNOD            27  // åˆ›å»ºè®¾å¤‡èŠ‚ç‚¹
#define CAP_AUDIT_WRITE      29  // å†™å…¥auditæ—¥å¿—
#define CAP_SETFCAP          31  // è®¾ç½®æ–‡ä»¶capabilities
#define CAP_MAC_OVERRIDE     32  // ç»•è¿‡MAC (Mandatory Access Control)
#define CAP_SYS_MODULE       16  // åŠ è½½/å¸è½½å†…æ ¸æ¨¡å—
#define CAP_SYS_RAWIO        17  // I/Oç«¯å£æ“ä½œ
#define CAP_SYS_PTRACE       19  // ptraceä»»æ„è¿›ç¨‹
#define CAP_SYS_NICE         23  // ä¿®æ”¹è¿›ç¨‹niceå€¼å’Œè°ƒåº¦ç­–ç•¥
#define CAP_SYS_RESOURCE     24  // ç»•è¿‡èµ„æºé™åˆ¶

// Capabilityç»“æ„
struct kernel_cap {
    __u32 cap[_KERNEL_CAPABILITY_U32S];  // ä½å›¾ (64ä½)
};

// è¿›ç¨‹çš„credentials
struct cred {
    // Capability sets
    kernel_cap_t cap_inheritable;  // ç»§æ‰¿é›† (å¯ä»¥è¢«å­è¿›ç¨‹ç»§æ‰¿)
    kernel_cap_t cap_permitted;    // è®¸å¯é›† (è¿›ç¨‹å¯ä»¥æ‹¥æœ‰çš„èƒ½åŠ›)
    kernel_cap_t cap_effective;    // æœ‰æ•ˆé›† (å½“å‰å®é™…ä½¿ç”¨çš„èƒ½åŠ›)
    kernel_cap_t cap_bset;         // è¾¹ç•Œé›† (capabilityçš„ä¸Šç•Œ)
    kernel_cap_t cap_ambient;      // ç¯å¢ƒé›† (execveåä¿ç•™)
    
    // UID/GID
    kuid_t uid, euid, suid, fsuid;
    kgid_t gid, egid, sgid, fsgid;
    
    // ...
};
```

**Capabilityæ£€æŸ¥**:

```c
// kernel/capability.c

// æ£€æŸ¥è¿›ç¨‹æ˜¯å¦æœ‰æŒ‡å®šcapability
bool capable(int cap) {
    return ns_capable(&init_user_ns, cap);
}

bool ns_capable(struct user_namespace *ns, int cap) {
    struct cred *cred = current_cred();
    
    return cap_raised(cred->cap_effective, cap) &&
           cap_issubset(cap_set, cred->cap_permitted);
}

// åœ¨ç³»ç»Ÿè°ƒç”¨ä¸­ä½¿ç”¨
asmlinkage long sys_chown(const char __user *filename, uid_t user, gid_t group) {
    // æ£€æŸ¥CAP_CHOWN capability
    if ((user != (uid_t)-1 || group != (gid_t)-1) && !capable(CAP_CHOWN))
        return -EPERM;
    
    return do_chown(filename, user, group);
}

asmlinkage long sys_mknod(const char __user *filename, umode_t mode, unsigned dev) {
    // åˆ›å»ºè®¾å¤‡èŠ‚ç‚¹éœ€è¦CAP_MKNOD
    if (!capable(CAP_MKNOD))
        return -EPERM;
    
    return do_mknodat(AT_FDCWD, filename, mode, dev);
}
```

**Dockerçš„é»˜è®¤Capabilityè®¾ç½®**:

```bash
# Dockeré»˜è®¤DROPçš„capabilities (ä¸ç»™å®¹å™¨)
CAP_AUDIT_CONTROL
CAP_AUDIT_READ
CAP_AUDIT_WRITE       # (æŸäº›ç‰ˆæœ¬ä¿ç•™)
CAP_BLOCK_SUSPEND
CAP_DAC_READ_SEARCH
CAP_FSETID            # (æŸäº›ç‰ˆæœ¬ä¿ç•™)
CAP_IPC_LOCK
CAP_IPC_OWNER
CAP_LEASE
CAP_LINUX_IMMUTABLE
CAP_MAC_ADMIN
CAP_MAC_OVERRIDE
CAP_NET_ADMIN
CAP_NET_BROADCAST
CAP_PERFMON
CAP_SYS_ADMIN         # æœ€å±é™©
CAP_SYS_BOOT
CAP_SYS_MODULE        # æœ€å±é™©
CAP_SYS_NICE
CAP_SYS_PACCT
CAP_SYS_PTRACE
CAP_SYS_RAWIO         # æœ€å±é™©
CAP_SYS_RESOURCE
CAP_SYS_TIME
CAP_SYS_TTY_CONFIG
CAP_SYSLOG
CAP_WAKE_ALARM

# Dockeré»˜è®¤ä¿ç•™çš„capabilities
CAP_CHOWN
CAP_DAC_OVERRIDE
CAP_FOWNER
CAP_FSETID
CAP_KILL
CAP_SETGID
CAP_SETUID
CAP_SETPCAP
CAP_NET_BIND_SERVICE
CAP_NET_RAW
CAP_SYS_CHROOT
CAP_MKNOD
CAP_AUDIT_WRITE
CAP_SETFCAP
```

**è‡ªå®šä¹‰Capability**:

```bash
# è¿è¡Œæ—¶æ·»åŠ capability
docker run --cap-add=NET_ADMIN myimage

# è¿è¡Œæ—¶åˆ é™¤capability
docker run --cap-drop=CHOWN myimage

# ç‰¹æƒå®¹å™¨ (æ‰€æœ‰capabilities)
docker run --privileged myimage

# æœ€å°æƒé™å®¹å™¨
docker run --cap-drop=ALL --cap-add=NET_BIND_SERVICE myimage
```

#### 2.4.2 Seccomp (Secure Computing Mode)

**Seccompæ¶æ„**:

```c
// include/linux/seccomp.h

struct seccomp {
    int mode;                          // SECCOMP_MODE_*
    struct seccomp_filter *filter;     // BPFè¿‡æ»¤å™¨
};

#define SECCOMP_MODE_DISABLED  0       // ç¦ç”¨
#define SECCOMP_MODE_STRICT    1       // ä¸¥æ ¼æ¨¡å¼ (åªå…è®¸read/write/exit/_exit/sigreturn)
#define SECCOMP_MODE_FILTER    2       // è¿‡æ»¤æ¨¡å¼ (BPF)

// Seccompè¿‡æ»¤å™¨
struct seccomp_filter {
    atomic_t usage;
    struct seccomp_filter *prev;       // è¿‡æ»¤å™¨é“¾
    struct bpf_prog *prog;             // BPFç¨‹åº
};

// Seccompæ•°æ® (ä¼ é€’ç»™BPFç¨‹åº)
struct seccomp_data {
    int nr;                            // ç³»ç»Ÿè°ƒç”¨å·
    __u32 arch;                        // æ¶æ„ (AUDIT_ARCH_*)
    __u64 instruction_pointer;         // æŒ‡ä»¤æŒ‡é’ˆ
    __u64 args[6];                     // ç³»ç»Ÿè°ƒç”¨å‚æ•°
};
```

**Seccomp BPFè¿‡æ»¤å™¨**:

```c
// è¿”å›å€¼
#define SECCOMP_RET_KILL_PROCESS 0x80000000U  // æ€æ­»æ•´ä¸ªè¿›ç¨‹ç»„
#define SECCOMP_RET_KILL_THREAD  0x00000000U  // æ€æ­»çº¿ç¨‹
#define SECCOMP_RET_TRAP         0x00030000U  // å‘é€SIGSYSä¿¡å·
#define SECCOMP_RET_ERRNO        0x00050000U  // è¿”å›errno
#define SECCOMP_RET_TRACE        0x7ff00000U  // é€šçŸ¥ptrace tracer
#define SECCOMP_RET_LOG          0x7ffc0000U  // è®°å½•æ—¥å¿—
#define SECCOMP_RET_ALLOW        0x7fff0000U  // å…è®¸

// ç¤ºä¾‹ï¼šç¦æ­¢mkdirç³»ç»Ÿè°ƒç”¨
struct sock_filter filter[] = {
    // åŠ è½½ç³»ç»Ÿè°ƒç”¨å·
    BPF_STMT(BPF_LD | BPF_W | BPF_ABS, offsetof(struct seccomp_data, nr)),
    
    // å¦‚æœæ˜¯mkdir (SYS_mkdir == 83)
    BPF_JUMP(BPF_JMP | BPF_JEQ | BPF_K, __NR_mkdir, 0, 1),
    
    // æ‹’ç» (è¿”å›EPERM)
    BPF_STMT(BPF_RET | BPF_K, SECCOMP_RET_ERRNO | EPERM),
    
    // é»˜è®¤å…è®¸
    BPF_STMT(BPF_RET | BPF_K, SECCOMP_RET_ALLOW),
};

struct sock_fprog prog = {
    .len = sizeof(filter) / sizeof(filter[0]),
    .filter = filter,
};

// å®‰è£…è¿‡æ»¤å™¨
prctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0);
prctl(PR_SET_SECCOMP, SECCOMP_MODE_FILTER, &prog);
```

**Dockerçš„é»˜è®¤Seccompé…ç½®**:

```json
{
  "defaultAction": "SCMP_ACT_ERRNO",
  "archMap": [
    {
      "architecture": "SCMP_ARCH_X86_64",
      "subArchitectures": ["SCMP_ARCH_X86", "SCMP_ARCH_X32"]
    }
  ],
  "syscalls": [
    {
      "names": [
        "accept", "accept4", "access", "adjtimex", "alarm",
        "bind", "brk", "capget", "capset", "chdir",
        "chmod", "chown", "chown32", "clock_getres", "clock_gettime",
        ...
      ],
      "action": "SCMP_ACT_ALLOW"
    },
    {
      "names": [
        "personality"
      ],
      "action": "SCMP_ACT_ALLOW",
      "args": [
        {
          "index": 0,
          "value": 0,
          "op": "SCMP_CMP_EQ"
        }
      ]
    },
    {
      "names": [
        "clone"
      ],
      "action": "SCMP_ACT_ALLOW",
      "args": [
        {
          "index": 0,
          "value": 2114060288,
          "op": "SCMP_CMP_MASKED_EQ"
        }
      ]
    }
  ]
}
```

**è¢«é˜»æ­¢çš„å±é™©ç³»ç»Ÿè°ƒç”¨**:

```bash
# Dockeré»˜è®¤é˜»æ­¢çš„ç³»ç»Ÿè°ƒç”¨
acct              # è¿›ç¨‹è®°è´¦
add_key           # å¯†é’¥ç®¡ç†
bpf               # BPFç³»ç»Ÿè°ƒç”¨
clock_adjtime     # è°ƒæ•´æ—¶é’Ÿ
clock_settime     # è®¾ç½®æ—¶é’Ÿ
clone (æŸäº›flags) # æŸäº›clone flags
create_module     # åˆ›å»ºå†…æ ¸æ¨¡å— (å·²åºŸå¼ƒ)
delete_module     # åˆ é™¤å†…æ ¸æ¨¡å—
finit_module      # åˆå§‹åŒ–å†…æ ¸æ¨¡å—
get_kernel_syms   # è·å–å†…æ ¸ç¬¦å· (å·²åºŸå¼ƒ)
get_mempolicy     # è·å–NUMAå†…å­˜ç­–ç•¥
init_module       # åˆå§‹åŒ–å†…æ ¸æ¨¡å—
ioperm            # I/Oç«¯å£æƒé™
iopl              # I/Oç‰¹æƒçº§
kcmp              # æ¯”è¾ƒè¿›ç¨‹
kexec_file_load   # kexec
kexec_load        # kexec
keyctl            # å¯†é’¥æ§åˆ¶
lookup_dcookie    # dcookie
mbind             # NUMAç»‘å®š
mount             # æŒ‚è½½æ–‡ä»¶ç³»ç»Ÿ
move_pages        # ç§»åŠ¨é¡µé¢
name_to_handle_at # æ–‡ä»¶å¥æŸ„
open_by_handle_at # é€šè¿‡å¥æŸ„æ‰“å¼€
perf_event_open   # æ€§èƒ½äº‹ä»¶
pivot_root        # pivot root
process_vm_readv  # è·¨è¿›ç¨‹è¯»
process_vm_writev # è·¨è¿›ç¨‹å†™
ptrace            # è¿›ç¨‹è·Ÿè¸ª
query_module      # æŸ¥è¯¢æ¨¡å— (å·²åºŸå¼ƒ)
quotactl          # é…é¢æ§åˆ¶
reboot            # é‡å¯
request_key       # è¯·æ±‚å¯†é’¥
set_mempolicy     # è®¾ç½®NUMAç­–ç•¥
setns             # åŠ å…¥namespace
settimeofday      # è®¾ç½®æ—¶é—´
stime             # è®¾ç½®æ—¶é—´ (å·²åºŸå¼ƒ)
swapon            # å¯ç”¨swap
swapoff           # ç¦ç”¨swap
sysfs             # sysfs (å·²åºŸå¼ƒ)
_sysctl           # sysctl (å·²åºŸå¼ƒ)
umount            # å¸è½½
umount2           # å¸è½½
unshare           # åˆ›å»ºnamespace
uselib            # ä½¿ç”¨å…±äº«åº“ (å·²åºŸå¼ƒ)
userfaultfd       # ç”¨æˆ·æ•…éšœå¤„ç†
ustat             # æ–‡ä»¶ç³»ç»Ÿç»Ÿè®¡ (å·²åºŸå¼ƒ)
vm86              # VM86æ¨¡å¼
vm86old           # VM86æ¨¡å¼ (æ—§)
```

#### 2.4.3 AppArmor / SELinux

**AppArmoré…ç½®æ–‡ä»¶**:

```bash
# /etc/apparmor.d/docker-default
#include <tunables/global>

profile docker-default flags=(attach_disconnected,mediate_deleted) {
  #include <abstractions/base>

  # ç½‘ç»œè®¿é—®
  network inet tcp,
  network inet udp,
  network inet icmp,

  # æ–‡ä»¶è®¿é—®
  deny @{PROC}/* w,                      # ç¦æ­¢å†™/proc
  deny @{PROC}/sys/kernel/ns_last_pid w, # ç¦æ­¢æ“ä½œnamespace
  deny @{PROC}/sys/vm/* w,               # ç¦æ­¢æ“ä½œvm
  deny @{PROC}/sysrq-trigger rwklx,      # ç¦æ­¢sysrq
  deny @{PROC}/sys/kernel/panic* w,      # ç¦æ­¢è§¦å‘panic
  deny @{PROC}/sys/kernel/core_pattern w, # ç¦æ­¢ä¿®æ”¹core_pattern
  deny @{PROC}/sys/kernel/modprobe w,    # ç¦æ­¢ä¿®æ”¹modprobe
  deny @{PROC}/sys/kernel/hotplug w,     # ç¦æ­¢ä¿®æ”¹hotplug
  
  # å…è®¸è¯»/sys
  @{PROC}/sys/kernel/version r,
  @{PROC}/sys/net/core/somaxconn r,
  
  # å…è®¸mount (ä»…é™ç‰¹å®šç±»å‹)
  mount fstype=(aufs, bind, btrfs, ext*, overlay, proc, sysfs, tmpfs, vfat),
  
  # ç¦æ­¢å±é™©æ“ä½œ
  deny /sys/[^f]*/** wklx,
  deny /sys/f[^s]*/** wklx,
  deny /sys/fs/[^c]*/** wklx,
  deny /sys/fs/c[^g]*/** wklx,
  deny /sys/fs/cg[^r]*/** wklx,
  deny /sys/firmware/** rwklx,
  deny /sys/kernel/security/** rwklx,
  
  # Capabilityé™åˆ¶
  capability chown,
  capability dac_override,
  capability fowner,
  capability fsetid,
  capability kill,
  capability setgid,
  capability setuid,
  capability setpcap,
  capability net_bind_service,
  capability net_raw,
  capability sys_chroot,
  capability mknod,
  capability audit_write,
  capability setfcap,
  
  # ç¦æ­¢å±é™©capability
  deny capability sys_admin,
  deny capability sys_module,
  deny capability sys_rawio,
  deny capability sys_ptrace,
}
```

**SELinuxå®¹å™¨ç­–ç•¥**:

```bash
# SELinux Type Enforcement
# container_t: å®¹å™¨è¿›ç¨‹çš„åŸŸ
# container_file_t: å®¹å™¨æ–‡ä»¶çš„ç±»å‹
# svirt_sandbox_file_t: å®¹å™¨æ²™ç®±æ–‡ä»¶

# å…è®¸å®¹å™¨è¯»å†™è‡ªå·±çš„æ–‡ä»¶
allow container_t container_file_t:file { read write open getattr };
allow container_t container_file_t:dir { read search };

# ç¦æ­¢å®¹å™¨è®¿é—®hostæ–‡ä»¶
neverallow container_t host_t:file { read write };

# å…è®¸å®¹å™¨ç½‘ç»œæ“ä½œ
allow container_t self:tcp_socket { create connect bind listen accept };
allow container_t self:udp_socket { create bind };

# ç¦æ­¢å®¹å™¨åŠ è½½å†…æ ¸æ¨¡å—
neverallow container_t kernel_module_t:system module_load;

# ç¦æ­¢å®¹å™¨ä¿®æ”¹SELinuxç­–ç•¥
neverallow container_t security_t:security { setenforce setbool };
```

#### 2.4.4 User Namespace

**User Namespaceçš„UID/GIDæ˜ å°„**:

```c
// kernel/user_namespace.c

struct user_namespace {
    struct uid_gid_map uid_map;        // UIDæ˜ å°„
    struct uid_gid_map gid_map;        // GIDæ˜ å°„
    struct uid_gid_map projid_map;     // Project IDæ˜ å°„
    atomic_t count;
    struct user_namespace *parent;
    int level;
    kuid_t owner;                      // åˆ›å»ºè€…çš„UID
    kgid_t group;                      // åˆ›å»ºè€…çš„GID
    struct ns_common ns;
    unsigned long flags;
    struct key *persistent_keyring_register;
    struct work_struct work;
    struct ctl_table_set set;
    struct ctl_table_header *sysctls;
};

// UID/GIDæ˜ å°„ç»“æ„
struct uid_gid_map {
    u32 nr_extents;                    // æ˜ å°„æ¡ç›®æ•°é‡
    union {
        struct uid_gid_extent extent[UID_GID_MAP_MAX_BASE_EXTENTS];
        struct {
            struct uid_gid_extent *forward;
            struct uid_gid_extent *reverse;
        };
    };
};

struct uid_gid_extent {
    u32 first;                         // namespaceä¸­çš„èµ·å§‹ID
    u32 lower_first;                   // hostä¸­çš„èµ·å§‹ID
    u32 count;                         // æ˜ å°„æ•°é‡
};
```

**é…ç½®UID/GIDæ˜ å°„**:

```bash
# åˆ›å»ºuser namespace
unshare --user --map-root-user /bin/bash

# æ‰‹åŠ¨é…ç½®æ˜ å°„
# /proc/$PID/uid_map å’Œ /proc/$PID/gid_map

# æ ¼å¼: <å†…éƒ¨ID> <å¤–éƒ¨ID> <é•¿åº¦>
echo "0 1000 1" > /proc/$$/uid_map
echo "1 1001 999" >> /proc/$$/uid_map

# è¿™å°†:
#   - namespaceå†…çš„UID 0 æ˜ å°„åˆ° hostçš„UID 1000
#   - namespaceå†…çš„UID 1-999 æ˜ å°„åˆ° hostçš„UID 1001-1999
```

**Dockerçš„User Namespace Remap**:

```bash
# /etc/docker/daemon.json
{
  "userns-remap": "dockremap"
}

# åˆ›å»ºdockremapç”¨æˆ·
useradd -r -s /bin/false dockremap

# é…ç½®subordinate UID/GID
echo "dockremap:100000:65536" >> /etc/subuid
echo "dockremap:100000:65536" >> /etc/subgid

# é‡å¯Docker
systemctl restart docker

# ç°åœ¨å®¹å™¨å†…çš„root (UID 0) å®é™…ä¸Šæ˜¯hostçš„UID 100000
# å®¹å™¨å†…çš„UID 1 æ˜¯hostçš„UID 100001
# ...
# å®¹å™¨å†…çš„UID 65535 æ˜¯hostçš„UID 165535
```

**User Namespaceçš„å®‰å…¨ä¼˜åŠ¿**:

```text
ä¼ ç»Ÿå®¹å™¨:
  å®¹å™¨å†…root (UID 0) == Host root (UID 0)
  âš ï¸ å¦‚æœå®¹å™¨é€ƒé€¸ï¼Œæ”»å‡»è€…è·å¾—host rootæƒé™

User Namespaceå®¹å™¨:
  å®¹å™¨å†…root (UID 0) == Hostæ™®é€šç”¨æˆ· (UID 100000)
  âœ… å³ä½¿å®¹å™¨é€ƒé€¸ï¼Œæ”»å‡»è€…åªè·å¾—æ™®é€šç”¨æˆ·æƒé™
```

---

## ç¬¬ä¸‰éƒ¨åˆ†ï¼šå®¹å™¨åŒ–çš„ç¡¬ä»¶è§„èŒƒä¸æ¥å£

### 3.1 OCI (Open Container Initiative) è§„èŒƒ

#### 3.1.1 OCI Runtime Specification

**å®¹å™¨çŠ¶æ€è½¬æ¢**:

```text
   creating
      |
      v
   created  <-------------------+
      |                         |
      | (start)                 |
      v                         |
   running ----------------+    |
      |                    |    |
      | (kill/stop)        |    |
      v                    |    |
   stopped  <--------------+    |
      |                         |
      | (delete)                |
      +-------------------------+
```

**config.jsonç»“æ„**:

```json
{
  "ociVersion": "1.0.2",
  "process": {
    "terminal": true,
    "user": {
      "uid": 0,
      "gid": 0,
      "additionalGids": [5, 6]
    },
    "args": ["/bin/sh"],
    "env": [
      "PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin",
      "TERM=xterm"
    ],
    "cwd": "/",
    "capabilities": {
      "bounding": ["CAP_AUDIT_WRITE", "CAP_KILL", "CAP_NET_BIND_SERVICE"],
      "effective": ["CAP_AUDIT_WRITE", "CAP_KILL"],
      "inheritable": ["CAP_AUDIT_WRITE", "CAP_KILL", "CAP_NET_BIND_SERVICE"],
      "permitted": ["CAP_AUDIT_WRITE", "CAP_KILL", "CAP_NET_BIND_SERVICE"]
    },
    "rlimits": [
      {
        "type": "RLIMIT_NOFILE",
        "hard": 1024,
        "soft": 1024
      }
    ],
    "noNewPrivileges": true
  },
  "root": {
    "path": "rootfs",
    "readonly": false
  },
  "hostname": "mycontainer",
  "mounts": [
    {
      "destination": "/proc",
      "type": "proc",
      "source": "proc"
    },
    {
      "destination": "/dev",
      "type": "tmpfs",
      "source": "tmpfs",
      "options": ["nosuid", "strictatime", "mode=755", "size=65536k"]
    },
    {
      "destination": "/dev/pts",
      "type": "devpts",
      "source": "devpts",
      "options": ["nosuid", "noexec", "newinstance", "ptmxmode=0666", "mode=0620"]
    },
    {
      "destination": "/sys",
      "type": "sysfs",
      "source": "sysfs",
      "options": ["nosuid", "noexec", "nodev", "ro"]
    }
  ],
  "linux": {
    "namespaces": [
      {"type": "pid"},
      {"type": "network"},
      {"type": "ipc"},
      {"type": "uts"},
      {"type": "mount"}
    ],
    "uidMappings": [
      {
        "containerID": 0,
        "hostID": 1000,
        "size": 1
      }
    ],
    "gidMappings": [
      {
        "containerID": 0,
        "hostID": 1000,
        "size": 1
      }
    ],
    "devices": [
      {
        "path": "/dev/null",
        "type": "c",
        "major": 1,
        "minor": 3,
        "fileMode": 438,
        "uid": 0,
        "gid": 0
      }
    ],
    "cgroupsPath": "/mycontainer",
    "resources": {
      "memory": {
        "limit": 536870912,
        "reservation": 268435456,
        "swap": 536870912
      },
      "cpu": {
        "shares": 1024,
        "quota": 100000,
        "period": 100000,
        "cpus": "0-3"
      },
      "blockIO": {
        "weight": 500,
        "weightDevice": [
          {
            "major": 8,
            "minor": 0,
            "weight": 600
          }
        ],
        "throttleReadBpsDevice": [
          {
            "major": 8,
            "minor": 0,
            "rate": 10485760
          }
        ]
      },
      "pids": {
        "limit": 1024
      }
    },
    "seccomp": {
      "defaultAction": "SCMP_ACT_ERRNO",
      "architectures": ["SCMP_ARCH_X86_64"],
      "syscalls": [
        {
          "names": ["read", "write", "exit", "exit_group"],
          "action": "SCMP_ACT_ALLOW"
        }
      ]
    }
  }
}
```

#### 3.1.2 OCI Image Specification

**Image Manifest**:

```json
{
  "schemaVersion": 2,
  "config": {
    "mediaType": "application/vnd.oci.image.config.v1+json",
    "digest": "sha256:b5b2b2c507a0944348e0303114d8d93aaaa081732b86451d9bce1f432a537bc7",
    "size": 7023
  },
  "layers": [
    {
      "mediaType": "application/vnd.oci.image.layer.v1.tar+gzip",
      "digest": "sha256:e692418e4cbaf90ca69d05a66403747baa33ee08806650b51fab815ad7fc331f",
      "size": 32654
    },
    {
      "mediaType": "application/vnd.oci.image.layer.v1.tar+gzip",
      "digest": "sha256:3c3a4604a545cdc127456d94e421cd355bca5b528f4a9c1905b15da2eb4a4c6b",
      "size": 16724
    }
  ],
  "annotations": {
    "org.opencontainers.image.created": "2025-01-15T14:20:45Z",
    "org.opencontainers.image.authors": "Example <example@example.com>",
    "org.opencontainers.image.title": "My Application",
    "org.opencontainers.image.version": "1.0.0"
  }
}
```

**Image Config**:

```json
{
  "created": "2025-01-15T14:20:45Z",
  "author": "Example <example@example.com>",
  "architecture": "amd64",
  "os": "linux",
  "config": {
    "User": "1000:1000",
    "ExposedPorts": {
      "8080/tcp": {}
    },
    "Env": [
      "PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin",
      "APP_ENV=production"
    ],
    "Entrypoint": ["/usr/bin/myapp"],
    "Cmd": ["--config", "/etc/myapp/config.yaml"],
    "Volumes": {
      "/data": {}
    },
    "WorkingDir": "/app",
    "Labels": {
      "version": "1.0.0",
      "maintainer": "example@example.com"
    }
  },
  "rootfs": {
    "type": "layers",
    "diff_ids": [
      "sha256:c6f988f4874bb0add23a778f753c65efe992244e148a1d2ec2a8b664fb66bbd1",
      "sha256:5f70bf18a086007016e948b04aed3b82103a36bea41755b6cddfaf10ace3c6ef"
    ]
  },
  "history": [
    {
      "created": "2025-01-15T14:10:30Z",
      "created_by": "/bin/sh -c #(nop) ADD file:abc123... in /",
      "comment": "Base layer"
    },
    {
      "created": "2025-01-15T14:15:20Z",
      "created_by": "/bin/sh -c apt-get update && apt-get install -y myapp",
      "comment": "Install application"
    },
    {
      "created": "2025-01-15T14:20:45Z",
      "created_by": "/bin/sh -c #(nop) CMD [\"--config\" \"/etc/myapp/config.yaml\"]",
      "empty_layer": true
    }
  ]
}
```

### 3.2 CRI (Container Runtime Interface) è§„èŒƒ

**CRI gRPCæ¥å£** (Kubernetes Runtime):

```protobuf
// CRI service definition
service RuntimeService {
    // Sandbox (Pod) ç®¡ç†
    rpc RunPodSandbox(RunPodSandboxRequest) returns (RunPodSandboxResponse) {}
    rpc StopPodSandbox(StopPodSandboxRequest) returns (StopPodSandboxResponse) {}
    rpc RemovePodSandbox(RemovePodSandboxRequest) returns (RemovePodSandboxResponse) {}
    rpc PodSandboxStatus(PodSandboxStatusRequest) returns (PodSandboxStatusResponse) {}
    rpc ListPodSandbox(ListPodSandboxRequest) returns (ListPodSandboxResponse) {}
    
    // Containerç®¡ç†
    rpc CreateContainer(CreateContainerRequest) returns (CreateContainerResponse) {}
    rpc StartContainer(StartContainerRequest) returns (StartContainerResponse) {}
    rpc StopContainer(StopContainerRequest) returns (StopContainerResponse) {}
    rpc RemoveContainer(RemoveContainerRequest) returns (RemoveContainerResponse) {}
    rpc ListContainers(ListContainersRequest) returns (ListContainersResponse) {}
    rpc ContainerStatus(ContainerStatusRequest) returns (ContainerStatusResponse) {}
    
    // Containeræ‰§è¡Œ
    rpc ExecSync(ExecSyncRequest) returns (ExecSyncResponse) {}
    rpc Exec(ExecRequest) returns (ExecResponse) {}
    rpc Attach(AttachRequest) returns (AttachResponse) {}
    
    // å…¶ä»–
    rpc UpdateRuntimeConfig(UpdateRuntimeConfigRequest) returns (UpdateRuntimeConfigResponse) {}
    rpc Status(StatusRequest) returns (StatusResponse) {}
}

service ImageService {
    // Imageç®¡ç†
    rpc ListImages(ListImagesRequest) returns (ListImagesResponse) {}
    rpc ImageStatus(ImageStatusRequest) returns (ImageStatusResponse) {}
    rpc PullImage(PullImageRequest) returns (PullImageResponse) {}
    rpc RemoveImage(RemoveImageRequest) returns (RemoveImageResponse) {}
    rpc ImageFsInfo(ImageFsInfoRequest) returns (ImageFsInfoResponse) {}
}
```

**PodSandboxConfigç¤ºä¾‹**:

```protobuf
message PodSandboxConfig {
    PodSandboxMetadata metadata = 1;
    string hostname = 2;
    string log_directory = 3;
    DNSConfig dns_config = 4;
    repeated PortMapping port_mappings = 5;
    map<string, string> labels = 6;
    map<string, string> annotations = 7;
    LinuxPodSandboxConfig linux = 8;
}

message LinuxPodSandboxConfig {
    string cgroup_parent = 1;
    NamespaceOption security_context = 2;
    repeated Sysctls sysctls = 3;
}
```

### 3.3 CNI (Container Network Interface) è§„èŒƒ

**CNI Pluginæ¥å£**:

```go
// github.com/containernetworking/cni/pkg/types

// CNI Pluginéœ€è¦å®ç°çš„å‘½ä»¤
type CNI interface {
    AddNetwork(net *NetworkConfig, rt *RuntimeConf) (types.Result, error)
    DelNetwork(net *NetworkConfig, rt *RuntimeConf) error
    CheckNetwork(net *NetworkConfig, rt *RuntimeConf) error
}

// ç½‘ç»œé…ç½®
type NetworkConfig struct {
    CNIVersion string `json:"cniVersion"`
    Name       string `json:"name"`
    Type       string `json:"type"`
    Args       map[string]string `json:"args"`
    IPAM       struct {
        Type string `json:"type"`
    } `json:"ipam"`
    DNS DNSConfig `json:"dns"`
}

// ADDæ“ä½œçš„è¿”å›ç»“æœ
type Result struct {
    CNIVersion string    `json:"cniVersion"`
    Interfaces []Interface `json:"interfaces"`
    IPs        []IPConfig `json:"ips"`
    Routes     []Route    `json:"routes"`
    DNS        DNSConfig  `json:"dns"`
}
```

**CNIé…ç½®ç¤ºä¾‹**:

```json
{
  "cniVersion": "0.4.0",
  "name": "mynet",
  "type": "bridge",
  "bridge": "cni0",
  "isGateway": true,
  "ipMasq": true,
  "ipam": {
    "type": "host-local",
    "subnet": "10.244.0.0/16",
    "routes": [
      { "dst": "0.0.0.0/0" }
    ]
  },
  "dns": {
    "nameservers": ["10.96.0.10"]
  }
}
```

**CNI Pluginè°ƒç”¨æµç¨‹**:

```bash
# ADD: åˆ›å»ºç½‘ç»œæ¥å£
CNI_COMMAND=ADD \
CNI_CONTAINERID=abc123 \
CNI_NETNS=/var/run/netns/abc123 \
CNI_IFNAME=eth0 \
CNI_PATH=/opt/cni/bin \
/opt/cni/bin/bridge < /etc/cni/net.d/10-mynet.conf

# è¿”å›JSON (stdout):
{
  "cniVersion": "0.4.0",
  "interfaces": [
    {
      "name": "cni0",
      "mac": "aa:bb:cc:dd:ee:ff"
    },
    {
      "name": "veth123",
      "mac": "00:11:22:33:44:55"
    },
    {
      "name": "eth0",
      "mac": "66:77:88:99:aa:bb",
      "sandbox": "/var/run/netns/abc123"
    }
  ],
  "ips": [
    {
      "version": "4",
      "address": "10.244.0.5/16",
      "gateway": "10.244.0.1",
      "interface": 2
    }
  ],
  "routes": [
    {
      "dst": "0.0.0.0/0",
      "gw": "10.244.0.1"
    }
  ],
  "dns": {
    "nameservers": ["10.96.0.10"]
  }
}

# DEL: åˆ é™¤ç½‘ç»œæ¥å£
CNI_COMMAND=DEL \
CNI_CONTAINERID=abc123 \
CNI_NETNS=/var/run/netns/abc123 \
CNI_IFNAME=eth0 \
CNI_PATH=/opt/cni/bin \
/opt/cni/bin/bridge < /etc/cni/net.d/10-mynet.conf
```

### 3.4 CSI (Container Storage Interface) è§„èŒƒ

**CSI gRPCæ¥å£**:

```protobuf
// CSI Serviceå®šä¹‰
service Identity {
    rpc GetPluginInfo(GetPluginInfoRequest) returns (GetPluginInfoResponse) {}
    rpc GetPluginCapabilities(GetPluginCapabilitiesRequest) returns (GetPluginCapabilitiesResponse) {}
    rpc Probe(ProbeRequest) returns (ProbeResponse) {}
}

service Controller {
    rpc CreateVolume(CreateVolumeRequest) returns (CreateVolumeResponse) {}
    rpc DeleteVolume(DeleteVolumeRequest) returns (DeleteVolumeResponse) {}
    rpc ControllerPublishVolume(ControllerPublishVolumeRequest) returns (ControllerPublishVolumeResponse) {}
    rpc ControllerUnpublishVolume(ControllerUnpublishVolumeRequest) returns (ControllerUnpublishVolumeResponse) {}
    rpc ValidateVolumeCapabilities(ValidateVolumeCapabilitiesRequest) returns (ValidateVolumeCapabilitiesResponse) {}
    rpc ListVolumes(ListVolumesRequest) returns (ListVolumesResponse) {}
    rpc GetCapacity(GetCapacityRequest) returns (GetCapacityResponse) {}
    rpc CreateSnapshot(CreateSnapshotRequest) returns (CreateSnapshotResponse) {}
    rpc DeleteSnapshot(DeleteSnapshotRequest) returns (DeleteSnapshotResponse) {}
    rpc ListSnapshots(ListSnapshotsRequest) returns (ListSnapshotsResponse) {}
    rpc ControllerExpandVolume(ControllerExpandVolumeRequest) returns (ControllerExpandVolumeResponse) {}
}

service Node {
    rpc NodeStageVolume(NodeStageVolumeRequest) returns (NodeStageVolumeResponse) {}
    rpc NodeUnstageVolume(NodeUnstageVolumeRequest) returns (NodeUnstageVolumeResponse) {}
    rpc NodePublishVolume(NodePublishVolumeRequest) returns (NodePublishVolumeResponse) {}
    rpc NodeUnpublishVolume(NodeUnpublishVolumeRequest) returns (NodeUnpublishVolumeResponse) {}
    rpc NodeGetVolumeStats(NodeGetVolumeStatsRequest) returns (NodeGetVolumeStatsResponse) {}
    rpc NodeExpandVolume(NodeExpandVolumeRequest) returns (NodeExpandVolumeResponse) {}
    rpc NodeGetCapabilities(NodeGetCapabilitiesRequest) returns (NodeGetCapabilitiesResponse) {}
    rpc NodeGetInfo(NodeGetInfoRequest) returns (NodeGetInfoResponse) {}
}
```

**CSI Volumeç”Ÿå‘½å‘¨æœŸ**:

```text
åˆ›å»ºé˜¶æ®µ:
  CreateVolume (Controller) -> Volume Created
       |
       v
  ControllerPublishVolume (Controller) -> Volume Attached to Node
       |
       v
  NodeStageVolume (Node) -> Volume Staged (æ ¼å¼åŒ–/æŒ‚è½½åˆ°Globalç›®å½•)
       |
       v
  NodePublishVolume (Node) -> Volume Published (ç»‘å®šåˆ°Podç›®å½•)

ä½¿ç”¨é˜¶æ®µ:
  Podä½¿ç”¨Volume

åˆ é™¤é˜¶æ®µ:
  NodeUnpublishVolume (Node) -> Volume Unpublished
       |
       v
  NodeUnstageVolume (Node) -> Volume Unstaged
       |
       v
  ControllerUnpublishVolume (Controller) -> Volume Detached
       |
       v
  DeleteVolume (Controller) -> Volume Deleted
```

## ç¬¬å››éƒ¨åˆ†ï¼šå½¢å¼åŒ–å®šä¹‰ä¸æ•°å­¦æ¨¡å‹

### 4.1 è™šæ‹ŸåŒ–çš„å½¢å¼åŒ–å®šä¹‰

#### 4.1.1 Popek-Goldbergè™šæ‹ŸåŒ–å®šç†

**ç»å…¸è™šæ‹ŸåŒ–å®šä¹‰**:

```text
ä¸€ä¸ªè™šæ‹Ÿæœºç›‘æ§å™¨(VMM)å¿…é¡»æ»¡è¶³ä¸‰ä¸ªæ€§è´¨:
  1. Equivalence (ç­‰ä»·æ€§): åœ¨VMMä¸Šè¿è¡Œçš„ç¨‹åºè¡Œä¸ºåº”ä¸ç›´æ¥åœ¨ç¡¬ä»¶ä¸Šè¿è¡Œç›¸åŒ
  2. Resource Control (èµ„æºæ§åˆ¶): VMMå¿…é¡»å®Œå…¨æ§åˆ¶è™šæ‹ŸåŒ–èµ„æº
  3. Efficiency (æ•ˆç‡): å¤§éƒ¨åˆ†æŒ‡ä»¤åº”ç›´æ¥åœ¨ç¡¬ä»¶ä¸Šæ‰§è¡Œ,æ— éœ€VMMå¹²é¢„
```

**æŒ‡ä»¤åˆ†ç±»**:

```haskell
-- æŒ‡ä»¤é›†åˆ†ç±»
data Instruction =
    Privileged Instruction      -- ç‰¹æƒæŒ‡ä»¤
  | Sensitive Instruction      -- æ•æ„ŸæŒ‡ä»¤
  | Innocent Instruction       -- æ— å®³æŒ‡ä»¤

-- æ•æ„ŸæŒ‡ä»¤çš„ä¸¤ç±»
data SensitiveType =
    ControlSensitive           -- æ§åˆ¶æ•æ„Ÿ (å½±å“ç³»ç»Ÿé…ç½®/èµ„æºåˆ†é…)
  | BehaviorSensitive         -- è¡Œä¸ºæ•æ„Ÿ (è¡Œä¸ºä¾èµ–äºç³»ç»ŸçŠ¶æ€)

-- Popek-Goldbergå®šç†
popek_goldberg_theorem :: InstructionSet -> Bool
popek_goldberg_theorem isa =
    -- å¯è™šæ‹ŸåŒ–çš„å……åˆ†æ¡ä»¶:
    -- æ‰€æœ‰æ•æ„ŸæŒ‡ä»¤éƒ½æ˜¯ç‰¹æƒæŒ‡ä»¤
    all_sensitive_instructions isa `isSubsetOf` all_privileged_instructions isa

-- x86çš„é—®é¢˜: å­˜åœ¨æ•æ„Ÿä½†éç‰¹æƒæŒ‡ä»¤
x86_violates_pg :: Bool
x86_violates_pg = True
-- ä¾‹å¦‚: SGDT, SIDT, SLDT, SMSW ç­‰æŒ‡ä»¤
-- è¿™äº›æŒ‡ä»¤åœ¨Ring 3å¯ä»¥æ‰§è¡Œ,ä½†ä¼šæš´éœ²ç‰¹æƒä¿¡æ¯
```

**å½¢å¼åŒ–è™šæ‹Ÿæœºæ¨¡å‹**:

```coq
(* Coqå½¢å¼åŒ–å®šä¹‰ *)

(* æœºå™¨çŠ¶æ€ *)
Record MachineState := {
    cpu : CPUState;
    memory : Memory;
    privilege_level : PrivilegeLevel
}.

(* æŒ‡ä»¤è¯­ä¹‰ *)
Definition InstructionSemantics := MachineState -> MachineState.

(* è™šæ‹Ÿæœºç›‘æ§å™¨ *)
Record VMM := {
    host_state : MachineState;
    guest_states : list MachineState;
    schedule : nat -> option nat;  (* è°ƒåº¦å‡½æ•° *)
    trap_handler : Instruction -> MachineState -> MachineState
}.

(* ç­‰ä»·æ€§æ€§è´¨ *)
Definition equivalence_property (vmm : VMM) (prog : list Instruction) : Prop :=
    forall (initial_state : MachineState),
        (* ç›´æ¥æ‰§è¡Œ *)
        let direct_result := execute_program prog initial_state in
        (* è™šæ‹ŸåŒ–æ‰§è¡Œ *)
        let virtual_result := execute_in_vm vmm prog initial_state in
        (* ç»“æœåº”ç›¸åŒ (é™¤äº†timing) *)
        observationally_equivalent direct_result virtual_result.

(* èµ„æºæ§åˆ¶æ€§è´¨ *)
Definition resource_control_property (vmm : VMM) : Prop :=
    forall (guest_id : nat) (resource : Resource),
        (* Gueståªèƒ½è®¿é—®VMMæˆæƒçš„èµ„æº *)
        guest_can_access guest_id resource ->
        vmm_grants_access vmm guest_id resource.

(* æ•ˆç‡æ€§è´¨ *)
Definition efficiency_property (vmm : VMM) (prog : list Instruction) : Prop :=
    (* å¤§å¤šæ•°æŒ‡ä»¤ç›´æ¥æ‰§è¡Œ,åªæœ‰æ•æ„ŸæŒ‡ä»¤æ‰trap *)
    (count_trapped_instructions vmm prog) < (k * length prog)
    (* kæ˜¯ä¸€ä¸ªå°çš„å¸¸æ•° *)
```

#### 4.1.2 ç±»å‹ç³»ç»Ÿè§†è§’ä¸‹çš„è™šæ‹ŸåŒ–

**è™šæ‹ŸåŒ–çš„ç±»å‹å®‰å…¨**:

```haskell
-- èµ„æºçš„ç±»å‹ç³»ç»Ÿ
data ResourceType =
    CPUResource Int           -- CPUæ ¸å¿ƒæ•°
  | MemoryResource Int        -- å†…å­˜å¤§å°(MB)
  | NetworkResource Int       -- ç½‘ç»œå¸¦å®½(Mbps)
  | StorageResource Int       -- å­˜å‚¨å®¹é‡(GB)

-- è™šæ‹Ÿæœºçš„èµ„æºç­¾å
type VMSignature = [ResourceType]

-- Hypervisorçš„èµ„æºæ± 
data HypervisorPool = Pool {
    available :: [ResourceType],
    allocated :: Map VMID VMSignature
}

-- èµ„æºåˆ†é…çš„ç±»å‹å®‰å…¨
allocate_vm :: VMSignature -> HypervisorPool -> Maybe (VMID, HypervisorPool)
allocate_vm sig pool =
    if can_allocate sig (available pool)
    then let vm_id = fresh_id pool
             new_pool = Pool {
                 available = subtract_resources (available pool) sig,
                 allocated = Map.insert vm_id sig (allocated pool)
             }
         in Just (vm_id, new_pool)
    else Nothing

-- ç±»å‹å®‰å…¨æ€§è´¨: å·²åˆ†é…èµ„æºä¹‹å’Œä¸è¶…è¿‡æ€»èµ„æº
type_safety :: HypervisorPool -> Bool
type_safety pool =
    sum (Map.elems (allocated pool)) <= total_resources pool
```

### 4.2 å®¹å™¨çš„å½¢å¼åŒ–å®šä¹‰

#### 4.2.1 å®¹å™¨çš„ä»£æ•°å®šä¹‰

```haskell
-- å®¹å™¨çš„ä»£æ•°ç»“æ„
data Container = Container {
    image :: Image,
    namespaces :: [Namespace],
    cgroups :: CgroupTree,
    rootfs :: Filesystem,
    process :: Process
}

-- Namespaceçš„ä»£æ•°æ€§è´¨
-- Namespaceå½¢æˆä¸€ä¸ªååºé›† (Partially Ordered Set)
instance PartialOrder Namespace where
    (<=) ns1 ns2 = ns1 `is_ancestor_of` ns2

-- Namespaceçš„å±‚çº§ç»“æ„
data NamespaceHierarchy = NS {
    level :: Int,
    parent :: Maybe NamespaceHierarchy,
    children :: [NamespaceHierarchy]
}

-- Namespaceéš”ç¦»çš„æ•°å­¦æ€§è´¨
namespace_isolation :: Namespace -> Namespace -> Bool
namespace_isolation ns1 ns2 =
    -- ä¸ç›¸äº¤æ€§: ä¸åŒçš„namespaceä¸å…±äº«çŠ¶æ€
    disjoint (state_space ns1) (state_space ns2)
    ||
    -- æˆ–è€…æ˜¯çˆ¶å­å…³ç³»
    (ns1 <= ns2 || ns2 <= ns1)

-- Cgroupå½¢æˆä¸€ä¸ªæ ‘ç»“æ„
data CgroupTree = Node {
    name :: String,
    resources :: ResourceQuota,
    children :: [CgroupTree]
}

-- Cgroupçš„å•è°ƒæ€§
cgroup_monotonicity :: CgroupTree -> Resource -> Bool
cgroup_monotonicity tree res =
    -- å­cgroupçš„èµ„æºé™åˆ¶ä¸è¶…è¿‡çˆ¶cgroup
    all (\child -> limit child res <= limit tree res) (children tree)
```

#### 4.2.2 å®¹å™¨ç»„åˆçš„èŒƒç•´è®ºè§†è§’

```haskell
-- å®¹å™¨ä½œä¸ºèŒƒç•´ä¸­çš„å¯¹è±¡
-- Category of Containers

-- æ€å°„ (Morphism): å®¹å™¨ä¹‹é—´çš„æ˜ å°„
data ContainerMorphism = CM {
    source :: Container,
    target :: Container,
    image_map :: Image -> Image,           -- é•œåƒæ˜ å°„
    namespace_map :: Namespace -> Namespace, -- Namespaceæ˜ å°„
    filesystem_map :: Filesystem -> Filesystem -- æ–‡ä»¶ç³»ç»Ÿæ˜ å°„
}

-- æ’ç­‰æ€å°„
identity_morphism :: Container -> ContainerMorphism
identity_morphism c = CM {
    source = c,
    target = c,
    image_map = id,
    namespace_map = id,
    filesystem_map = id
}

-- æ€å°„ç»„åˆ
compose :: ContainerMorphism -> ContainerMorphism -> ContainerMorphism
compose f g = CM {
    source = source g,
    target = target f,
    image_map = (image_map f) . (image_map g),
    namespace_map = (namespace_map f) . (namespace_map g),
    filesystem_map = (filesystem_map f) . (filesystem_map g)
}

-- èŒƒç•´å…¬ç†
-- 1. ç»“åˆå¾‹
associativity :: ContainerMorphism -> ContainerMorphism -> ContainerMorphism -> Bool
associativity f g h =
    compose (compose f g) h == compose f (compose g h)

-- 2. å•ä½å…ƒ
identity_law :: ContainerMorphism -> Bool
identity_law f =
    compose f (identity_morphism (source f)) == f &&
    compose (identity_morphism (target f)) f == f

-- Functor: ä»Dockeråˆ°Kubernetesçš„æ˜ å°„
data DockerToK8sFunctor = Functor {
    -- å¯¹è±¡æ˜ å°„
    object_map :: Container -> Pod,
    -- æ€å°„æ˜ å°„
    morphism_map :: ContainerMorphism -> PodMorphism
}

-- Functorä¿æŒç»“æ„
functor_preserves_composition :: DockerToK8sFunctor -> ContainerMorphism -> ContainerMorphism -> Bool
functor_preserves_composition F f g =
    morphism_map F (compose f g) == compose_pods (morphism_map F f) (morphism_map F g)
```

### 4.3 éš”ç¦»æ€§çš„å½¢å¼åŒ–è¯æ˜

#### 4.3.1 å†…å­˜éš”ç¦»çš„å½¢å¼åŒ–

```coq
(* Coqå®šç†è¯æ˜ *)

(* å®¹å™¨çš„å†…å­˜æ¨¡å‹ *)
Definition ContainerMemory := nat -> option byte.

(* å†…å­˜éš”ç¦»æ€§è´¨ *)
Definition memory_isolation (c1 c2 : Container) : Prop :=
    forall (addr : nat),
        (* å¦‚æœc1å¯ä»¥è®¿é—®addr *)
        (can_access c1 addr) ->
        (* åˆ™c2ä¸èƒ½è®¿é—®addr *)
        ~(can_access c2 addr).

(* å®šç†: Namespace + Cgroupä¿è¯å†…å­˜éš”ç¦» *)
Theorem namespace_cgroup_ensures_isolation :
    forall (c1 c2 : Container),
        different_namespaces c1 c2 ->
        separate_cgroups c1 c2 ->
        memory_isolation c1 c2.
Proof.
    intros c1 c2 H_ns H_cg addr H_c1_access.
    unfold memory_isolation.
    intros H_c2_access.
    
    (* çŸ›ç›¾: ä¸åŒnamespaceä¸èƒ½è®¿é—®ç›¸åŒçš„åœ°å€ *)
    apply different_namespaces_disjoint_address_space in H_ns.
    apply H_ns with (addr := addr).
    - exact H_c1_access.
    - exact H_c2_access.
Qed.

(* è¾…åŠ©å¼•ç†: ä¸åŒnamespaceæœ‰ä¸ç›¸äº¤çš„åœ°å€ç©ºé—´ *)
Lemma different_namespaces_disjoint_address_space :
    forall (c1 c2 : Container) (addr : nat),
        different_namespaces c1 c2 ->
        can_access c1 addr ->
        can_access c2 addr ->
        False.
Proof.
    (* æ ¹æ®namespaceè¯­ä¹‰è¯æ˜ *)
Admitted.
```

#### 4.3.2 è¿›ç¨‹éš”ç¦»çš„å½¢å¼åŒ–

```coq
(* PID Namespaceéš”ç¦» *)
Definition ProcessID := nat.

(* è¿›ç¨‹è¡¨ *)
Definition ProcessTable := list (ProcessID * Process).

(* PID Namespace *)
Record PIDNamespace := {
    pid_range : ProcessID * ProcessID;  (* PIDèŒƒå›´ *)
    process_table : ProcessTable;       (* è¿›ç¨‹è¡¨ *)
    parent_ns : option PIDNamespace     (* çˆ¶namespace *)
}.

(* PIDéš”ç¦»æ€§è´¨ *)
Definition pid_isolation (ns1 ns2 : PIDNamespace) : Prop :=
    (* ä¸åŒnamespaceçš„PIDèŒƒå›´ä¸ç›¸äº¤ *)
    disjoint_ranges (pid_range ns1) (pid_range ns2) ->
    (* åˆ™è¿›ç¨‹è¡¨ä¸ç›¸äº¤ *)
    forall (pid : ProcessID) (p : Process),
        In (pid, p) (process_table ns1) ->
        ~In (pid, p) (process_table ns2).

(* å®šç†: PID Namespaceä¿è¯è¿›ç¨‹éš”ç¦» *)
Theorem pid_namespace_ensures_isolation :
    forall (ns1 ns2 : PIDNamespace),
        different_pid_namespaces ns1 ns2 ->
        pid_isolation ns1 ns2.
Proof.
    intros ns1 ns2 H_diff H_disjoint pid p H_in1 H_in2.
    
    (* ä»different_pid_namespacesæ¨å¯¼å‡ºèŒƒå›´ä¸ç›¸äº¤ *)
    apply different_pid_namespaces_disjoint_ranges in H_diff.
    apply H_disjoint in H_diff.
    
    (* çŸ›ç›¾: pidåœ¨ns1çš„èŒƒå›´å†…,ä½†ä¹Ÿåœ¨ns2çš„èŒƒå›´å†… *)
    apply in_process_table_in_range in H_in1.
    apply in_process_table_in_range in H_in2.
    apply H_diff with (pid := pid).
    - exact H_in1.
    - exact H_in2.
Qed.
```

#### 4.3.3 æ–‡ä»¶ç³»ç»Ÿéš”ç¦»çš„å½¢å¼åŒ–

```coq
(* Mount Namespaceéš”ç¦» *)
Record MountNamespace := {
    mount_table : list Mount;
    root_inode : Inode
}.

Record Mount := {
    mount_point : Path;
    filesystem : Filesystem;
    flags : MountFlags
}.

(* æ–‡ä»¶ç³»ç»Ÿéš”ç¦»æ€§è´¨ *)
Definition filesystem_isolation (ns1 ns2 : MountNamespace) : Prop :=
    forall (path : Path) (inode : Inode),
        (* å¦‚æœpathåœ¨ns1ä¸­è§£æåˆ°inode *)
        path_resolve ns1 path = Some inode ->
        (* å¦‚æœns1å’Œns2çš„æ ¹inodeä¸åŒ *)
        root_inode ns1 <> root_inode ns2 ->
        (* åˆ™pathåœ¨ns2ä¸­ä¸èƒ½è§£æåˆ°ç›¸åŒçš„inode *)
        path_resolve ns2 path <> Some inode.

(* OverlayFSçš„å†™æ—¶å¤åˆ¶è¯­ä¹‰ *)
Definition copy_on_write_semantics (overlay : OverlayFS) : Prop :=
    forall (file : Path) (old_content : Content) (new_content : Content),
        (* åŸæ–‡ä»¶åœ¨lowerå±‚ *)
        file_in_lower overlay file old_content ->
        (* ä¿®æ”¹æ–‡ä»¶ *)
        write_file overlay file new_content ->
        (* åˆ™lowerå±‚å†…å®¹ä¸å˜ *)
        file_in_lower overlay file old_content /\
        (* upperå±‚æœ‰æ–°å†…å®¹ *)
        file_in_upper overlay file new_content.

(* å®šç†: OverlayFSä¿è¯å†™æ—¶å¤åˆ¶è¯­ä¹‰ *)
Theorem overlayfs_preserves_cow :
    forall (overlay : OverlayFS),
        well_formed_overlay overlay ->
        copy_on_write_semantics overlay.
Proof.
    (* æ ¹æ®OverlayFSçš„copy-upæœºåˆ¶è¯æ˜ *)
Admitted.
```

### 4.4 å®‰å…¨è¾¹ç•Œçš„ç†è®ºæ¨¡å‹

#### 4.4.1 ä¿¡æ¯æµå®‰å…¨æ¨¡å‹

```haskell
-- Bell-LaPadulaæ¨¡å‹åœ¨å®¹å™¨ä¸­çš„åº”ç”¨

-- å®‰å…¨çº§åˆ«
data SecurityLevel = Unclassified | Confidential | Secret | TopSecret
    deriving (Eq, Ord)

-- ä¸»ä½“ (å®¹å™¨ã€è¿›ç¨‹)
data Subject = Subject {
    subject_id :: String,
    clearance :: SecurityLevel,
    categories :: Set Category
}

-- å®¢ä½“ (æ–‡ä»¶ã€ç½‘ç»œç«¯å£)
data Object = Object {
    object_id :: String,
    classification :: SecurityLevel,
    object_categories :: Set Category
}

-- Bell-LaPadulaè§„åˆ™
-- 1. Simple Security Property (no read up)
simple_security :: Subject -> Object -> Bool
simple_security s o =
    clearance s >= classification o &&
    (categories s) `Set.isSuperset` (object_categories o)

-- 2. *-Property (no write down)
star_property :: Subject -> Object -> Bool
star_property s o =
    clearance s <= classification o

-- å®¹å™¨ä¹‹é—´çš„ä¿¡æ¯æµ
data InformationFlow = Flow {
    source_container :: Container,
    target_container :: Container,
    channel :: Channel  -- Network, SharedMemory, etc.
}

-- ä¿¡æ¯æµå®‰å…¨æ€§
information_flow_secure :: InformationFlow -> Bool
information_flow_secure flow =
    security_level (source_container flow) <=
    security_level (target_container flow)

-- éå¹²æ‰°æ€§ (Noninterference)
-- ä½å®‰å…¨çº§åˆ«çš„å®¹å™¨ä¸åº”è§‚å¯Ÿåˆ°é«˜å®‰å…¨çº§åˆ«å®¹å™¨çš„è¡Œä¸º
noninterference :: System -> SecurityLevel -> SecurityLevel -> Bool
noninterference sys low_level high_level =
    -- å¯¹äºä½çº§åˆ«çš„è§‚å¯Ÿè€…
    forall low_observer in containers_at_level sys low_level,
        -- é«˜çº§åˆ«å®¹å™¨çš„è¡Œä¸ºä¸å½±å“ä½çº§åˆ«çš„è§‚å¯Ÿ
        observations low_observer (run sys with_high_containers) ==
        observations low_observer (run sys without_high_containers)
```

#### 4.4.2 èƒ½åŠ›å®‰å…¨æ¨¡å‹

```haskell
-- Capability-based Security

-- èƒ½åŠ› (Capability)
data Capability = Cap {
    object_ref :: ObjectReference,
    permissions :: Set Permission
}

data Permission = Read | Write | Execute | Delegate

-- ä¸»ä½“çš„èƒ½åŠ›é›†
type CapabilityList = [Capability]

-- è®¿é—®æ§åˆ¶
access_allowed :: CapabilityList -> ObjectReference -> Permission -> Bool
access_allowed caps obj_ref perm =
    any (\cap -> object_ref cap == obj_ref && perm `Set.member` permissions cap) caps

-- èƒ½åŠ›ä¼ é€’
delegate_capability :: Capability -> Subject -> Maybe Capability
delegate_capability cap target_subject =
    if Delegate `Set.member` permissions cap
    then Just $ cap { permissions = Set.delete Delegate (permissions cap) }
    else Nothing

-- æœ€å°æƒé™åŸåˆ™
principle_of_least_privilege :: Container -> CapabilityList
principle_of_least_privilege container =
    -- åªæˆäºˆå®Œæˆä»»åŠ¡æ‰€éœ€çš„æœ€å°èƒ½åŠ›é›†
    minimal_capabilities_for (required_operations container)

-- Docker Capabilitiesæ˜ å°„
docker_capabilities_to_formal :: [DockerCapability] -> CapabilityList
docker_capabilities_to_formal docker_caps =
    map (\dc -> Cap {
        object_ref = capability_object dc,
        permissions = capability_permissions dc
    }) docker_caps
```

---

## ç¬¬äº”éƒ¨åˆ†ï¼šæŠ€æœ¯çŸ¥è¯†å›¾è°±

### 5.1 æ¦‚å¿µå±‚æ¬¡ç»“æ„

```text
è™šæ‹ŸåŒ–ä¸å®¹å™¨åŒ–æŠ€æœ¯çŸ¥è¯†å›¾è°±

Level 0: è®¡ç®—åŸºç¡€
  â”œâ”€â”€ è®¡ç®—æœºä½“ç³»ç»“æ„
  â”‚   â”œâ”€â”€ CPU (æŒ‡ä»¤é›†ã€æµæ°´çº¿ã€ç¼“å­˜)
  â”‚   â”œâ”€â”€ å†…å­˜ (è™šæ‹Ÿå†…å­˜ã€MMUã€TLB)
  â”‚   â”œâ”€â”€ I/O (ä¸­æ–­ã€DMAã€æ€»çº¿)
  â”‚   â””â”€â”€ å­˜å‚¨ (ç£ç›˜ã€RAIDã€SSD)
  â””â”€â”€ æ“ä½œç³»ç»Ÿ
      â”œâ”€â”€ è¿›ç¨‹ç®¡ç†
      â”œâ”€â”€ å†…å­˜ç®¡ç†
      â”œâ”€â”€ æ–‡ä»¶ç³»ç»Ÿ
      â””â”€â”€ ç½‘ç»œæ ˆ

Level 1: ç¡¬ä»¶è™šæ‹ŸåŒ–æ”¯æŒ
  â”œâ”€â”€ CPUè™šæ‹ŸåŒ–
  â”‚   â”œâ”€â”€ Intel VT-x
  â”‚   â”‚   â”œâ”€â”€ VMX Root Mode
  â”‚   â”‚   â”œâ”€â”€ VMX Non-Root Mode
  â”‚   â”‚   â”œâ”€â”€ VMCS (Virtual Machine Control Structure)
  â”‚   â”‚   â”œâ”€â”€ VM Entry/Exit
  â”‚   â”‚   â””â”€â”€ VPID (Virtual Processor ID)
  â”‚   â”œâ”€â”€ AMD-V
  â”‚   â”‚   â”œâ”€â”€ SVM (Secure Virtual Machine)
  â”‚   â”‚   â”œâ”€â”€ VMCB (Virtual Machine Control Block)
  â”‚   â”‚   â”œâ”€â”€ ASID (Address Space ID)
  â”‚   â”‚   â””â”€â”€ NPT (Nested Page Tables)
  â”‚   â””â”€â”€ ARMè™šæ‹ŸåŒ–
  â”‚       â”œâ”€â”€ EL2 (Hypervisor Exception Level)
  â”‚       â”œâ”€â”€ Stage 2 Translation
  â”‚       â””â”€â”€ VGIC (Virtual GIC)
  â”œâ”€â”€ å†…å­˜è™šæ‹ŸåŒ–
  â”‚   â”œâ”€â”€ Shadow Page Tables
  â”‚   â”œâ”€â”€ Intel EPT (Extended Page Tables)
  â”‚   â”œâ”€â”€ AMD NPT (Nested Page Tables)
  â”‚   â””â”€â”€ ARM Stage 2 Translation
  â””â”€â”€ I/Oè™šæ‹ŸåŒ–
      â”œâ”€â”€ Intel VT-d (IOMMU)
      â”œâ”€â”€ AMD-Vi
      â”œâ”€â”€ SR-IOV (Single Root I/O Virtualization)
      â””â”€â”€ VFIO (Virtual Function I/O)

Level 2: Hypervisorå±‚
  â”œâ”€â”€ Type 1 (Bare-Metal)
  â”‚   â”œâ”€â”€ VMware ESXi
  â”‚   â”œâ”€â”€ Xen
  â”‚   â”œâ”€â”€ Microsoft Hyper-V
  â”‚   â””â”€â”€ KVM (Kernel-based Virtual Machine)
  â””â”€â”€ Type 2 (Hosted)
      â”œâ”€â”€ VMware Workstation
      â”œâ”€â”€ VirtualBox
      â””â”€â”€ QEMU

Level 3: æ“ä½œç³»ç»Ÿçº§è™šæ‹ŸåŒ– (å®¹å™¨åŒ–)
  â”œâ”€â”€ Linuxå®¹å™¨æŠ€æœ¯åŸºç¡€
  â”‚   â”œâ”€â”€ Namespaces
  â”‚   â”‚   â”œâ”€â”€ PID Namespace (è¿›ç¨‹éš”ç¦»)
  â”‚   â”‚   â”œâ”€â”€ Network Namespace (ç½‘ç»œéš”ç¦»)
  â”‚   â”‚   â”œâ”€â”€ Mount Namespace (æ–‡ä»¶ç³»ç»Ÿéš”ç¦»)
  â”‚   â”‚   â”œâ”€â”€ UTS Namespace (hostnameéš”ç¦»)
  â”‚   â”‚   â”œâ”€â”€ IPC Namespace (è¿›ç¨‹é—´é€šä¿¡éš”ç¦»)
  â”‚   â”‚   â”œâ”€â”€ User Namespace (UID/GIDéš”ç¦»)
  â”‚   â”‚   â”œâ”€â”€ Cgroup Namespace (cgroupè§†å›¾éš”ç¦»)
  â”‚   â”‚   â””â”€â”€ Time Namespace (æ—¶é’Ÿéš”ç¦»)
  â”‚   â”œâ”€â”€ Cgroups (Control Groups)
  â”‚   â”‚   â”œâ”€â”€ CPUæ§åˆ¶å™¨ (cpu, cpuacct)
  â”‚   â”‚   â”œâ”€â”€ Memoryæ§åˆ¶å™¨
  â”‚   â”‚   â”œâ”€â”€ Block I/Oæ§åˆ¶å™¨ (blkio)
  â”‚   â”‚   â”œâ”€â”€ Networkæ§åˆ¶å™¨ (net_cls, net_prio)
  â”‚   â”‚   â”œâ”€â”€ PIDæ§åˆ¶å™¨
  â”‚   â”‚   â”œâ”€â”€ Deviceæ§åˆ¶å™¨
  â”‚   â”‚   â””â”€â”€ Cgroup v2 (ç»Ÿä¸€å±‚çº§)
  â”‚   â”œâ”€â”€ Unionæ–‡ä»¶ç³»ç»Ÿ
  â”‚   â”‚   â”œâ”€â”€ AUFS
  â”‚   â”‚   â”œâ”€â”€ OverlayFS / Overlay2
  â”‚   â”‚   â”œâ”€â”€ Btrfs
  â”‚   â”‚   â”œâ”€â”€ ZFS
  â”‚   â”‚   â””â”€â”€ Device Mapper
  â”‚   â””â”€â”€ å®‰å…¨æœºåˆ¶
  â”‚       â”œâ”€â”€ Capabilities (èƒ½åŠ›)
  â”‚       â”œâ”€â”€ Seccomp (ç³»ç»Ÿè°ƒç”¨è¿‡æ»¤)
  â”‚       â”œâ”€â”€ AppArmor (å¼ºåˆ¶è®¿é—®æ§åˆ¶)
  â”‚       â”œâ”€â”€ SELinux (å®‰å…¨å¢å¼ºLinux)
  â”‚       â””â”€â”€ User Namespace (UID/GIDé‡æ˜ å°„)
  â””â”€â”€ Windowså®¹å™¨æŠ€æœ¯
      â”œâ”€â”€ Windows Server Containers
      â””â”€â”€ Hyper-V Containers

Level 4: å®¹å™¨è¿è¡Œæ—¶
  â”œâ”€â”€ é«˜çº§è¿è¡Œæ—¶
  â”‚   â”œâ”€â”€ Docker
  â”‚   â”œâ”€â”€ containerd
  â”‚   â”œâ”€â”€ CRI-O
  â”‚   â””â”€â”€ Podman
  â”œâ”€â”€ ä½çº§è¿è¡Œæ—¶
  â”‚   â”œâ”€â”€ runc (OCI Reference Implementation)
  â”‚   â”œâ”€â”€ crun (C implementation)
  â”‚   â”œâ”€â”€ kata-runtime (VM-based)
  â”‚   â”œâ”€â”€ gVisor (runsc)
  â”‚   â””â”€â”€ Firecracker
  â””â”€â”€ æ²™ç®±è¿è¡Œæ—¶
      â”œâ”€â”€ gVisor (ç”¨æˆ·æ€å†…æ ¸)
      â”œâ”€â”€ Kata Containers (è½»é‡çº§VM)
      â””â”€â”€ Firecracker (microVM)

Level 5: å®¹å™¨ç¼–æ’
  â”œâ”€â”€ Kubernetes
  â”‚   â”œâ”€â”€ æ§åˆ¶å¹³é¢
  â”‚   â”‚   â”œâ”€â”€ API Server
  â”‚   â”‚   â”œâ”€â”€ etcd
  â”‚   â”‚   â”œâ”€â”€ Scheduler
  â”‚   â”‚   â””â”€â”€ Controller Manager
  â”‚   â”œâ”€â”€ å·¥ä½œèŠ‚ç‚¹
  â”‚   â”‚   â”œâ”€â”€ kubelet
  â”‚   â”‚   â”œâ”€â”€ kube-proxy
  â”‚   â”‚   â””â”€â”€ Container Runtime (CRI)
  â”‚   â”œâ”€â”€ æ ¸å¿ƒèµ„æº
  â”‚   â”‚   â”œâ”€â”€ Pod
  â”‚   â”‚   â”œâ”€â”€ Deployment
  â”‚   â”‚   â”œâ”€â”€ StatefulSet
  â”‚   â”‚   â”œâ”€â”€ DaemonSet
  â”‚   â”‚   â”œâ”€â”€ Service
  â”‚   â”‚   â””â”€â”€ Ingress / Gateway API
  â”‚   â””â”€â”€ æ‰©å±•
  â”‚       â”œâ”€â”€ Operators
  â”‚       â”œâ”€â”€ CRD (Custom Resource Definitions)
  â”‚       â””â”€â”€ Webhooks
  â”œâ”€â”€ Docker Swarm
  â”œâ”€â”€ Apache Mesos
  â””â”€â”€ Nomad

Level 6: å®¹å™¨ç½‘ç»œ
  â”œâ”€â”€ CNI (Container Network Interface)
  â”‚   â”œâ”€â”€ Bridge
  â”‚   â”œâ”€â”€ Host
  â”‚   â”œâ”€â”€ Overlay
  â”‚   â””â”€â”€ IPAM
  â”œâ”€â”€ CNI Plugins
  â”‚   â”œâ”€â”€ Calico
  â”‚   â”œâ”€â”€ Flannel
  â”‚   â”œâ”€â”€ Cilium (eBPF-based)
  â”‚   â”œâ”€â”€ Weave Net
  â”‚   â””â”€â”€ Multus (Multi-CNI)
  â”œâ”€â”€ Service Mesh
  â”‚   â”œâ”€â”€ Istio
  â”‚   â”œâ”€â”€ Linkerd
  â”‚   â”œâ”€â”€ Consul Connect
  â”‚   â””â”€â”€ Envoy Proxy
  â””â”€â”€ ç½‘ç»œç­–ç•¥
      â”œâ”€â”€ NetworkPolicy (Kubernetes)
      â”œâ”€â”€ Cilium Network Policy
      â””â”€â”€ Calico Network Policy

Level 7: å®¹å™¨å­˜å‚¨
  â”œâ”€â”€ CSI (Container Storage Interface)
  â”œâ”€â”€ Volumeç±»å‹
  â”‚   â”œâ”€â”€ emptyDir
  â”‚   â”œâ”€â”€ hostPath
  â”‚   â”œâ”€â”€ PersistentVolume (PV)
  â”‚   â””â”€â”€ PersistentVolumeClaim (PVC)
  â”œâ”€â”€ å­˜å‚¨é©±åŠ¨
  â”‚   â”œâ”€â”€ Local Storage
  â”‚   â”œâ”€â”€ Ceph / Rook
  â”‚   â”œâ”€â”€ GlusterFS
  â”‚   â”œâ”€â”€ NFS
  â”‚   â”œâ”€â”€ iSCSI
  â”‚   â”œâ”€â”€ Longhorn
  â”‚   â””â”€â”€ OpenEBS
  â””â”€â”€ äº‘å­˜å‚¨
      â”œâ”€â”€ AWS EBS
      â”œâ”€â”€ Azure Disk
      â””â”€â”€ GCE Persistent Disk

Level 8: å®¹å™¨é•œåƒä¸Registry
  â”œâ”€â”€ OCI Image Specification
  â”œâ”€â”€ é•œåƒæ ¼å¼
  â”‚   â”œâ”€â”€ Docker Image Format
  â”‚   â”œâ”€â”€ OCI Image Format
  â”‚   â””â”€â”€ Buildah / BuildKit
  â”œâ”€â”€ Registry
  â”‚   â”œâ”€â”€ Docker Hub
  â”‚   â”œâ”€â”€ Harbor
  â”‚   â”œâ”€â”€ Quay.io
  â”‚   â”œâ”€â”€ Amazon ECR
  â”‚   â”œâ”€â”€ Google GCR
  â”‚   â””â”€â”€ Azure ACR
  â””â”€â”€ é•œåƒå®‰å…¨
      â”œâ”€â”€ é•œåƒæ‰«æ (Trivy, Clair, Anchore)
      â”œâ”€â”€ é•œåƒç­¾å (Cosign, Notary)
      â”œâ”€â”€ SBOM (Software Bill of Materials)
      â””â”€â”€ SLSA (Supply chain Levels for Software Artifacts)

Level 9: å¯è§‚æµ‹æ€§
  â”œâ”€â”€ ç›‘æ§
  â”‚   â”œâ”€â”€ Prometheus
  â”‚   â”œâ”€â”€ Grafana
  â”‚   â”œâ”€â”€ cAdvisor
  â”‚   â”œâ”€â”€ node-exporter
  â”‚   â””â”€â”€ DCGM (GPU)
  â”œâ”€â”€ æ—¥å¿—
  â”‚   â”œâ”€â”€ Fluentd / Fluent Bit
  â”‚   â”œâ”€â”€ Logstash
  â”‚   â”œâ”€â”€ Loki
  â”‚   â””â”€â”€ Elasticsearch
  â”œâ”€â”€ è¿½è¸ª
  â”‚   â”œâ”€â”€ Jaeger
  â”‚   â”œâ”€â”€ Zipkin
  â”‚   â”œâ”€â”€ Tempo
  â”‚   â””â”€â”€ OpenTelemetry
  â””â”€â”€ eBPFå¯è§‚æµ‹æ€§
      â”œâ”€â”€ Pixie
      â”œâ”€â”€ Hubble (Cilium)
      â”œâ”€â”€ Falco
      â””â”€â”€ Tetragon

Level 10: æ–°å…´æŠ€æœ¯
  â”œâ”€â”€ WebAssemblyå®¹å™¨
  â”‚   â”œâ”€â”€ WasmEdge
  â”‚   â”œâ”€â”€ Wasmtime
  â”‚   â””â”€â”€ WASI
  â”œâ”€â”€ æœºå¯†è®¡ç®—
  â”‚   â”œâ”€â”€ Intel SGX
  â”‚   â”œâ”€â”€ AMD SEV
  â”‚   â””â”€â”€ Confidential Containers
  â”œâ”€â”€ Serverless
  â”‚   â”œâ”€â”€ Knative
  â”‚   â”œâ”€â”€ OpenFaaS
  â”‚   â”œâ”€â”€ Kubeless
  â”‚   â””â”€â”€ AWS Lambda / Fargate
  â””â”€â”€ Edge Computing
      â”œâ”€â”€ K3s
      â”œâ”€â”€ KubeEdge
      â”œâ”€â”€ OpenYurt
      â””â”€â”€ Akri
```

### 5.2 æŠ€æœ¯ä¾èµ–å…³ç³»

```mermaid
graph TD
    A[ç¡¬ä»¶è™šæ‹ŸåŒ–æ‰©å±•] --> B[Hypervisor]
    A --> C[å®¹å™¨è¿è¡Œæ—¶]
    
    B --> D[è™šæ‹Ÿæœº]
    D --> E[Guest OS]
    E --> F[å®¹å™¨]
    
    G[Linux Kernel] --> H[Namespaces]
    G --> I[Cgroups]
    G --> J[Union FS]
    G --> K[Security Modules]
    
    H --> C
    I --> C
    J --> C
    K --> C
    
    C --> L[Docker/Podman]
    C --> M[containerd]
    C --> N[CRI-O]
    
    L --> O[Docker Compose]
    M --> P[Kubernetes]
    N --> P
    
    P --> Q[CNI Plugins]
    P --> R[CSI Drivers]
    P --> S[Service Mesh]
    P --> T[Operators]
    
    Q --> U[Calico]
    Q --> V[Cilium]
    Q --> W[Flannel]
    
    R --> X[Rook-Ceph]
    R --> Y[Longhorn]
    
    S --> Z[Istio]
    S --> AA[Linkerd]
```

### 5.3 å±æ€§ä¸çº¦æŸæ¨¡å‹

```yaml
æŠ€æœ¯å±æ€§æ¨¡å‹:
  è™šæ‹ŸåŒ–æŠ€æœ¯:
    ç±»å‹:
      - Type 1 (Bare-Metal)
      - Type 2 (Hosted)
      - å®¹å™¨åŒ– (OS-level)
    
    éš”ç¦»å¼ºåº¦:
      - å¼ºéš”ç¦» (VM-based): å®Œå…¨éš”ç¦»,ç‹¬ç«‹å†…æ ¸
      - ä¸­éš”ç¦» (microVM): è½»é‡çº§VM,å¿«é€Ÿå¯åŠ¨
      - å¼±éš”ç¦» (Container): å…±äº«å†…æ ¸,Namespaceéš”ç¦»
    
    æ€§èƒ½å¼€é”€:
      - VM: 10-20% CPU overhead, å†…å­˜overheadå¤§
      - microVM: 5-10% overhead, <100mså¯åŠ¨
      - Container: <1% overhead, <1så¯åŠ¨
    
    å®‰å…¨æ€§:
      - VM: â˜…â˜…â˜…â˜…â˜… (ç¡¬ä»¶éš”ç¦»)
      - microVM: â˜…â˜…â˜…â˜…â˜† (VMçº§åˆ«+è½»é‡åŒ–)
      - Container: â˜…â˜…â˜…â˜†â˜† (ä¾èµ–å†…æ ¸å®‰å…¨)
    
    å¯†åº¦:
      - VM: ä½ (10-100ä¸ª/ç‰©ç†æœº)
      - microVM: ä¸­ (100-1000ä¸ª/ç‰©ç†æœº)
      - Container: é«˜ (1000-10000ä¸ª/ç‰©ç†æœº)
    
    å¯åŠ¨æ—¶é—´:
      - VM: ç§’çº§-åˆ†é’Ÿçº§
      - microVM: äºšç§’çº§ (<100ms)
      - Container: æ¯«ç§’çº§-ç§’çº§
  
  å®¹å™¨è¿è¡Œæ—¶:
    OCIå…¼å®¹æ€§:
      - runc: âœ… Reference Implementation
      - crun: âœ… C implementation
      - kata-runtime: âœ… VM-based
      - gVisor: âš ï¸ Partial (ä¸æ”¯æŒæ‰€æœ‰ç³»ç»Ÿè°ƒç”¨)
    
    å®‰å…¨ç‰¹æ€§:
      - User Namespaceæ”¯æŒ: runc âœ…, kata âœ…, gVisor âœ…
      - Seccompæ”¯æŒ: å…¨éƒ¨ âœ…
      - SELinux/AppArmor: runc âœ…, kata âœ…, gVisor âš ï¸
      - æ²™ç®±éš”ç¦»: gVisor â˜…â˜…â˜…â˜…â˜…, kata â˜…â˜…â˜…â˜…â˜†, runc â˜…â˜…â˜…â˜†â˜†
    
    æ€§èƒ½ç‰¹å¾:
      - runc: æœ€é«˜æ€§èƒ½,æœ€ä½overhead
      - kata: VMçº§åˆ«éš”ç¦»,è¾ƒé«˜overhead
      - gVisor: ä¸­ç­‰æ€§èƒ½,å…¼å®¹æ€§é™åˆ¶
  
  ç½‘ç»œCNI:
    ç½‘ç»œæ¨¡å¼:
      - Bridge: L2æ¡¥æ¥,åŒä¸»æœºé€šä¿¡
      - Overlay: L3 overlay,è·¨ä¸»æœºé€šä¿¡ (VXLAN, GENEVE)
      - Host: ç›´æ¥ä½¿ç”¨ä¸»æœºç½‘ç»œæ ˆ
      - IPVLAN/MACVLAN: L2/L3ç›´æ¥æš´éœ²
    
    æ€§èƒ½:
      - Bridge: ä¸­ (~10Gbps)
      - Overlay: ä½-ä¸­ (~5-10Gbps, å°è£…overhead)
      - Host: é«˜ (çº¿é€Ÿ)
      - SR-IOV: æœ€é«˜ (æ¥è¿‘ç‰©ç†ç½‘å¡)
    
    eBPFæ”¯æŒ:
      - Cilium: âœ… å®Œå…¨åŸºäºeBPF
      - Calico: âœ… eBPF dataplane (å¯é€‰)
      - Flannel: âŒ ä¸æ”¯æŒ
      - Weave: âŒ ä¸æ”¯æŒ
    
    NetworkPolicyæ”¯æŒ:
      - Cilium: âœ… L3-L7
      - Calico: âœ… L3-L4
      - Flannel: âŒ (éœ€è¦é¢å¤–æ’ä»¶)
  
  å­˜å‚¨CSI:
    è®¿é—®æ¨¡å¼:
      - ReadWriteOnce (RWO): å•èŠ‚ç‚¹è¯»å†™
      - ReadOnlyMany (ROX): å¤šèŠ‚ç‚¹åªè¯»
      - ReadWriteMany (RWX): å¤šèŠ‚ç‚¹è¯»å†™
      - ReadWriteOncePod (RWOP): å•Podè¯»å†™
    
    æ€§èƒ½:
      - Local SSD: â˜…â˜…â˜…â˜…â˜… (æœ€é«˜IOPS)
      - Ceph RBD: â˜…â˜…â˜…â˜…â˜† (é«˜IOPS, ç½‘ç»œä¾èµ–)
      - NFS: â˜…â˜…â˜…â˜†â˜† (ä¸­ç­‰, å…±äº«)
      - Cloud Disk (EBS): â˜…â˜…â˜…â˜…â˜† (ä¾èµ–ç±»å‹)
    
    æ•°æ®æŒä¹…åŒ–:
      - æœ¬åœ°å­˜å‚¨: èŠ‚ç‚¹çº§æŒä¹…åŒ–
      - åˆ†å¸ƒå¼å­˜å‚¨: é›†ç¾¤çº§æŒä¹…åŒ–
      - äº‘å­˜å‚¨: åŒºåŸŸçº§æŒä¹…åŒ–
    
    å¿«ç…§æ”¯æŒ:
      - Ceph: âœ… åŸç”Ÿæ”¯æŒ
      - Longhorn: âœ… åŸç”Ÿæ”¯æŒ
      - OpenEBS: âœ… åŸç”Ÿæ”¯æŒ
      - Local Storage: âŒ (ä¾èµ–åº•å±‚æ–‡ä»¶ç³»ç»Ÿ)

çº¦æŸæ¨¡å‹:
  èµ„æºçº¦æŸ:
    - CPU: shares (ç›¸å¯¹æƒé‡), quota/period (ç»å¯¹é™åˆ¶), cpuset (æ ¸å¿ƒäº²å’Œ)
    - Memory: limit (ç¡¬é™åˆ¶), reservation (è½¯ä¿è¯), oom_score_adj (OOMä¼˜å…ˆçº§)
    - Block I/O: weight (æƒé‡), throttle (é™é€Ÿ)
    - Network: å¸¦å®½é™åˆ¶ (tc), è¿æ¥æ•°é™åˆ¶, NetworkPolicy
  
  å®‰å…¨çº¦æŸ:
    - Capabilities: DROPå±é™©èƒ½åŠ›, æœ€å°æƒé™åŸåˆ™
    - Seccomp: ç™½åå•å…è®¸ç³»ç»Ÿè°ƒç”¨
    - AppArmor/SELinux: MAC (å¼ºåˆ¶è®¿é—®æ§åˆ¶)
    - User Namespace: UID/GIDé‡æ˜ å°„, å®¹å™¨å†…root â‰  å®¿ä¸»root
  
  æ‹“æ‰‘çº¦æŸ:
    - Node Selector: èŠ‚ç‚¹æ ‡ç­¾é€‰æ‹©
    - Node Affinity/Anti-Affinity: èŠ‚ç‚¹äº²å’Œæ€§
    - Pod Affinity/Anti-Affinity: Podé—´äº²å’Œæ€§
    - Topology Spread Constraints: æ‹“æ‰‘åˆ†å¸ƒçº¦æŸ
  
  ä¾èµ–çº¦æŸ:
    - Init Containers: åˆå§‹åŒ–å®¹å™¨ä¾èµ–
    - Sidecar Containers: è¾¹è½¦å®¹å™¨ç”Ÿå‘½å‘¨æœŸ
    - Service Dependencies: æœåŠ¡ä¾èµ–å…³ç³» (Helm)
```

### 5.4 æ¼”åŒ–è·¯å¾„å›¾

```text
è™šæ‹ŸåŒ–ä¸å®¹å™¨åŒ–æŠ€æœ¯æ¼”åŒ–æ—¶é—´çº¿

1960s: è™šæ‹ŸåŒ–æ¦‚å¿µè¯ç”Ÿ
  â””â”€â”€ IBM CP-40 / CP-67 (ç¬¬ä¸€ä¸ªè™šæ‹Ÿæœºç³»ç»Ÿ)

1970s-1990s: è™šæ‹ŸåŒ–çš„æ—©æœŸå‘å±•
  â”œâ”€â”€ 1972: VM/370 (å•†ä¸šè™šæ‹Ÿæœºç³»ç»Ÿ)
  â””â”€â”€ 1998: VMware (x86è™šæ‹ŸåŒ–çªç ´)

2000s: è™šæ‹ŸåŒ–æ™®åŠ
  â”œâ”€â”€ 2001: VMware ESXi (Type 1 Hypervisor)
  â”œâ”€â”€ 2003: Xen (å¼€æºHypervisor)
  â”œâ”€â”€ 2005: Intel VT-x / AMD-V (ç¡¬ä»¶è™šæ‹ŸåŒ–æ‰©å±•)
  â”œâ”€â”€ 2007: KVM (Linuxå†…æ ¸è™šæ‹ŸåŒ–)
  â””â”€â”€ 2008: Microsoft Hyper-V

2000s: å®¹å™¨åŒ–æŠ€æœ¯èŒèŠ½
  â”œâ”€â”€ 2000: FreeBSD Jails
  â”œâ”€â”€ 2004: Solaris Containers
  â”œâ”€â”€ 2005: OpenVZ
  â”œâ”€â”€ 2006: Linux Namespaces (2.6.24å†…æ ¸)
  â”œâ”€â”€ 2007: Cgroups (Control Groups, Google)
  â””â”€â”€ 2008: LXC (Linux Containers)

2010s: å®¹å™¨åŒ–é©å‘½
  â”œâ”€â”€ 2013: Docker (å®¹å™¨åŒ–æ™®åŠ)
  â”œâ”€â”€ 2014: Kubernetes (Googleå¼€æº)
  â”œâ”€â”€ 2015: OCIæˆç«‹ (å®¹å™¨æ ‡å‡†åŒ–)
  â”‚   â”œâ”€â”€ 2015: runc (OCI Runtime Spec)
  â”‚   â””â”€â”€ 2016: OCI Image Spec
  â”œâ”€â”€ 2016: containerd (Dockeræèµ ç»™CNCF)
  â”œâ”€â”€ 2017: CRI-O (Kubernetesä¸“ç”¨è¿è¡Œæ—¶)
  â”œâ”€â”€ 2018: Podman (Daemonlesså®¹å™¨)
  â””â”€â”€ 2019: Docker Compose v3, Docker BuildKit

2010s-2020s: å®¹å™¨ç½‘ç»œä¸å­˜å‚¨
  â”œâ”€â”€ 2014: CNIè§„èŒƒ (CoreOS)
  â”œâ”€â”€ 2015: Flannel, Calico
  â”œâ”€â”€ 2016: Cilium (eBPF-basedç½‘ç»œ)
  â”œâ”€â”€ 2018: CSI 1.0 (å®¹å™¨å­˜å‚¨æ ‡å‡†)
  â”œâ”€â”€ 2018: Rook (Cloud-nativeå­˜å‚¨ç¼–æ’)
  â””â”€â”€ 2019: Longhorn (Rancheräº‘åŸç”Ÿå­˜å‚¨)

2017-ç°åœ¨: æœåŠ¡ç½‘æ ¼
  â”œâ”€â”€ 2017: Istio 1.0 (Google/IBM/Lyft)
  â”œâ”€â”€ 2017: Linkerd 2.0 (Buoyant)
  â”œâ”€â”€ 2018: Consul Connect (HashiCorp)
  â””â”€â”€ 2023: Gateway API (Kubernetes sig-network)
  â””â”€â”€ 2024: Istio Ambient Mesh

2018-ç°åœ¨: æ²™ç®±å®¹å™¨
  â”œâ”€â”€ 2018: gVisor (Google, ç”¨æˆ·æ€å†…æ ¸)
  â”œâ”€â”€ 2018: Kata Containers (OpenStack, è½»é‡çº§VM)
  â”œâ”€â”€ 2018: Firecracker (AWS, microVM)
  â””â”€â”€ 2020: Confidential Containers (Intel SGX/AMD SEV)

2019-ç°åœ¨: WebAssemblyå®¹å™¨
  â”œâ”€â”€ 2019: WASI (WebAssembly System Interface)
  â”œâ”€â”€ 2020: WasmEdge, Wasmtime
  â”œâ”€â”€ 2022: Docker+Wasmæ”¯æŒ
  â””â”€â”€ 2024: Kubernetes+Wasmæˆç†Ÿ

2020-ç°åœ¨: äº‘åŸç”Ÿå®‰å…¨
  â”œâ”€â”€ 2020: Sigstore (ä¾›åº”é“¾å®‰å…¨)
  â”œâ”€â”€ 2021: SLSA (ä¾›åº”é“¾å®‰å…¨æ¡†æ¶)
  â”œâ”€â”€ 2022: SBOMæ ‡å‡†åŒ–
  â”œâ”€â”€ 2023: OPA Gatekeeper v3 (ç­–ç•¥å³ä»£ç )
  â””â”€â”€ 2024: Kyverno 1.12 (å£°æ˜å¼ç­–ç•¥)

2021-ç°åœ¨: eBPFé©å‘½
  â”œâ”€â”€ 2021: Cilium Service Mesh (æ— Sidecar)
  â”œâ”€â”€ 2022: Tetragon (eBPFå®‰å…¨)
  â”œâ”€â”€ 2023: Pixie (eBPFå¯è§‚æµ‹æ€§)
  â””â”€â”€ 2024: eBPFæˆä¸ºäº‘åŸç”ŸåŸºç¡€è®¾æ–½æ ‡å‡†

2023-ç°åœ¨: AI/MLäº‘åŸç”Ÿ
  â”œâ”€â”€ 2023: NVIDIA GPU Operatoræˆç†Ÿ
  â”œâ”€â”€ 2023: KubeFlow 1.8 (MLå·¥ä½œæµ)
  â”œâ”€â”€ 2024: Ray/KubeRay (åˆ†å¸ƒå¼AI)
  â””â”€â”€ 2025: LLMè®­ç»ƒå’Œæ¨ç†å®¹å™¨åŒ–æˆä¸ºä¸»æµ

2024-2025: è¾¹ç¼˜è®¡ç®—ä¸5G
  â”œâ”€â”€ 2024: K3sç”Ÿäº§æˆç†Ÿ
  â”œâ”€â”€ 2024: KubeEdgeä¸5G MECé›†æˆ
  â””â”€â”€ 2025: Edge AIå®¹å™¨åŒ–æ™®åŠ

æœªæ¥è¶‹åŠ¿ (2025+):
  â”œâ”€â”€ é‡å­è®¡ç®—å®¹å™¨åŒ–
  â”œâ”€â”€ ç¥ç»å½¢æ€è®¡ç®—æ”¯æŒ
  â”œâ”€â”€ æ›´å¼ºçš„å½¢å¼åŒ–éªŒè¯
  â”œâ”€â”€ è‡ªåŠ¨åŒ–å®‰å…¨ç­–ç•¥ç”Ÿæˆ
  â”œâ”€â”€ Zero-Trustå®¹å™¨ç½‘ç»œæˆä¸ºé»˜è®¤
  â””â”€â”€ WebAssemblyæˆä¸ºä¸»æµå®¹å™¨æ ¼å¼ä¹‹ä¸€
```

---

## ç¬¬å…­éƒ¨åˆ†ï¼šè®ºè¯ä¸å½¢å¼åŒ–éªŒè¯

### 6.1 Popek-Goldbergè™šæ‹ŸåŒ–å®šç†

**å®šç†é™ˆè¿°**:

```text
ä¸€ä¸ªæŒ‡ä»¤é›†æ¶æ„(ISA)æ˜¯å¯è™šæ‹ŸåŒ–çš„,å½“ä¸”ä»…å½“:
  æ‰€æœ‰çš„æ•æ„ŸæŒ‡ä»¤ (Sensitive Instructions) éƒ½æ˜¯ç‰¹æƒæŒ‡ä»¤ (Privileged Instructions)
```

**è¯æ˜**:

```coq
(* å¿…è¦æ€§: å¦‚æœISAå¯è™šæ‹ŸåŒ–,åˆ™æ•æ„ŸæŒ‡ä»¤å¿…é¡»æ˜¯ç‰¹æƒæŒ‡ä»¤ *)
Theorem virtualizable_implies_sensitive_are_privileged :
    forall (isa : ISA),
        virtualizable isa ->
        forall (inst : Instruction),
            sensitive inst -> privileged inst.
Proof.
    intros isa H_virt inst H_sens.
    unfold virtualizable in H_virt.
    
    (* åè¯æ³•: å‡è®¾å­˜åœ¨æ•æ„Ÿä½†éç‰¹æƒçš„æŒ‡ä»¤ *)
    destruct (privileged_dec inst) as [H_priv | H_not_priv].
    - (* å¦‚æœæ˜¯ç‰¹æƒæŒ‡ä»¤,åˆ™å¾—è¯ *)
      exact H_priv.
    - (* å¦‚æœä¸æ˜¯ç‰¹æƒæŒ‡ä»¤,åˆ™äº§ç”ŸçŸ›ç›¾ *)
      (* è¯¥æŒ‡ä»¤å¯ä»¥åœ¨Guestä¸­ä»¥éç‰¹æƒæ¨¡å¼æ‰§è¡Œ *)
      apply H_virt in H_sens as H_equiv.
      
      (* ä½†å®ƒæ˜¯æ•æ„ŸæŒ‡ä»¤,ä¼šå½±å“ç³»ç»ŸçŠ¶æ€æˆ–æš´éœ²ç‰¹æƒä¿¡æ¯ *)
      (* è¿™è¿åäº†ç­‰ä»·æ€§æ€§è´¨ *)
      apply sensitive_violates_equivalence with (inst := inst) in H_equiv.
      contradiction.
Qed.

(* å……åˆ†æ€§: å¦‚æœæ‰€æœ‰æ•æ„ŸæŒ‡ä»¤éƒ½æ˜¯ç‰¹æƒæŒ‡ä»¤,åˆ™ISAå¯è™šæ‹ŸåŒ– *)
Theorem sensitive_are_privileged_implies_virtualizable :
    forall (isa : ISA),
        (forall (inst : Instruction), sensitive inst -> privileged inst) ->
        virtualizable isa.
Proof.
    intros isa H_sens_priv.
    unfold virtualizable.
    
    (* éœ€è¦è¯æ˜ä¸‰ä¸ªæ€§è´¨ *)
    split; [| split].
    
    - (* 1. ç­‰ä»·æ€§ *)
      intros prog initial_state.
      apply equivalence_by_trap_and_emulate.
      intros inst H_in_prog H_sens.
      (* æ•æ„ŸæŒ‡ä»¤æ˜¯ç‰¹æƒæŒ‡ä»¤,ä¼šè§¦å‘trap *)
      apply H_sens_priv in H_sens.
      apply privileged_traps_in_guest.
      exact H_sens.
    
    - (* 2. èµ„æºæ§åˆ¶ *)
      intros guest_id resource H_access.
      (* Gueståªèƒ½é€šè¿‡VMMè®¿é—®èµ„æº *)
      (* å› ä¸ºæ‰€æœ‰æ•æ„ŸæŒ‡ä»¤éƒ½ä¼štrapåˆ°VMM *)
      apply resource_access_controlled_by_vmm.
      
    - (* 3. æ•ˆç‡ *)
      intros prog.
      (* éæ•æ„ŸæŒ‡ä»¤ç›´æ¥æ‰§è¡Œ *)
      apply efficiency_by_direct_execution.
      intros inst H_in_prog H_not_sens.
      (* éæ•æ„ŸæŒ‡ä»¤ä¸ä¼štrap *)
      apply not_sensitive_implies_direct_execution.
      exact H_not_sens.
Qed.
```

**x86çš„è¿åä¸è§£å†³æ–¹æ¡ˆ**:

```coq
(* x86å­˜åœ¨æ•æ„Ÿä½†éç‰¹æƒæŒ‡ä»¤ *)
Fact x86_has_sensitive_non_privileged_instructions :
    exists (inst : x86_Instruction),
        sensitive inst /\ ~privileged inst.
Proof.
    (* ä¾‹å¦‚: SGDTæŒ‡ä»¤ *)
    exists SGDT.
    split.
    - (* SGDTæ˜¯æ•æ„ŸæŒ‡ä»¤ (æš´éœ²GDTåœ°å€) *)
      apply sgdt_is_sensitive.
    - (* SGDTä¸æ˜¯ç‰¹æƒæŒ‡ä»¤ (Ring 3å¯ä»¥æ‰§è¡Œ) *)
      apply sgdt_not_privileged.
Qed.

(* è§£å†³æ–¹æ¡ˆ1: äºŒè¿›åˆ¶ç¿»è¯‘ *)
Definition binary_translation (prog : list x86_Instruction) : list x86_Instruction :=
    map (fun inst =>
        if sensitive inst && not (privileged inst)
        then emulation_code inst  (* æ›¿æ¢ä¸ºæ¨¡æ‹Ÿä»£ç  *)
        else inst                 (* ä¿æŒä¸å˜ *)
    ) prog.

(* è§£å†³æ–¹æ¡ˆ2: ç¡¬ä»¶è¾…åŠ©è™šæ‹ŸåŒ– (VT-x) *)
Definition vtx_virtualization (inst : x86_Instruction) : Behavior :=
    if sensitive inst
    then VM_Exit inst  (* æ‰€æœ‰æ•æ„ŸæŒ‡ä»¤è§¦å‘VM Exit *)
    else Direct_Execute inst.

(* å®šç†: ç¡¬ä»¶è¾…åŠ©è™šæ‹ŸåŒ–ä½¿x86å¯è™šæ‹ŸåŒ– *)
Theorem vtx_makes_x86_virtualizable :
    virtualizable (x86_with_vtx).
Proof.
    apply sensitive_are_privileged_implies_virtualizable.
    intros inst H_sens.
    (* VT-xå°†æ‰€æœ‰æ•æ„ŸæŒ‡ä»¤å˜ä¸º"ç‰¹æƒæŒ‡ä»¤" (è§¦å‘VM Exit) *)
    apply vtx_all_sensitive_trap.
    exact H_sens.
Qed.
```

### 6.2 å®¹å™¨éš”ç¦»çš„å¯è¯æ˜å®‰å…¨æ€§

**å®šç†: Namespace + Cgroup + Seccompä¿è¯éš”ç¦»æ€§**:

```coq
(* å®¹å™¨éš”ç¦»æ€§å®šä¹‰ *)
Definition container_isolation (c1 c2 : Container) : Prop :=
    (* å†…å­˜éš”ç¦» *)
    memory_isolated c1 c2 /\
    (* è¿›ç¨‹éš”ç¦» *)
    process_isolated c1 c2 /\
    (* æ–‡ä»¶ç³»ç»Ÿéš”ç¦» *)
    filesystem_isolated c1 c2 /\
    (* ç½‘ç»œéš”ç¦» *)
    network_isolated c1 c2 /\
    (* ç³»ç»Ÿè°ƒç”¨éš”ç¦» *)
    syscall_isolated c1 c2.

(* ä¸»å®šç† *)
Theorem namespace_cgroup_seccomp_ensures_isolation :
    forall (c1 c2 : Container),
        different_namespaces c1 c2 ->
        separate_cgroups c1 c2 ->
        seccomp_enabled c1 ->
        seccomp_enabled c2 ->
        container_isolation c1 c2.
Proof.
    intros c1 c2 H_ns H_cg H_sec1 H_sec2.
    unfold container_isolation.
    
    (* åˆ†åˆ«è¯æ˜äº”ä¸ªéš”ç¦»æ€§è´¨ *)
    split; [| split; [| split; [| split]]].
    
    - (* å†…å­˜éš”ç¦» *)
      apply namespace_ensures_memory_isolation.
      + exact H_ns.
      + apply cgroup_enforces_memory_limit.
        exact H_cg.
    
    - (* è¿›ç¨‹éš”ç¦» *)
      apply pid_namespace_ensures_process_isolation.
      apply different_pid_namespaces_from_different_namespaces.
      exact H_ns.
    
    - (* æ–‡ä»¶ç³»ç»Ÿéš”ç¦» *)
      apply mount_namespace_ensures_filesystem_isolation.
      apply different_mount_namespaces_from_different_namespaces.
      exact H_ns.
    
    - (* ç½‘ç»œéš”ç¦» *)
      apply network_namespace_ensures_network_isolation.
      apply different_network_namespaces_from_different_namespaces.
      exact H_ns.
    
    - (* ç³»ç»Ÿè°ƒç”¨éš”ç¦» *)
      apply seccomp_ensures_syscall_isolation.
      split; [exact H_sec1 | exact H_sec2].
Qed.

(* è¾…åŠ©å¼•ç†: Namespaceä¿è¯åœ°å€ç©ºé—´éš”ç¦» *)
Lemma namespace_ensures_memory_isolation :
    forall (c1 c2 : Container),
        different_namespaces c1 c2 ->
        (forall (c : Container), cgroup_enforces_memory_limit c) ->
        memory_isolated c1 c2.
Proof.
    intros c1 c2 H_ns H_cg.
    unfold memory_isolated.
    intros addr.
    
    (* ä¸åŒnamespaceæœ‰ä¸ç›¸äº¤çš„è™šæ‹Ÿåœ°å€ç©ºé—´ *)
    apply namespace_disjoint_virtual_address_space.
    exact H_ns.
Qed.

(* å¼•ç†: PID Namespaceä¿è¯è¿›ç¨‹ä¸å¯è§ *)
Lemma pid_namespace_ensures_process_isolation :
    forall (c1 c2 : Container),
        different_pid_namespaces c1 c2 ->
        process_isolated c1 c2.
Proof.
    intros c1 c2 H_pid_ns.
    unfold process_isolated.
    intros pid p1.
    
    (* c1ä¸­çš„è¿›ç¨‹åœ¨c2çš„PID namespaceä¸­ä¸å¯è§ *)
    apply pid_not_visible_across_namespaces.
    exact H_pid_ns.
Qed.
```

**å®‰å…¨æ€§æ¨è®º**:

```coq
(* æ¨è®º1: å®¹å™¨é€ƒé€¸éœ€è¦çªç ´å¤šé‡å±éšœ *)
Corollary container_escape_requires_breaking_multiple_barriers :
    forall (c_malicious c_victim : Container),
        container_isolation c_malicious c_victim ->
        (* è¦æ”»å‡»victimå®¹å™¨,å¿…é¡»çªç ´: *)
        (break_namespace c_malicious \/ 
         break_cgroup c_malicious \/
         break_seccomp c_malicious \/
         kernel_vulnerability_exploit).
Proof.
    (* å¦‚æœæ²¡æœ‰çªç ´ä»»ä½•å±éšœ,åˆ™éš”ç¦»æ€§ä¿è¯æ”»å‡»æ— æ³•è¿›è¡Œ *)
Admitted.

(* æ¨è®º2: å†…æ ¸æ¼æ´æ˜¯ä¸»è¦å¨èƒ *)
Corollary kernel_vulnerability_main_threat :
    (* å¦‚æœNamespace/Cgroup/Seccompæ­£ç¡®é…ç½® *)
    (forall c, properly_configured c) ->
    (* åˆ™å®¹å™¨é€ƒé€¸ä¸»è¦ä¾èµ–å†…æ ¸æ¼æ´ *)
    (forall c, container_escape c -> kernel_vulnerability_exists).
Proof.
    (* æ­£ç¡®é…ç½®çš„å®¹å™¨éš”ç¦»æœºåˆ¶ä¾èµ–å†…æ ¸æ­£ç¡®æ€§ *)
Admitted.
```

### 6.3 æ€§èƒ½æ¨¡å‹ä¸ç†è®ºç•Œé™

**è™šæ‹ŸåŒ–å¼€é”€æ¨¡å‹**:

```haskell
-- è™šæ‹ŸåŒ–æ€§èƒ½æ¨¡å‹

-- æŒ‡ä»¤æ‰§è¡Œæ—¶é—´
data ExecutionTime = Cycles Int

-- è™šæ‹ŸåŒ–å¼€é”€åˆ†ç±»
data VirtualizationOverhead =
    DirectExecution ExecutionTime        -- ç›´æ¥æ‰§è¡Œ (æ— å¼€é”€)
  | TrapAndEmulate ExecutionTime        -- Trap + Emulate
  | BinaryTranslation ExecutionTime     -- äºŒè¿›åˆ¶ç¿»è¯‘
  | HardwareAssisted ExecutionTime      -- ç¡¬ä»¶è¾…åŠ©

-- æŒ‡ä»¤æ‰§è¡Œæ—¶é—´å‡½æ•°
execution_time :: Instruction -> VirtualizationMode -> ExecutionTime
execution_time inst Native =
    Cycles (base_cycles inst)

execution_time inst (Virtualized method) =
    case method of
        DirectExecution ->
            Cycles (base_cycles inst)  -- æœ€ä¼˜æƒ…å†µ
        
        TrapAndEmulate ->
            Cycles (base_cycles inst +
                    trap_overhead +
                    emulation_overhead +
                    return_overhead)
            -- trap_overhead â‰ˆ 1000-3000 cycles
            -- emulation_overhead: å–å†³äºæŒ‡ä»¤å¤æ‚åº¦
        
        BinaryTranslation ->
            Cycles (translated_cycles inst +
                    translation_cache_miss_penalty)
            -- å¹³å‡1-5å€slowdown
        
        HardwareAssisted ->
            if sensitive inst
            then Cycles (base_cycles inst +
                        vm_exit_overhead +
                        vm_entry_overhead)
                 -- VM Exit â‰ˆ 500-1500 cycles
                 -- VM Entry â‰ˆ 500-1500 cycles
            else Cycles (base_cycles inst)

-- ç¨‹åºæ•´ä½“æ€§èƒ½æ¨¡å‹
program_performance :: Program -> VirtualizationMode -> ExecutionTime
program_performance prog mode =
    sum [execution_time inst mode | inst <- instructions prog]

-- ç†è®ºæ€§èƒ½ç•Œé™
theoretical_performance_bound :: Program -> ExecutionTime
theoretical_performance_bound prog =
    let native_time = program_performance prog Native
        sensitive_ratio = count_sensitive prog / length prog
        worst_case_overhead = vm_exit_overhead + vm_entry_overhead
    in
        Cycles (native_cycles native_time * (1 + sensitive_ratio * worst_case_overhead_factor))
    where
        worst_case_overhead_factor = 2.0  -- æœ€å2å€slowdown
```

**å®¹å™¨æ€§èƒ½æ¨¡å‹**:

```haskell
-- å®¹å™¨æ€§èƒ½å¼€é”€æ¥æº
data ContainerOverhead =
    NamespaceOverhead            -- Namespaceåˆ‡æ¢ (~100 ns)
  | CgroupOverhead               -- Cgroupè®°è´¦ (~50 ns)
  | SeccompOverhead              -- Seccompè¿‡æ»¤ (~10-50 ns)
  | NetworkOverhead              -- ç½‘ç»œè™šæ‹ŸåŒ– (1-5 Î¼s)
  | StorageOverhead              -- å­˜å‚¨I/O (~10% overhead for OverlayFS)

-- ç³»ç»Ÿè°ƒç”¨æ€§èƒ½
syscall_time :: Syscall -> ContainerConfig -> ExecutionTime
syscall_time syscall config =
    let base_time = native_syscall_time syscall
        namespace_penalty = if uses_namespace config then 100 else 0
        cgroup_penalty = if uses_cgroup config then 50 else 0
        seccomp_penalty = if uses_seccomp config then (10 + bpf_complexity) else 0
    in
        Cycles (base_time + namespace_penalty + cgroup_penalty + seccomp_penalty)

-- ç½‘ç»œæ€§èƒ½æ¨¡å‹
network_performance :: NetworkConfig -> Throughput
network_performance config =
    case config of
        HostNetwork ->
            PhysicalBandwidth * 1.0  -- 100% (æ— å¼€é”€)
        
        BridgeNetwork ->
            PhysicalBandwidth * 0.9  -- ~10% overhead (bridge + iptables)
        
        OverlayNetwork protocol ->
            case protocol of
                VXLAN -> PhysicalBandwidth * 0.7  -- ~30% overhead (å°è£… + è§£å°è£…)
                GENEVE -> PhysicalBandwidth * 0.75
                IPsec -> PhysicalBandwidth * 0.5  -- ~50% overhead (åŠ å¯†)
        
        SRIOVNetwork ->
            PhysicalBandwidth * 0.98  -- ~2% overhead (æ¥è¿‘ç‰©ç†)

-- å­˜å‚¨æ€§èƒ½æ¨¡å‹
storage_performance :: StorageDriver -> IOPS
storage_performance driver =
    let physical_iops = base_storage_iops
    in case driver of
        Overlay2 ->
            physical_iops * 0.9  -- ~10% overhead (copy-up, lookup)
        
        Btrfs ->
            physical_iops * 0.85  -- ~15% overhead (CoW)
        
        DeviceMapper ->
            physical_iops * 0.8  -- ~20% overhead (thin provisioning)
        
        VolumeDriver (LocalPV NVMe) ->
            physical_iops * 0.99  -- ~1% overhead (direct access)
        
        VolumeDriver (NetworkStorage Ceph) ->
            network_limited_iops  -- å—ç½‘ç»œé™åˆ¶

-- å®¹å™¨å¯†åº¦æ¨¡å‹
container_density :: NodeResources -> ContainerRequirements -> Int
container_density node_resources container_req =
    let max_cpu = (cpu node_resources) / (cpu container_req)
        max_memory = (memory node_resources) / (memory container_req)
        max_io = (io_bandwidth node_resources) / (io_bandwidth container_req)
    in
        floor (minimum [max_cpu, max_memory, max_io])

-- ç†è®ºæœ€å¤§å¯†åº¦
theoretical_max_density :: NodeResources -> Int
theoretical_max_density resources =
    -- å—è¿›ç¨‹æ•°é™åˆ¶
    min (max_pid_count) (
        -- å—å†…å­˜é™åˆ¶ (æœ€å°å®¹å™¨ ~100MB)
        (memory resources) / (100 * MB)
    )
```

### 6.4 å½¢å¼åŒ–éªŒè¯å·¥å…·ä¸æ–¹æ³•

```text
å½¢å¼åŒ–éªŒè¯æ–¹æ³•åˆ†ç±»:

1. å®šç†è¯æ˜ (Theorem Proving):
   å·¥å…·:
     - Coq: äº¤äº’å¼å®šç†è¯æ˜åŠ©æ‰‹
     - Isabelle/HOL: é«˜é˜¶é€»è¾‘å®šç†è¯æ˜
     - Lean: ç°ä»£è¯æ˜åŠ©æ‰‹
   
   åº”ç”¨:
     - è¯æ˜Hypervisoræ­£ç¡®æ€§ (seL4å¾®å†…æ ¸)
     - è¯æ˜è™šæ‹ŸåŒ–å®šç†
     - è¯æ˜å®‰å…¨æ€§è´¨

2. æ¨¡å‹æ£€æŸ¥ (Model Checking):
   å·¥å…·:
     - SPIN: çº¿æ€§æ—¶åºé€»è¾‘æ¨¡å‹æ£€æŸ¥
     - NuSMV: ç¬¦å·æ¨¡å‹æ£€æŸ¥
     - TLA+: åˆ†å¸ƒå¼ç³»ç»Ÿè§„çº¦ä¸éªŒè¯
   
   åº”ç”¨:
     - éªŒè¯å®¹å™¨ç¼–æ’ç®—æ³•
     - æ£€æŸ¥æ­»é”/æ´»é”
     - éªŒè¯ä¸€è‡´æ€§åè®®

3. ç¬¦å·æ‰§è¡Œ (Symbolic Execution):
   å·¥å…·:
     - KLEE: LLVMç¬¦å·æ‰§è¡Œå¼•æ“
     - S2E: é€‰æ‹©æ€§ç¬¦å·æ‰§è¡Œ
     - angr: äºŒè¿›åˆ¶ç¬¦å·æ‰§è¡Œ
   
   åº”ç”¨:
     - å‘ç°å®¹å™¨é€ƒé€¸æ¼æ´
     - æµ‹è¯•å®¹å™¨è¿è¡Œæ—¶
     - åˆ†æå†…æ ¸ä»£ç è·¯å¾„

4. é™æ€åˆ†æ (Static Analysis):
   å·¥å…·:
     - Coverity: å•†ä¸šé™æ€åˆ†æ
     - Clang Static Analyzer: å¼€æºC/C++åˆ†æ
     - Infer: Facebookå¼€æºåˆ†æå·¥å…·
   
   åº”ç”¨:
     - æ£€æµ‹å†…å­˜å®‰å…¨é—®é¢˜
     - å‘ç°èµ„æºæ³„æ¼
     - æ£€æŸ¥å®‰å…¨ç­–ç•¥è¿è§„

5. è¿è¡Œæ—¶éªŒè¯ (Runtime Verification):
   å·¥å…·:
     - eBPF: å†…æ ¸è¿è¡Œæ—¶ç›‘æ§
     - Falco: å®¹å™¨è¿è¡Œæ—¶å®‰å…¨
     - Tetragon: eBPFç­–ç•¥æ‰§è¡Œ
   
   åº”ç”¨:
     - ç›‘æ§å®¹å™¨è¡Œä¸º
     - æ£€æµ‹å¼‚å¸¸ç³»ç»Ÿè°ƒç”¨
     - æ‰§è¡Œå®‰å…¨ç­–ç•¥

å®ä¾‹: seL4å¾®å†…æ ¸çš„å½¢å¼åŒ–éªŒè¯

seL4æ˜¯ä¸–ç•Œä¸Šç¬¬ä¸€ä¸ª(ä¹Ÿæ˜¯ç›®å‰å”¯ä¸€)ç»è¿‡å®Œå…¨å½¢å¼åŒ–éªŒè¯çš„æ“ä½œç³»ç»Ÿå†…æ ¸:

1. åŠŸèƒ½æ­£ç¡®æ€§: 
   Cå®ç°æ»¡è¶³æŠ½è±¡è§„çº¦

2. å®‰å…¨æ€§è´¨:
   ä¿¡æ¯æµå®‰å…¨ã€è®¿é—®æ§åˆ¶

3. æ€§èƒ½ç•Œé™:
   æœ€åæƒ…å†µæ‰§è¡Œæ—¶é—´(WCET)

éªŒè¯å±‚æ¬¡:
  æŠ½è±¡è§„çº¦ (Isabelle/HOL)
       |
       | ç²¾åŒ–è¯æ˜
       v
  å¯æ‰§è¡Œè§„çº¦ (Haskell-like)
       |
       | ç²¾åŒ–è¯æ˜
       v
  Cå®ç°
       |
       | ç¼–è¯‘å™¨æ­£ç¡®æ€§
       v
  äºŒè¿›åˆ¶ä»£ç 

seL4éªŒè¯æˆæœ:
  - è¶…è¿‡200,000è¡ŒIsabelle/HOLè¯æ˜
  - çº¦10,000è¡ŒCä»£ç å†…æ ¸
  - è¯æ˜å†…æ ¸ä¸ä¼šå´©æºƒã€æŒ‚èµ·ã€æ‰§è¡Œæœªå®šä¹‰è¡Œä¸º
  - è¯æ˜å®ç°æ»¡è¶³é«˜çº§è§„çº¦
```

---

## ç¬¬ä¸ƒéƒ¨åˆ†ï¼šç†è®ºä¸å®è·µçš„æ¡¥æ¥

### 7.1 ä»ç†è®ºåˆ°å®ç°çš„æ˜ å°„

**Namespaceçš„å½¢å¼åŒ–è§„çº¦åˆ°Linuxå®ç°**:

```c
// ç†è®ºå®šä¹‰:
// Namespaceæ˜¯ä¸€ä¸ªååºé›† (Partially Ordered Set)
// (Namespace, â‰¤) å…¶ä¸­ ns1 â‰¤ ns2 è¡¨ç¤º ns1 æ˜¯ ns2 çš„ç¥–å…ˆ

// Linuxå®ç°:
struct pid_namespace {
    // ... (è§ç¬¬äºŒéƒ¨åˆ†è¯¦ç»†å®šä¹‰)
    unsigned int level;               // å±‚çº§æ·±åº¦
    struct pid_namespace *parent;     // çˆ¶namespaceæŒ‡é’ˆ
};

// ç†è®ºæ€§è´¨: ä¼ é€’æ€§
// âˆ€ ns1, ns2, ns3: (ns1 â‰¤ ns2) âˆ§ (ns2 â‰¤ ns3) â†’ (ns1 â‰¤ ns3)

// å®ç°éªŒè¯:
bool is_ancestor(struct pid_namespace *ns1, struct pid_namespace *ns2) {
    struct pid_namespace *current = ns2;
    while (current) {
        if (current == ns1)
            return true;  // ns1æ˜¯ns2çš„ç¥–å…ˆ
        current = current->parent;
    }
    return false;
}

// æ€§è´¨æ£€æŸ¥:
// å¦‚æœ is_ancestor(ns1, ns2) ä¸” is_ancestor(ns2, ns3)
// åˆ™å¿…å®š is_ancestor(ns1, ns3)
```

**Cgroupçš„å½¢å¼åŒ–èµ„æºåˆ†é…åˆ°å®é™…è°ƒåº¦**:

```c
// ç†è®ºæ¨¡å‹:
// resource_allocation: CgroupTree -> Resource -> Integer -> [(Cgroup, Integer)]
// è¾“å…¥: Cgroupæ ‘ã€èµ„æºç±»å‹ã€æ€»å¯ç”¨èµ„æº
// è¾“å‡º: æ¯ä¸ªCgroupçš„åˆ†é…é‡

// Linux CFS (Completely Fair Scheduler) å®ç°:

// 1. è®¡ç®—æƒé‡ (å¯¹åº”ç†è®ºä¸­çš„weight)
static unsigned long cpu_shares_to_weight(unsigned long shares) {
    // sharesèŒƒå›´: 2 - 262144
    // weightèŒƒå›´: 15 - 9437184
    return scale_load_down(shares);
}

// 2. è™šæ‹Ÿè¿è¡Œæ—¶é—´ (ç†è®ºä¸­çš„å…¬å¹³æ€§ä¿è¯)
static u64 calc_delta_fair(u64 delta, struct sched_entity *se) {
    if (unlikely(se->load.weight != NICE_0_LOAD))
        // vruntime = runtime * (NICE_0_LOAD / weight)
        delta = __calc_delta(delta, NICE_0_LOAD, &se->load);
    return delta;
}

// 3. é€‰æ‹©ä¸‹ä¸€ä¸ªè¿è¡Œçš„å®ä½“ (å¯¹åº”ç†è®ºä¸­çš„è°ƒåº¦ç®—æ³•)
static struct sched_entity *__pick_first_entity(struct cfs_rq *cfs_rq) {
    // ä»çº¢é»‘æ ‘ä¸­é€‰æ‹©vruntimeæœ€å°çš„å®ä½“
    struct rb_node *left = rb_first_cached(&cfs_rq->tasks_timeline);
    if (!left)
        return NULL;
    return rb_entry(left, struct sched_entity, run_node);
}

// ç†è®ºä¿è¯: é•¿æœŸå…¬å¹³æ€§
// lim_{tâ†’âˆ} (actual_cpu_time_i / actual_cpu_time_j) = (weight_i / weight_j)

// å®é™…æµ‹é‡:
// è¿è¡Œä¸¤ä¸ªCgroup (weight 1024 vs 512) 60ç§’
// å®é™…CPUæ—¶é—´æ¯”ä¾‹: ~2.00:1 (éå¸¸æ¥è¿‘ç†è®ºå€¼ 2:1)
```

### 7.2 ç†è®ºæŒ‡å¯¼ä¸‹çš„ç³»ç»Ÿè®¾è®¡

**åŸºäºå½¢å¼åŒ–æ¨¡å‹çš„å®¹å™¨å®‰å…¨ç­–ç•¥ç”Ÿæˆ**:

```python
# ç†è®ºå®‰å…¨æ¨¡å‹: Bell-LaPadula

class SecurityLevel(Enum):
    UNCLASSIFIED = 0
    CONFIDENTIAL = 1
    SECRET = 2
    TOP_SECRET = 3

# ç†è®ºè§„åˆ™å®ç°
def can_read(subject_clearance: SecurityLevel, object_classification: SecurityLevel) -> bool:
    """Simple Security Property: no read up"""
    return subject_clearance.value >= object_classification.value

def can_write(subject_clearance: SecurityLevel, object_classification: SecurityLevel) -> bool:
    """*-Property: no write down"""
    return subject_clearance.value <= object_classification.value

# è‡ªåŠ¨ç”ŸæˆNetworkPolicy
def generate_network_policy(container_clearance: SecurityLevel,
                           target_clearance: SecurityLevel,
                           operation: str) -> dict:
    """
    æ ¹æ®Bell-LaPadulaæ¨¡å‹è‡ªåŠ¨ç”ŸæˆKubernetes NetworkPolicy
    """
    
    if operation == "read" and can_read(container_clearance, target_clearance):
        # å…è®¸è¯»å– (ä»ä½çº§åˆ«è¯»å–é«˜çº§åˆ«æ•°æ®)
        return {
            "apiVersion": "networking.k8s.io/v1",
            "kind": "NetworkPolicy",
            "metadata": {
                "name": f"allow-read-{target_clearance.name.lower()}"
            },
            "spec": {
                "podSelector": {
                    "matchLabels": {
                        "clearance": container_clearance.name.lower()
                    }
                },
                "policyTypes": ["Ingress"],
                "ingress": [{
                    "from": [{
                        "podSelector": {
                            "matchLabels": {
                                "clearance": target_clearance.name.lower()
                            }
                        }
                    }]
                }]
            }
        }
    
    elif operation == "write" and can_write(container_clearance, target_clearance):
        # å…è®¸å†™å…¥ (å‘é«˜çº§åˆ«å†™å…¥æ•°æ®)
        return {
            "apiVersion": "networking.k8s.io/v1",
            "kind": "NetworkPolicy",
            "spec": {
                "podSelector": {
                    "matchLabels": {
                        "clearance": container_clearance.name.lower()
                    }
                },
                "policyTypes": ["Egress"],
                "egress": [{
                    "to": [{
                        "podSelector": {
                            "matchLabels": {
                                "clearance": target_clearance.name.lower()
                            }
                        }
                    }]
                }]
            }
        }
    
    else:
        # æ‹’ç» (è¿åå®‰å…¨ç­–ç•¥)
        return {
            "apiVersion": "networking.k8s.io/v1",
            "kind": "NetworkPolicy",
            "spec": {
                "podSelector": {
                    "matchLabels": {
                        "clearance": container_clearance.name.lower()
                    }
                },
                "policyTypes": ["Ingress", "Egress"],
                "ingress": [],
                "egress": []
            }
        }

# ä½¿ç”¨ç¤ºä¾‹:
# Confidentialå®¹å™¨æƒ³è¦è¯»å–Secretæ•°æ® -> å…è®¸
policy1 = generate_network_policy(
    SecurityLevel.CONFIDENTIAL,
    SecurityLevel.SECRET,
    "read"
)  # ç”Ÿæˆå…è®¸ç­–ç•¥

# Secretå®¹å™¨æƒ³è¦å†™å…¥Unclassifiedæ•°æ® -> æ‹’ç» (write down)
policy2 = generate_network_policy(
    SecurityLevel.SECRET,
    SecurityLevel.UNCLASSIFIED,
    "write"
)  # ç”Ÿæˆæ‹’ç»ç­–ç•¥
```

### 7.3 æ€§èƒ½ä¼˜åŒ–çš„ç†è®ºåŸºç¡€

**åŸºäºAmdahlå®šå¾‹çš„å®¹å™¨æ€§èƒ½ä¼˜åŒ–**:

```haskell
-- Amdahlå®šå¾‹:
-- Speedup = 1 / ((1 - P) + P/S)
-- P: å¯å¹¶è¡ŒåŒ–çš„æ¯”ä¾‹
-- S: å¹¶è¡ŒåŒ–çš„åŠ é€Ÿæ¯”

-- å®¹å™¨æ€§èƒ½ä¼˜åŒ–å†³ç­–
data OptimizationTarget =
    NetworkOptimization    -- ç½‘ç»œI/Oå¯†é›†å‹
  | StorageOptimization    -- å­˜å‚¨I/Oå¯†é›†å‹
  | CPUOptimization        -- CPUå¯†é›†å‹
  | MemoryOptimization     -- å†…å­˜å¯†é›†å‹

-- æ€§èƒ½ç“¶é¢ˆåˆ†æ
analyze_bottleneck :: Container -> OptimizationTarget
analyze_bottleneck container =
    let cpu_util = cpu_utilization container
        mem_util = memory_utilization container
        net_io = network_io_rate container
        disk_io = disk_io_rate container
    in
        if disk_io > high_threshold
        then StorageOptimization
        else if net_io > high_threshold
        then NetworkOptimization
        else if cpu_util > high_threshold
        then CPUOptimization
        else MemoryOptimization

-- ä¼˜åŒ–ç­–ç•¥ç”Ÿæˆ
generate_optimization_strategy :: OptimizationTarget -> OptimizationPlan
generate_optimization_strategy target =
    case target of
        NetworkOptimization ->
            -- æ ¹æ®ç†è®º,å‡å°‘ç½‘ç»œè™šæ‹ŸåŒ–å¼€é”€
            OptimizationPlan {
                use_host_network = True,        -- å‡å°‘30%ç½‘ç»œå¼€é”€
                enable_sr_iov = True,           -- æ¥è¿‘ç‰©ç†ç½‘ç»œæ€§èƒ½
                use_cilium_ebpf = True,         -- å‡å°‘kube-proxyå¼€é”€
                expected_speedup = 1.5          -- é¢„æœŸ1.5å€åŠ é€Ÿ
            }
        
        StorageOptimization ->
            -- å‡å°‘å­˜å‚¨I/Oè·¯å¾„é•¿åº¦
            OptimizationPlan {
                use_local_nvme = True,          -- ç›´æ¥è®¿é—®NVMe
                disable_overlay = True,         -- é¿å…OverlayFSå¼€é”€
                use_io_uring = True,            -- å¼‚æ­¥I/O
                expected_speedup = 2.0          -- é¢„æœŸ2å€åŠ é€Ÿ
            }
        
        CPUOptimization ->
            -- CPUäº²å’Œæ€§å’Œéš”ç¦»
            OptimizationPlan {
                enable_cpu_pinning = True,      -- CPUç»‘å®š
                isolate_cpus = True,            -- CPUéš”ç¦»
                disable_smt = False,            -- ä¿ç•™è¶…çº¿ç¨‹
                expected_speedup = 1.2          -- é¢„æœŸ1.2å€åŠ é€Ÿ
            }
        
        MemoryOptimization ->
            -- å†…å­˜åˆ†é…ä¼˜åŒ–
            OptimizationPlan {
                use_huge_pages = True,          -- å¤§é¡µå†…å­˜
                enable_numa_binding = True,     -- NUMAç»‘å®š
                optimize_memory_allocator = True,
                expected_speedup = 1.3          -- é¢„æœŸ1.3å€åŠ é€Ÿ
            }

-- éªŒè¯ä¼˜åŒ–æ•ˆæœ
verify_optimization :: Container -> OptimizationPlan -> Bool
verify_optimization container plan =
    let before_perf = measure_performance container
        apply_optimization container plan
        after_perf = measure_performance container
        actual_speedup = after_perf / before_perf
    in
        actual_speedup >= (expected_speedup plan * 0.9)  -- å…è®¸10%è¯¯å·®
```

---

## å‚è€ƒæ–‡çŒ®

### ç»å…¸è®ºæ–‡

1. **Popek, G. J., & Goldberg, R. P. (1974)**. "Formal requirements for virtualizable third generation architectures". *Communications of the ACM*, 17(7), 412-421.

2. **Barham, P., et al. (2003)**. "Xen and the art of virtualization". *ACM SIGOPS Operating Systems Review*, 37(5), 164-177.

3. **Kivity, A., et al. (2007)**. "kvm: the Linux virtual machine monitor". *Proceedings of the Linux symposium*, 1, 225-230.

4. **Banga, G., Druschel, P., & Mogul, J. C. (1999)**. "Resource containers: A new facility for resource management in server systems". *OSDI*, 99, 45-58.

5. **Soltesz, S., et al. (2007)**. "Container-based operating system virtualization: a scalable, high-performance alternative to hypervisors". *ACM SIGOPS Operating Systems Review*, 41(3), 275-287.

6. **Merkel, D. (2014)**. "Docker: lightweight linux containers for consistent development and deployment". *Linux journal*, 2014(239), 2.

### å½¢å¼åŒ–éªŒè¯

1. **Klein, G., et al. (2009)**. "seL4: Formal verification of an OS kernel". *ACM SIGOPS Operating Systems Review*, 43(3), 207-220.

2. **Gu, R., et al. (2016)**. "CertiKOS: An extensible architecture for building certified concurrent OS kernels". *OSDI*, 16, 653-669.

3. **Nelson, L., et al. (2017)**. "Hyperkernel: Push-button verification of an OS kernel". *Proceedings of the 26th Symposium on Operating Systems Principles*, 252-269.

### å®‰å…¨

1. **Reshetova, E., et al. (2014)**. "Security of OS-level virtualization technologies". *Nordic Conference on Secure IT Systems*, 77-93.

2. **Bui, T. (2015)**. "Analysis of Docker security". *arXiv preprint arXiv:1501.02967*.

3. **Sultan, F., et al. (2019)**. "Container security: Issues, challenges, and the road ahead". *IEEE Access*, 7, 52976-52996.

### æ€§èƒ½

1. **Felter, W., et al. (2015)**. "An updated performance comparison of virtual machines and Linux containers". *2015 IEEE international symposium on performance analysis of systems and software (ISPASS)*, 171-172.

2. **Morabito, R., KjÃ¤llman, J., & Komu, M. (2015)**. "Hypervisors vs. lightweight virtualization: a performance comparison". *2015 IEEE International Conference on Cloud Engineering*, 386-393.

3. **Agache, A., et al. (2020)**. "Firecracker: Lightweight virtualization for serverless applications". *17th USENIX Symposium on Networked Systems Design and Implementation (NSDI 20)*, 419-434.

### æ ‡å‡†ä¸è§„èŒƒ

1. **OCI Runtime Specification**. Open Container Initiative, https://github.com/opencontainers/runtime-spec

2. **OCI Image Format Specification**. Open Container Initiative, https://github.com/opencontainers/image-spec

3. **Kubernetes Container Runtime Interface (CRI)**. Kubernetes, https://kubernetes.io/docs/concepts/architecture/cri/

4. **Container Network Interface (CNI) Specification**. CNCF, https://github.com/containernetworking/cni

5. **Container Storage Interface (CSI) Specification**. Kubernetes, https://github.com/container-storage-interface/spec

### ä¹¦ç±

1. **Smith, J. E., & Nair, R. (2005)**. *Virtual machines: versatile platforms for systems and processes*. Elsevier.

2. **Tanenbaum, A. S., & Bos, H. (2014)**. *Modern operating systems*. Pearson.

3. **Love, R. (2010)**. *Linux kernel development*. Pearson Education.

4. **Burns, B., & Oppenheimer, D. (2016)**. *Kubernetes: Up and running: Dive into the future of infrastructure*. O'Reilly Media.

5. **LukÅ¡a, M. (2017)**. *Kubernetes in action*. Manning Publications.

---

**æ›´æ–°æ—¶é—´**: 2025-10-20  
**æ–‡æ¡£ç‰ˆæœ¬**: v1.0  
**ä½œè€…**: AI Assistant  
**çŠ¶æ€**: âœ… **å®Œæˆ**

---

**ğŸ“ æœ¬æ–‡æ¡£æä¾›äº†è™šæ‹ŸåŒ–ä¸å®¹å™¨åŒ–æŠ€æœ¯çš„å®Œæ•´ç†è®ºåŸºç¡€,ä»ç¡¬ä»¶ä½“ç³»ç»“æ„åˆ°å½¢å¼åŒ–éªŒè¯,ä¸ºæ·±å…¥ç†è§£å’Œæ­£ç¡®å®ç°è¿™äº›æŠ€æœ¯æä¾›äº†åšå®çš„ç†è®ºæ”¯æ’‘ï¼ğŸ“**-
