# 服务网格安全

## 目录

- [服务网格安全](#服务网格安全)
  - [目录](#目录)
  - [1. 服务网格安全概述](#1-服务网格安全概述)
    - [1.1 安全挑战](#11-安全挑战)
    - [1.2 服务网格安全优势](#12-服务网格安全优势)
    - [1.3 安全架构层次](#13-安全架构层次)
  - [2. 零信任架构](#2-零信任架构)
    - [2.1 零信任原则](#21-零信任原则)
    - [2.2 零信任实施](#22-零信任实施)
    - [2.3 Istio零信任架构](#23-istio零信任架构)
      - [2.3.1 Istio零信任实现](#231-istio零信任实现)
      - [2.3.2 验证零信任配置](#232-验证零信任配置)
    - [2.4 Linkerd零信任架构](#24-linkerd零信任架构)
      - [2.4.1 Linkerd零信任实现](#241-linkerd零信任实现)
      - [2.4.2 验证Linkerd零信任](#242-验证linkerd零信任)
  - [3. mTLS深度剖析](#3-mtls深度剖析)
    - [3.1 mTLS工作原理](#31-mtls工作原理)
      - [3.1.1 mTLS握手过程](#311-mtls握手过程)
      - [3.1.2 证书结构](#312-证书结构)
    - [3.2 证书生命周期](#32-证书生命周期)
    - [3.3 Istio mTLS](#33-istio-mtls)
      - [3.3.1 Istio mTLS配置](#331-istio-mtls配置)
      - [3.3.2 查看Istio证书](#332-查看istio证书)
    - [3.4 Linkerd mTLS](#34-linkerd-mtls)
      - [3.4.1 Linkerd mTLS（自动启用）](#341-linkerd-mtls自动启用)
    - [3.5 mTLS性能影响](#35-mtls性能影响)
  - [4. 身份认证机制](#4-身份认证机制)
    - [4.1 SPIFFE标准](#41-spiffe标准)
      - [4.1.1 SPIFFE概述](#411-spiffe概述)
      - [4.1.2 Istio SPIFFE实现](#412-istio-spiffe实现)
    - [4.2 JWT认证](#42-jwt认证)
      - [4.2.1 JWT验证配置](#421-jwt验证配置)
      - [4.2.2 JWT测试](#422-jwt测试)
    - [4.3 OAuth2/OIDC集成](#43-oauth2oidc集成)
      - [4.3.1 OAuth2代理配置](#431-oauth2代理配置)
    - [4.4 多因素认证](#44-多因素认证)
  - [5. 授权机制](#5-授权机制)
    - [5.1 RBAC授权](#51-rbac授权)
      - [5.1.1 Istio RBAC](#511-istio-rbac)
      - [5.1.2 Kubernetes RBAC集成](#512-kubernetes-rbac集成)
    - [5.2 ABAC授权](#52-abac授权)
    - [5.3 OPA集成](#53-opa集成)
      - [5.3.1 部署OPA](#531-部署opa)
      - [5.3.2 OPA策略](#532-opa策略)
      - [5.3.3 Istio OPA集成](#533-istio-opa集成)
    - [5.4 授权实战](#54-授权实战)
      - [5.4.1 多层授权](#541-多层授权)
  - [6. 证书管理与PKI](#6-证书管理与pki)
    - [6.1 PKI架构](#61-pki架构)
    - [6.2 cert-manager集成](#62-cert-manager集成)
      - [6.2.1 安装cert-manager](#621-安装cert-manager)
      - [6.2.2 创建CA](#622-创建ca)
      - [6.2.3 Istio与cert-manager集成](#623-istio与cert-manager集成)
      - [6.2.4 Linkerd与cert-manager集成](#624-linkerd与cert-manager集成)
    - [6.3 证书轮换策略](#63-证书轮换策略)
    - [6.4 证书监控告警](#64-证书监控告警)
  - [7. 供应链安全](#7-供应链安全)
    - [7.1 镜像签名验证](#71-镜像签名验证)
      - [7.1.1 Sigstore/Cosign](#711-sigstorecosign)
      - [7.1.2 Kubernetes镜像策略](#712-kubernetes镜像策略)
    - [7.2 SBOM管理](#72-sbom管理)
    - [7.3 漏洞扫描](#73-漏洞扫描)
    - [7.4 供应链最佳实践](#74-供应链最佳实践)
  - [8. 审计与合规](#8-审计与合规)
    - [8.1 审计日志](#81-审计日志)
      - [8.1.1 Kubernetes审计](#811-kubernetes审计)
      - [8.1.2 Istio访问日志](#812-istio访问日志)
    - [8.2 合规标准](#82-合规标准)
    - [8.3 安全审计实践](#83-安全审计实践)
  - [9. 安全实战案例](#9-安全实战案例)
    - [9.1 金融级零信任架构](#91-金融级零信任架构)
    - [9.2 多租户隔离](#92-多租户隔离)
    - [9.3 东西向流量加密](#93-东西向流量加密)
  - [10. 安全最佳实践](#10-安全最佳实践)
  - [11. 总结](#11-总结)
    - [11.1 服务网格安全核心价值](#111-服务网格安全核心价值)
    - [11.2 Istio vs Linkerd安全对比](#112-istio-vs-linkerd安全对比)
    - [11.3 未来展望](#113-未来展望)

---

## 1. 服务网格安全概述

### 1.1 安全挑战

在微服务架构中，安全面临诸多挑战：

```yaml
传统微服务安全挑战:

1. 服务间通信:
   ❌ 明文传输
   ❌ 无身份验证
   ❌ 易受中间人攻击
   ❌ 难以审计

2. 身份管理:
   ❌ 静态密钥
   ❌ 密钥分发困难
   ❌ 密钥泄露风险
   ❌ 轮换复杂

3. 访问控制:
   ❌ 应用层实现不一致
   ❌ 缺乏统一策略
   ❌ 难以审计
   ❌ 更新困难

4. 合规要求:
   ❌ 缺乏加密证明
   ❌ 审计日志不完整
   ❌ 难以满足监管要求

5. 运维复杂:
   ❌ 证书管理复杂
   ❌ 手动轮换
   ❌ 配置分散
   ❌ 故障排查困难
```

### 1.2 服务网格安全优势

```yaml
服务网格安全优势:

1. 透明加密:
   ✅ 自动mTLS
   ✅ 无需修改应用代码
   ✅ 服务间通信加密
   ✅ 中间人攻击防护

2. 强身份:
   ✅ SPIFFE标准身份
   ✅ 基于服务账号
   ✅ 自动证书颁发
   ✅ 自动证书轮换

3. 细粒度授权:
   ✅ 服务级别控制
   ✅ 方法级别控制
   ✅ 路径级别控制
   ✅ 声明式策略

4. 可观测性:
   ✅ 完整审计日志
   ✅ 流量可视化
   ✅ 安全指标监控
   ✅ 异常检测

5. 集中管理:
   ✅ 统一策略管理
   ✅ 统一证书管理
   ✅ 配置即代码
   ✅ GitOps友好
```

### 1.3 安全架构层次

```yaml
服务网格安全层次模型:

Layer 1 - 网络安全:
  - Kubernetes NetworkPolicy
  - CNI插件安全
  - 网络隔离
  - DDoS防护

Layer 2 - 传输安全 (服务网格核心):
  - mTLS加密
  - 证书管理
  - 身份认证
  - 服务身份

Layer 3 - 应用安全 (服务网格增强):
  - JWT验证
  - API认证
  - 速率限制
  - WAF集成

Layer 4 - 授权安全 (服务网格核心):
  - RBAC
  - ABAC
  - OPA策略
  - 细粒度授权

Layer 5 - 审计与合规:
  - 审计日志
  - 安全监控
  - 合规报告
  - 威胁检测

深度防御策略:
  ✅ 多层安全
  ✅ 纵深防御
  ✅ 最小权限
  ✅ 持续监控
```

---

## 2. 零信任架构

### 2.1 零信任原则

```yaml
零信任核心原则:

1. 永不信任，始终验证 (Never Trust, Always Verify):
   - 不信任网络位置
   - 不信任IP地址
   - 每次请求都验证
   - 持续验证身份

2. 最小权限原则 (Least Privilege):
   - 默认拒绝所有访问
   - 显式授权所需权限
   - 时间限制访问
   - 定期审核权限

3. 微分段 (Micro-Segmentation):
   - 服务级别隔离
   - 工作负载隔离
   - 命名空间隔离
   - 细粒度网络策略

4. 持续监控与验证:
   - 实时流量监控
   - 异常行为检测
   - 自动响应
   - 审计日志

5. 加密无处不在:
   - 东西向流量加密
   - 南北向流量加密
   - 静态数据加密
   - 端到端加密
```

### 2.2 零信任实施

```yaml
零信任实施步骤:

阶段1: 资产识别
  1. 识别所有服务
  2. 识别数据流
  3. 识别依赖关系
  4. 绘制服务拓扑

阶段2: 网络分段
  1. 服务分组
  2. 命名空间隔离
  3. 网络策略
  4. 微分段

阶段3: 身份管理
  1. 服务身份分配
  2. 证书颁发
  3. 自动轮换
  4. 身份验证

阶段4: 访问控制
  1. 默认拒绝策略
  2. 显式授权规则
  3. 最小权限
  4. 动态授权

阶段5: 监控审计
  1. 流量监控
  2. 异常检测
  3. 审计日志
  4. 安全告警
```

### 2.3 Istio零信任架构

#### 2.3.1 Istio零信任实现

```yaml
# 步骤1: 启用全局严格mTLS
apiVersion: security.istio.io/v1beta1
kind: PeerAuthentication
metadata:
  name: default
  namespace: istio-system
spec:
  mtls:
    mode: STRICT  # 强制所有流量使用mTLS
---
# 步骤2: 默认拒绝所有访问
apiVersion: security.istio.io/v1beta1
kind: AuthorizationPolicy
metadata:
  name: deny-all
  namespace: default
spec:
  {}  # 空策略表示拒绝所有
---
# 步骤3: 显式允许必要的服务间通信
apiVersion: security.istio.io/v1beta1
kind: AuthorizationPolicy
metadata:
  name: allow-frontend-to-backend
  namespace: default
spec:
  selector:
    matchLabels:
      app: backend
  action: ALLOW
  rules:
  - from:
    - source:
        principals:
        - "cluster.local/ns/default/sa/frontend"
    to:
    - operation:
        methods: ["GET", "POST"]
        paths: ["/api/*"]
---
# 步骤4: JWT验证（终端用户认证）
apiVersion: security.istio.io/v1beta1
kind: RequestAuthentication
metadata:
  name: jwt-auth
  namespace: default
spec:
  selector:
    matchLabels:
      app: frontend
  jwtRules:
  - issuer: "https://auth.example.com"
    jwksUri: "https://auth.example.com/.well-known/jwks.json"
    audiences:
    - "api.example.com"
---
# 步骤5: 基于JWT Claims的授权
apiVersion: security.istio.io/v1beta1
kind: AuthorizationPolicy
metadata:
  name: jwt-authz
  namespace: default
spec:
  selector:
    matchLabels:
      app: frontend
  action: ALLOW
  rules:
  - when:
    - key: request.auth.claims[iss]
      values: ["https://auth.example.com"]
    - key: request.auth.claims[role]
      values: ["user", "admin"]
```

#### 2.3.2 验证零信任配置

```bash
# 验证mTLS状态
istioctl authn tls-check <pod-name>.<namespace>

# 输出示例
HOST:PORT                                  STATUS     SERVER     CLIENT     AUTHN POLICY     DESTINATION RULE
backend.default.svc.cluster.local:8080     OK         mTLS       mTLS       default/         -

# 测试授权策略
kubectl exec <frontend-pod> -- curl http://backend:8080/api/users

# 应该成功（已授权）

kubectl exec <unauthorized-pod> -- curl http://backend:8080/api/users

# 应该失败（RBAC: access denied）

# 查看拒绝日志
kubectl logs -n istio-system -l app=istiod | grep "RBAC: access denied"
```

### 2.4 Linkerd零信任架构

#### 2.4.1 Linkerd零信任实现

```yaml
# 步骤1: Linkerd默认启用mTLS（无需配置）
# 所有注入Linkerd的服务自动获得mTLS

# 步骤2: 设置默认拒绝策略
# 修改Linkerd配置
apiVersion: v1
kind: ConfigMap
metadata:
  name: linkerd-config
  namespace: linkerd
data:
  config: |
    proxyInit:
      ignoreInboundPorts: ""
      ignoreOutboundPorts: ""
    proxy:
      defaultInboundPolicy: "deny"  # 默认拒绝

# 步骤3: 定义Server资源
apiVersion: policy.linkerd.io/v1beta1
kind: Server
metadata:
  name: backend-http
  namespace: default
spec:
  podSelector:
    matchLabels:
      app: backend
  port: 8080
  proxyProtocol: HTTP/2
---
# 步骤4: 定义ServerAuthorization
apiVersion: policy.linkerd.io/v1beta1
kind: ServerAuthorization
metadata:
  name: allow-frontend
  namespace: default
spec:
  server:
    name: backend-http
  client:
    meshTLS:
      serviceAccounts:
      - name: frontend
        namespace: default
```

#### 2.4.2 验证Linkerd零信任

```bash
# 验证mTLS状态
linkerd viz edges deployment

# 输出
SRC        DST        SRC_NS    DST_NS    SECURED
frontend   backend    default   default   √

# 测试授权
kubectl exec <frontend-pod> -- curl http://backend:8080/api/users
# 应该成功

kubectl exec <unauthorized-pod> -- curl http://backend:8080/api/users
# 应该失败

# 实时查看被拒绝的请求
linkerd viz tap deploy/backend | grep "status=403"
```

---

## 3. mTLS深度剖析

### 3.1 mTLS工作原理

#### 3.1.1 mTLS握手过程

```yaml
mTLS握手流程 (服务A → 服务B):

1. ClientHello (A → B):
   - 支持的TLS版本
   - 支持的加密套件
   - 客户端随机数

2. ServerHello (B → A):
   - 选择的TLS版本
   - 选择的加密套件
   - 服务器随机数
   - 服务器证书 (B的身份)
   - Certificate Request (要求客户端证书)

3. Client Certificate (A → B):
   - 客户端证书 (A的身份)
   - Certificate Verify (证明拥有私钥)

4. 双向验证:
   - A验证B的证书（是否由可信CA签名）
   - B验证A的证书（是否由可信CA签名）
   - 验证证书链
   - 检查证书有效期
   - 检查证书撤销状态

5. Session Keys交换:
   - 使用双方公钥交换会话密钥
   - 派生对称加密密钥

6. Encrypted Communication:
   - 使用会话密钥加密所有通信
   - 保证机密性和完整性

传统TLS vs mTLS:
  TLS (单向):
    - 只验证服务器身份
    - 客户端不需要证书
    - 常用于HTTPS
  
  mTLS (双向):
    - 同时验证双方身份
    - 客户端和服务器都需要证书
    - 适用于服务间通信
```

#### 3.1.2 证书结构

```yaml
X.509证书结构:

Version: 3
Serial Number: 123456789
Signature Algorithm: ecdsa-with-SHA256
Issuer: CN=Istio CA (或 Linkerd Identity)
Validity:
  Not Before: 2025-10-19 00:00:00 UTC
  Not After:  2025-10-20 00:00:00 UTC  # 24小时有效期
Subject: CN=frontend.default.serviceaccount.identity.linkerd.cluster.local
Subject Public Key Info:
  Public Key Algorithm: id-ecPublicKey (ECDSA P-256)
  Public Key: 04:ab:cd:ef:...
X509v3 Extensions:
  X509v3 Subject Alternative Name:
    URI:spiffe://cluster.local/ns/default/sa/frontend
  X509v3 Key Usage: critical
    Digital Signature, Key Encipherment
  X509v3 Extended Key Usage:
    TLS Web Server Authentication, TLS Web Client Authentication

SPIFFE ID格式:
  spiffe://<trust-domain>/ns/<namespace>/sa/<serviceaccount>
  
  示例:
  spiffe://cluster.local/ns/default/sa/frontend
  spiffe://cluster.local/ns/prod/sa/payment-service

优势:
  ✅ 基于Kubernetes ServiceAccount
  ✅ 自动映射到身份
  ✅ 无需手动管理
  ✅ 与RBAC集成
```

### 3.2 证书生命周期

```yaml
证书生命周期管理:

1. 证书颁发:
   时机:
     - Pod启动时
     - Sidecar注入时
   
   流程:
     1. Sidecar proxy向CA请求证书
     2. CA验证请求者身份（基于SA）
     3. CA签发证书
     4. Proxy获取证书和私钥
   
   参数:
     - 有效期: 24小时（可配置）
     - 算法: ECDSA P-256
     - 身份: SPIFFE ID

2. 证书使用:
   - 建立mTLS连接
   - 双向身份验证
   - 加密通信

3. 证书轮换:
   时机:
     - 证书过期前（通常50%生命周期）
     - Istio: 过期前12小时
     - Linkerd: 过期前12小时
   
   流程:
     1. Proxy检测证书即将过期
     2. 向CA请求新证书
     3. 获取新证书
     4. 替换旧证书
     5. 继续服务（无中断）
   
   特点:
     ✅ 自动轮换
     ✅ 零停机
     ✅ 平滑过渡

4. 证书撤销:
   场景:
     - ServiceAccount被删除
     - Pod被删除
     - 安全事件
   
   方法:
     - 证书短期有效（24小时）
     - 不使用CRL（证书撤销列表）
     - 依赖短期证书自动过期

证书存储:
  Istio:
    - 路径: /etc/certs/
    - cert-chain.pem: 证书链
    - key.pem: 私钥
    - root-cert.pem: 根证书
  
  Linkerd:
    - 通过Secret注入
    - Proxy内存中存储
    - 不写入磁盘
```

### 3.3 Istio mTLS

#### 3.3.1 Istio mTLS配置

```yaml
# 1. 全局严格mTLS
apiVersion: security.istio.io/v1beta1
kind: PeerAuthentication
metadata:
  name: default
  namespace: istio-system
spec:
  mtls:
    mode: STRICT
---
# 2. Namespace级别宽松模式（迁移阶段）
apiVersion: security.istio.io/v1beta1
kind: PeerAuthentication
metadata:
  name: default
  namespace: legacy
spec:
  mtls:
    mode: PERMISSIVE  # 同时接受mTLS和明文
---
# 3. 工作负载级别配置
apiVersion: security.istio.io/v1beta1
kind: PeerAuthentication
metadata:
  name: httpbin
  namespace: default
spec:
  selector:
    matchLabels:
      app: httpbin
  mtls:
    mode: STRICT
  portLevelMtls:
    8080:
      mode: STRICT
    9080:
      mode: DISABLE  # 特定端口禁用（如健康检查）
---
# 4. DestinationRule配置mTLS
apiVersion: networking.istio.io/v1beta1
kind: DestinationRule
metadata:
  name: api-mtls
spec:
  host: api.example.com
  trafficPolicy:
    tls:
      mode: ISTIO_MUTUAL  # 使用Istio管理的mTLS
```

#### 3.3.2 查看Istio证书

```bash
# 查看证书详情
istioctl proxy-config secret <pod-name> -o json | \
  jq -r '.dynamicActiveSecrets[0].secret.tlsCertificate.certificateChain.inlineBytes' | \
  base64 -d | openssl x509 -text -noout

# 输出（简化）
Certificate:
    Version: 3
    Serial Number: 12345678
    Signature Algorithm: ecdsa-with-SHA256
    Issuer: O=cluster.local
    Validity
        Not Before: Oct 19 00:00:00 2025 GMT
        Not After : Oct 20 00:00:00 2025 GMT
    Subject: 
    Subject Public Key Info:
        Public Key Algorithm: id-ecPublicKey
            Public-Key: (256 bit)
    X509v3 extensions:
        X509v3 Subject Alternative Name: critical
            URI:spiffe://cluster.local/ns/default/sa/frontend

# 验证mTLS状态
istioctl authn tls-check <pod-name>.<namespace>

# 查看mTLS使用率
kubectl exec -it <pod-name> -c istio-proxy -- \
  curl localhost:15000/stats/prometheus | grep ssl

# 输出
envoy_listener_ssl_connection_active{...} 5
envoy_listener_ssl_handshake{...} 100
```

### 3.4 Linkerd mTLS

#### 3.4.1 Linkerd mTLS（自动启用）

```bash
# Linkerd mTLS是默认启用的，无需配置

# 查看mTLS状态
linkerd viz edges deployment

# 输出
SRC           DST           SRC_NS      DST_NS      SECURED
frontend      backend       default     default     √
backend       database      default     default     √

# 查看证书详情
kubectl exec <pod-name> -c linkerd-proxy -- \
  openssl s_client -connect <service>:8080 < /dev/null 2>/dev/null | \
  openssl x509 -text -noout

# 输出
Certificate:
    Validity
        Not Before: Oct 19 00:00:00 2025 GMT
        Not After : Oct 20 00:00:00 2025 GMT
    Subject: CN=frontend.default.serviceaccount.identity.linkerd.cluster.local
    X509v3 extensions:
        X509v3 Subject Alternative Name: 
            URI:spiffe://cluster.local/ns/default/sa/frontend

# 查看mTLS统计
linkerd viz stat deploy --from deploy/frontend
```

### 3.5 mTLS性能影响

```yaml
mTLS性能测试结果:

测试环境:
  - 场景: HTTP/1.1，1KB请求
  - QPS: 1000
  - 并发: 100

Baseline (无加密):
  - P50延迟: 1.0ms
  - P99延迟: 3.0ms
  - CPU: 10%
  - 吞吐量: 10000 QPS

TLS 1.2:
  - P50延迟: 1.5ms (+50%)
  - P99延迟: 4.5ms (+50%)
  - CPU: 15% (+50%)
  - 吞吐量: 8500 QPS (-15%)

TLS 1.3 (Istio/Linkerd使用):
  - P50延迟: 1.2ms (+20%)
  - P99延迟: 3.5ms (+17%)
  - CPU: 12% (+20%)
  - 吞吐量: 9500 QPS (-5%)

结论:
  ✅ TLS 1.3性能优秀
  ✅ 握手时间减少
  ✅ CPU开销可接受
  ✅ 安全收益远大于性能损失

优化建议:
  1. 使用TLS 1.3
  2. 启用会话恢复
  3. 使用ECDSA证书（比RSA快）
  4. 合理设置连接池
  5. 监控TLS握手时间
```

---

## 4. 身份认证机制

### 4.1 SPIFFE标准

#### 4.1.1 SPIFFE概述

```yaml
SPIFFE (Secure Production Identity Framework for Everyone):

核心概念:

1. SPIFFE ID:
   - 格式: spiffe://<trust-domain>/<workload-identifier>
   - 示例: spiffe://cluster.local/ns/default/sa/frontend
   - 唯一标识工作负载
   - 与平台无关

2. SVID (SPIFFE Verifiable Identity Document):
   - X.509-SVID: X.509证书
   - JWT-SVID: JWT令牌
   - 可验证的身份文档
   - 用于身份验证

3. Workload API:
   - 工作负载获取SVID的API
   - Unix Domain Socket
   - 自动证书轮换
   - 安全分发

4. Trust Bundle:
   - 可信CA证书集合
   - 验证SVID的根证书
   - 跨信任域联邦

SPIFFE优势:
  ✅ 平台无关
  ✅ 标准化身份
  ✅ 互操作性
  ✅ 安全性高
  ✅ 自动化管理
```

#### 4.1.2 Istio SPIFFE实现

```bash
# 查看SPIFFE ID
kubectl exec <pod-name> -c istio-proxy -- \
  pilot-agent request GET certs | jq -r '.cert_chain[0]' | \
  base64 -d | openssl x509 -text -noout | grep URI

# 输出
URI:spiffe://cluster.local/ns/default/sa/frontend

# 验证SPIFFE身份
istioctl proxy-config secret <pod-name> -o json | \
  jq '.dynamicActiveSecrets[0].secret.tlsCertificate.certificateChain.inlineBytes' | \
  base64 -d | openssl x509 -text -noout | grep -A1 "Subject Alternative Name"

# 输出
X509v3 Subject Alternative Name: critical
    URI:spiffe://cluster.local/ns/default/sa/frontend
```

### 4.2 JWT认证

#### 4.2.1 JWT验证配置

```yaml
# RequestAuthentication: 验证JWT
apiVersion: security.istio.io/v1beta1
kind: RequestAuthentication
metadata:
  name: jwt-auth
  namespace: default
spec:
  selector:
    matchLabels:
      app: api
  jwtRules:
  - issuer: "https://auth.example.com"
    jwksUri: "https://auth.example.com/.well-known/jwks.json"
    audiences:
    - "api.example.com"
    forwardOriginalToken: true
    outputPayloadToHeader: "x-jwt-payload"
---
# AuthorizationPolicy: 基于JWT Claims授权
apiVersion: security.istio.io/v1beta1
kind: AuthorizationPolicy
metadata:
  name: jwt-authz
  namespace: default
spec:
  selector:
    matchLabels:
      app: api
  action: ALLOW
  rules:
  # 规则1: 管理员
  - when:
    - key: request.auth.claims[role]
      values: ["admin"]
  
  # 规则2: 用户访问自己的资源
  - when:
    - key: request.auth.claims[sub]
      values: ["*"]
    to:
    - operation:
        paths: ["/api/users/${request.auth.claims[sub]}/*"]
  
  # 规则3: 特定scope
  - when:
    - key: request.auth.claims[scope]
      values: ["read:users"]
    to:
    - operation:
        methods: ["GET"]
        paths: ["/api/users/*"]
```

#### 4.2.2 JWT测试

```bash
# 生成测试JWT (使用jwt.io或自己的auth server)
export JWT_TOKEN="eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9..."

# 不带JWT访问（应该失败）
curl http://api.example.com/api/users

# 输出
RBAC: access denied

# 带JWT访问（应该成功）
curl -H "Authorization: Bearer $JWT_TOKEN" \
  http://api.example.com/api/users

# 输出
{"users": [...]}

# 查看JWT验证日志
kubectl logs -n istio-system -l app=istiod | grep "JWT"
```

### 4.3 OAuth2/OIDC集成

#### 4.3.1 OAuth2代理配置

```yaml
# 部署OAuth2 Proxy
apiVersion: apps/v1
kind: Deployment
metadata:
  name: oauth2-proxy
  namespace: default
spec:
  replicas: 1
  selector:
    matchLabels:
      app: oauth2-proxy
  template:
    metadata:
      labels:
        app: oauth2-proxy
    spec:
      containers:
      - name: oauth2-proxy
        image: quay.io/oauth2-proxy/oauth2-proxy:latest
        args:
        - --provider=oidc
        - --oidc-issuer-url=https://auth.example.com
        - --client-id=my-client-id
        - --client-secret=my-client-secret
        - --cookie-secret=random-secret
        - --email-domain=*
        - --upstream=http://api:8080
        - --http-address=0.0.0.0:4180
        ports:
        - containerPort: 4180
---
# Service
apiVersion: v1
kind: Service
metadata:
  name: oauth2-proxy
spec:
  selector:
    app: oauth2-proxy
  ports:
  - port: 4180
    targetPort: 4180
---
# Gateway配置
apiVersion: networking.istio.io/v1beta1
kind: Gateway
metadata:
  name: api-gateway
spec:
  selector:
    istio: ingressgateway
  servers:
  - port:
      number: 80
      name: http
      protocol: HTTP
    hosts:
    - "api.example.com"
---
# VirtualService路由到OAuth2 Proxy
apiVersion: networking.istio.io/v1beta1
kind: VirtualService
metadata:
  name: api-vs
spec:
  hosts:
  - "api.example.com"
  gateways:
  - api-gateway
  http:
  - route:
    - destination:
        host: oauth2-proxy
        port:
          number: 4180
```

### 4.4 多因素认证

```yaml
多因素认证集成:

方案1: OAuth2 Proxy + MFA提供商
  - 用户首先通过OAuth2/OIDC登录
  - MFA由Identity Provider处理
  - OAuth2 Proxy验证令牌
  - 令牌包含MFA信息

方案2: API Gateway + MFA
  - 在Istio Gateway前部署API Gateway
  - API Gateway处理MFA
  - 通过后转发到Istio
  - Istio验证JWT

方案3: 应用层MFA
  - 服务网格处理mTLS
  - 应用层处理用户MFA
  - 分层安全

推荐架构:
  User → MFA Provider → OAuth2/OIDC → JWT → Istio Gateway → Services
                                          ↓
                                     JWT验证
                                     Claims授权
```

---

## 5. 授权机制

### 5.1 RBAC授权

#### 5.1.1 Istio RBAC

```yaml
# 基于服务身份的RBAC
apiVersion: security.istio.io/v1beta1
kind: AuthorizationPolicy
metadata:
  name: service-rbac
  namespace: default
spec:
  selector:
    matchLabels:
      app: database
  action: ALLOW
  rules:
  # 规则1: 允许backend服务访问
  - from:
    - source:
        principals:
        - "cluster.local/ns/default/sa/backend"
    to:
    - operation:
        methods: ["GET", "POST", "PUT", "DELETE"]
        paths: ["/db/*"]
  
  # 规则2: 允许admin服务完全访问
  - from:
    - source:
        principals:
        - "cluster.local/ns/admin/sa/db-admin"
```

#### 5.1.2 Kubernetes RBAC集成

```yaml
# ServiceAccount
apiVersion: v1
kind: ServiceAccount
metadata:
  name: backend
  namespace: default
---
# Role
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  name: backend-role
  namespace: default
rules:
- apiGroups: [""]
  resources: ["secrets"]
  resourceNames: ["db-credentials"]
  verbs: ["get"]
---
# RoleBinding
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: backend-binding
  namespace: default
subjects:
- kind: ServiceAccount
  name: backend
  namespace: default
roleRef:
  kind: Role
  name: backend-role
  apiGroup: rbac.authorization.k8s.io
---
# Istio AuthorizationPolicy基于K8s RBAC
apiVersion: security.istio.io/v1beta1
kind: AuthorizationPolicy
metadata:
  name: k8s-rbac-authz
  namespace: default
spec:
  selector:
    matchLabels:
      app: api
  action: ALLOW
  rules:
  - from:
    - source:
        principals:
        - "cluster.local/ns/default/sa/backend"  # 使用K8s SA
```

### 5.2 ABAC授权

```yaml
# 基于属性的访问控制 (Attribute-Based Access Control)

# 基于HTTP Headers
apiVersion: security.istio.io/v1beta1
kind: AuthorizationPolicy
metadata:
  name: abac-headers
  namespace: default
spec:
  selector:
    matchLabels:
      app: api
  action: ALLOW
  rules:
  - when:
    - key: request.headers[x-user-group]
      values: ["engineering", "admin"]
    - key: request.headers[x-environment]
      values: ["prod"]
    to:
    - operation:
        paths: ["/api/prod/*"]
---
# 基于源IP
apiVersion: security.istio.io/v1beta1
kind: AuthorizationPolicy
metadata:
  name: abac-ip
  namespace: default
spec:
  selector:
    matchLabels:
      app: admin-api
  action: ALLOW
  rules:
  - from:
    - source:
        ipBlocks:
        - "10.0.0.0/8"     # 内网IP
        - "192.168.1.0/24" # VPN IP段
---
# 基于时间（需要OPA）
apiVersion: security.istio.io/v1beta1
kind: AuthorizationPolicy
metadata:
  name: abac-custom
  namespace: default
spec:
  selector:
    matchLabels:
      app: api
  action: CUSTOM
  provider:
    name: opa
  rules:
  - to:
    - operation:
        paths: ["/api/*"]
```

### 5.3 OPA集成

#### 5.3.1 部署OPA

```yaml
# 部署OPA
apiVersion: apps/v1
kind: Deployment
metadata:
  name: opa
  namespace: default
spec:
  replicas: 1
  selector:
    matchLabels:
      app: opa
  template:
    metadata:
      labels:
        app: opa
    spec:
      containers:
      - name: opa
        image: openpolicyagent/opa:latest
        ports:
        - containerPort: 8181
        args:
        - "run"
        - "--server"
        - "--addr=0.0.0.0:8181"
        volumeMounts:
        - name: policies
          mountPath: /policies
      volumes:
      - name: policies
        configMap:
          name: opa-policies
---
# Service
apiVersion: v1
kind: Service
metadata:
  name: opa
spec:
  selector:
    app: opa
  ports:
  - port: 8181
    targetPort: 8181
```

#### 5.3.2 OPA策略

```rego
# OPA策略 (Rego语言)
package istio.authz

import input.attributes.request.http as http_request
import input.attributes.source.address as source_address

# 默认拒绝
default allow = false

# 规则1: 工作时间允许访问
allow {
  is_working_hours
  is_authorized_user
}

# 规则2: 管理员总是允许
allow {
  input.parsed_body.role == "admin"
}

# 工作时间判断 (09:00-18:00, UTC)
is_working_hours {
  time.clock([hour, _, _])
  hour >= 9
  hour < 18
}

# 授权用户判断
is_authorized_user {
  http_request.headers["x-user-group"] == "engineering"
}

# 速率限制
allow {
  not rate_limit_exceeded
}

rate_limit_exceeded {
  count(recent_requests) > 100
}

recent_requests[r] {
  r := data.requests[_]
  r.user == input.parsed_body.user
  r.timestamp > time.now_ns() - 60000000000  # 最近1分钟
}
```

#### 5.3.3 Istio OPA集成

```yaml
# ConfigMap存储OPA策略
apiVersion: v1
kind: ConfigMap
metadata:
  name: opa-policies
  namespace: default
data:
  policy.rego: |
    package istio.authz
    default allow = false
    allow {
      input.parsed_path[0] == "api"
      input.parsed_path[1] == "public"
    }
    allow {
      input.attributes.request.http.headers["x-api-key"] == "secret"
    }
---
# ExtensionProvider配置OPA
apiVersion: install.istio.io/v1alpha1
kind: IstioOperator
spec:
  meshConfig:
    extensionProviders:
    - name: opa
      envoyExtAuthzGrpc:
        service: opa.default.svc.cluster.local
        port: 9191
---
# AuthorizationPolicy使用OPA
apiVersion: security.istio.io/v1beta1
kind: AuthorizationPolicy
metadata:
  name: opa-authz
  namespace: default
spec:
  selector:
    matchLabels:
      app: api
  action: CUSTOM
  provider:
    name: opa
  rules:
  - to:
    - operation:
        paths: ["/api/*"]
```

### 5.4 授权实战

#### 5.4.1 多层授权

```yaml
# 完整的多层授权架构

# Layer 1: 网络层 - NetworkPolicy
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: api-netpol
  namespace: default
spec:
  podSelector:
    matchLabels:
      app: api
  policyTypes:
  - Ingress
  - Egress
  ingress:
  - from:
    - podSelector:
        matchLabels:
          app: frontend
    ports:
    - protocol: TCP
      port: 8080
---
# Layer 2: 服务层 - Istio mTLS
apiVersion: security.istio.io/v1beta1
kind: PeerAuthentication
metadata:
  name: api-mtls
  namespace: default
spec:
  selector:
    matchLabels:
      app: api
  mtls:
    mode: STRICT
---
# Layer 3: 服务身份授权 - RBAC
apiVersion: security.istio.io/v1beta1
kind: AuthorizationPolicy
metadata:
  name: api-rbac
  namespace: default
spec:
  selector:
    matchLabels:
      app: api
  action: ALLOW
  rules:
  - from:
    - source:
        principals:
        - "cluster.local/ns/default/sa/frontend"
    to:
    - operation:
        methods: ["GET", "POST"]
---
# Layer 4: 终端用户认证 - JWT
apiVersion: security.istio.io/v1beta1
kind: RequestAuthentication
metadata:
  name: api-jwt
  namespace: default
spec:
  selector:
    matchLabels:
      app: api
  jwtRules:
  - issuer: "https://auth.example.com"
    jwksUri: "https://auth.example.com/.well-known/jwks.json"
---
# Layer 5: 细粒度授权 - Claims
apiVersion: security.istio.io/v1beta1
kind: AuthorizationPolicy
metadata:
  name: api-claims
  namespace: default
spec:
  selector:
    matchLabels:
      app: api
  action: ALLOW
  rules:
  - when:
    - key: request.auth.claims[role]
      values: ["user", "admin"]
    to:
    - operation:
        paths: ["/api/users/*"]
```

---

## 6. 证书管理与PKI

### 6.1 PKI架构

```yaml
服务网格PKI架构:

三层PKI架构:

1. Root CA (根CA):
   - 离线存储
   - 高度安全
   - 长期有效 (10年+)
   - 签发中间CA证书

2. Intermediate CA (中间CA):
   - Istio CA / Linkerd Identity
   - 在线运行
   - 中期有效 (1-5年)
   - 签发工作负载证书

3. Leaf Certificates (叶子证书):
   - 工作负载证书
   - 短期有效 (24小时)
   - 自动轮换
   - SPIFFE ID

证书链验证:
  Workload Cert → Intermediate CA → Root CA
  
  每个工作负载验证:
    1. 证书由可信中间CA签发
    2. 中间CA由根CA签发
    3. 根CA在信任列表中
    4. 证书未过期
    5. SPIFFE ID匹配

优势:
  ✅ 根CA离线，高度安全
  ✅ 中间CA compromise不影响根CA
  ✅ 工作负载证书短期，自动轮换
  ✅ 分层管理，职责分离
```

### 6.2 cert-manager集成

#### 6.2.1 安装cert-manager

```bash
# 安装cert-manager
kubectl apply -f https://github.com/cert-manager/cert-manager/releases/download/v1.13.0/cert-manager.yaml

# 验证安装
kubectl get pods -n cert-manager

# 输出
NAME                                       READY   STATUS
cert-manager-xxxxx                         1/1     Running
cert-manager-cainjector-xxxxx              1/1     Running
cert-manager-webhook-xxxxx                 1/1     Running
```

#### 6.2.2 创建CA

```yaml
# 自签名CA
apiVersion: cert-manager.io/v1
kind: ClusterIssuer
metadata:
  name: selfsigned-issuer
spec:
  selfSigned: {}
---
# 根CA证书
apiVersion: cert-manager.io/v1
kind: Certificate
metadata:
  name: root-ca
  namespace: cert-manager
spec:
  isCA: true
  commonName: root-ca
  secretName: root-ca-secret
  privateKey:
    algorithm: ECDSA
    size: 256
  issuerRef:
    name: selfsigned-issuer
    kind: ClusterIssuer
    group: cert-manager.io
  duration: 87600h  # 10年
---
# 根CA Issuer
apiVersion: cert-manager.io/v1
kind: ClusterIssuer
metadata:
  name: root-ca-issuer
spec:
  ca:
    secretName: root-ca-secret
```

#### 6.2.3 Istio与cert-manager集成

```yaml
# Istio中间CA证书
apiVersion: cert-manager.io/v1
kind: Certificate
metadata:
  name: istio-ca
  namespace: istio-system
spec:
  isCA: true
  commonName: istio-ca
  secretName: istio-ca-secret
  duration: 8760h  # 1年
  renewBefore: 720h  # 提前30天续期
  privateKey:
    algorithm: ECDSA
    size: 256
  issuerRef:
    name: root-ca-issuer
    kind: ClusterIssuer
  dnsNames:
  - istiod.istio-system.svc
---
# 安装Istio时使用cert-manager证书
apiVersion: install.istio.io/v1alpha1
kind: IstioOperator
metadata:
  name: istio
  namespace: istio-system
spec:
  components:
    pilot:
      k8s:
        env:
        - name: ENABLE_CA_SERVER
          value: "false"  # 禁用内置CA
  values:
    global:
      caAddress: cert-manager-istio-csr.cert-manager.svc:443
```

#### 6.2.4 Linkerd与cert-manager集成

```bash
# 使用cert-manager生成Linkerd证书
kubectl apply -f - <<EOF
apiVersion: cert-manager.io/v1
kind: Certificate
metadata:
  name: linkerd-trust-anchor
  namespace: linkerd
spec:
  isCA: true
  commonName: root.linkerd.cluster.local
  secretName: linkerd-trust-anchor
  duration: 87600h  # 10年
  privateKey:
    algorithm: ECDSA
  issuerRef:
    name: root-ca-issuer
    kind: ClusterIssuer
---
apiVersion: cert-manager.io/v1
kind: Certificate
metadata:
  name: linkerd-identity-issuer
  namespace: linkerd
spec:
  isCA: true
  commonName: identity.linkerd.cluster.local
  secretName: linkerd-identity-issuer
  duration: 8760h  # 1年
  renewBefore: 720h
  privateKey:
    algorithm: ECDSA
  issuerRef:
    name: linkerd-trust-anchor-issuer
    kind: Issuer
  dnsNames:
  - identity.linkerd.cluster.local
  usages:
  - cert sign
  - crl sign
  - server auth
  - client auth
EOF

# 安装Linkerd时使用cert-manager证书
linkerd install \
  --identity-external-issuer \
  --identity-trust-anchors-file <(kubectl get secret linkerd-trust-anchor -n linkerd -o jsonpath='{.data.ca\.crt}' | base64 -d) | \
  kubectl apply -f -
```

### 6.3 证书轮换策略

```yaml
证书轮换策略:

1. 根CA:
   - 有效期: 10年
   - 轮换时机: 不轮换，或极少轮换
   - 轮换方式: 手动，严格控制
   - 影响: 全局，需停机

2. 中间CA:
   - 有效期: 1年
   - 轮换时机: 提前30天
   - 轮换方式: cert-manager自动
   - 影响: 控制平面重启

3. 工作负载证书:
   - 有效期: 24小时
   - 轮换时机: 提前12小时
   - 轮换方式: 完全自动
   - 影响: 零停机

轮换最佳实践:

1. 自动化:
   ✅ 使用cert-manager
   ✅ 配置自动续期
   ✅ 监控续期状态

2. 提前续期:
   ✅ 在有效期50%时续期
   ✅ 预留足够缓冲时间
   ✅ 避免证书过期

3. 监控告警:
   ✅ 监控证书过期时间
   ✅ 提前告警 (7天、3天、1天)
   ✅ 自动通知

4. 灾难恢复:
   ✅ 备份根CA私钥
   ✅ 备份中间CA
   ✅ 定期演练恢复
```

### 6.4 证书监控告警

```yaml
# Prometheus规则监控证书过期
apiVersion: v1
kind: ConfigMap
metadata:
  name: prometheus-rules
  namespace: istio-system
data:
  cert-expiry.yml: |
    groups:
    - name: certificate-expiry
      interval: 1h
      rules:
      # 证书7天内过期
      - alert: CertificateExpiryWarning
        expr: |
          (cert_manager_certificate_expiration_timestamp_seconds - time()) / 86400 < 7
        for: 1h
        labels:
          severity: warning
        annotations:
          summary: "Certificate expiring soon"
          description: "Certificate {{ $labels.name }} in namespace {{ $labels.namespace }} expires in {{ $value }} days"
      
      # 证书1天内过期
      - alert: CertificateExpiryCritical
        expr: |
          (cert_manager_certificate_expiration_timestamp_seconds - time()) / 86400 < 1
        for: 10m
        labels:
          severity: critical
        annotations:
          summary: "Certificate expiring very soon"
          description: "Certificate {{ $labels.name }} expires in {{ $value }} days!"
      
      # Istio CA证书监控
      - alert: IstioCACertExpiry
        expr: |
          (citadel_server_root_cert_expiry_timestamp - time()) / 86400 < 30
        for: 1h
        labels:
          severity: warning
        annotations:
          summary: "Istio CA certificate expiring"
          description: "Istio CA certificate expires in {{ $value }} days"
```

```bash
# 查询证书过期时间
kubectl get certificates -A -o jsonpath='{range .items[*]}{.metadata.namespace}{"\t"}{.metadata.name}{"\t"}{.status.notAfter}{"\n"}{end}'

# 输出
istio-system    istio-ca    2026-10-19T00:00:00Z
linkerd         linkerd-identity-issuer    2026-10-19T00:00:00Z

# Grafana Dashboard查询
cert_manager_certificate_expiration_timestamp_seconds{namespace="istio-system"}
```

---

## 7. 供应链安全

### 7.1 镜像签名验证

#### 7.1.1 Sigstore/Cosign

```bash
# 安装Cosign
wget https://github.com/sigstore/cosign/releases/download/v2.2.0/cosign-linux-amd64
chmod +x cosign-linux-amd64
mv cosign-linux-amd64 /usr/local/bin/cosign

# 生成密钥对
cosign generate-key-pair

# 签名容器镜像
cosign sign --key cosign.key myregistry.com/myapp:v1.0

# 验证镜像签名
cosign verify --key cosign.pub myregistry.com/myapp:v1.0

# 输出
Verification for myregistry.com/myapp:v1.0 --
The following checks were performed on each of these signatures:
  - The cosign claims were validated
  - The signatures were verified against the specified public key
```

#### 7.1.2 Kubernetes镜像策略

```yaml
# 使用OPA Gatekeeper强制镜像签名
apiVersion: templates.gatekeeper.sh/v1beta1
kind: ConstraintTemplate
metadata:
  name: k8srequirecosignsignature
spec:
  crd:
    spec:
      names:
        kind: K8sRequireCosignSignature
  targets:
  - target: admission.k8s.gatekeeper.sh
    rego: |
      package k8srequirecosignsignature
      violation[{"msg": msg}] {
        container := input.review.object.spec.containers[_]
        not is_signed(container.image)
        msg := sprintf("Image %v is not signed", [container.image])
      }
      is_signed(image) {
        # 调用外部验证服务
        # 实际实现需要集成cosign验证
      }
---
# 应用约束
apiVersion: constraints.gatekeeper.sh/v1beta1
kind: K8sRequireCosignSignature
metadata:
  name: require-cosign-signature
spec:
  match:
    kinds:
    - apiGroups: [""]
      kinds: ["Pod"]
    namespaces:
    - "prod"
```

### 7.2 SBOM管理

```yaml
软件物料清单 (Software Bill of Materials):

1. SBOM生成:
   工具:
     - Syft: 容器镜像SBOM生成
     - Trivy: 漏洞扫描+SBOM
     - Grype: SBOM漏洞分析

   示例:
     # 使用Syft生成SBOM
     syft myregistry.com/myapp:v1.0 -o json > sbom.json
     
     # 使用Trivy生成SBOM
     trivy image --format cyclonedx myregistry.com/myapp:v1.0 > sbom-cyclonedx.json

2. SBOM存储:
   - OCI Registry: 与镜像一起存储
   - 依赖追踪系统: Dependency-Track
   - 版本控制: Git

3. SBOM验证:
   - 验证完整性
   - 检查已知漏洞
   - 许可证合规

4. SBOM监控:
   - 持续监控新漏洞
   - 自动告警
   - 影响分析
```

### 7.3 漏洞扫描

```yaml
# Trivy扫描Job
apiVersion: batch/v1
kind: CronJob
metadata:
  name: trivy-scan
  namespace: security
spec:
  schedule: "0 2 * * *"  # 每天凌晨2点
  jobTemplate:
    spec:
      template:
        spec:
          containers:
          - name: trivy
            image: aquasec/trivy:latest
            command:
            - sh
            - -c
            - |
              trivy image --severity HIGH,CRITICAL \
                --format json \
                --output /reports/scan-$(date +%Y%m%d).json \
                myregistry.com/myapp:latest
              
              # 如果发现严重漏洞，发送告警
              CRITICAL_COUNT=$(cat /reports/scan-$(date +%Y%m%d).json | jq '.Results[].Vulnerabilities | map(select(.Severity=="CRITICAL")) | length')
              if [ "$CRITICAL_COUNT" -gt 0 ]; then
                # 发送Slack/Email告警
                echo "Found $CRITICAL_COUNT critical vulnerabilities!"
              fi
            volumeMounts:
            - name: reports
              mountPath: /reports
          volumes:
          - name: reports
            persistentVolumeClaim:
              claimName: scan-reports
          restartPolicy: OnFailure
```

### 7.4 供应链最佳实践

```yaml
供应链安全最佳实践:

1. 镜像安全:
   ✅ 使用最小化基础镜像 (distroless, alpine)
   ✅ 多阶段构建，减少攻击面
   ✅ 不使用latest标签
   ✅ 签名所有镜像
   ✅ 验证镜像签名

2. 依赖管理:
   ✅ 锁定依赖版本
   ✅ 定期更新依赖
   ✅ 扫描依赖漏洞
   ✅ 使用私有Registry镜像

3. 构建安全:
   ✅ 使用可重现构建
   ✅ 签名构建产物
   ✅ 审计构建日志
   ✅ 隔离构建环境

4. 运行时安全:
   ✅ 只运行签名验证的镜像
   ✅ 使用准入控制器
   ✅ 最小权限运行
   ✅ 只读文件系统

5. 合规性:
   ✅ 维护SBOM
   ✅ 许可证合规
   ✅ 审计追踪
   ✅ 定期审计
```

---

## 8. 审计与合规

### 8.1 审计日志

#### 8.1.1 Kubernetes审计

```yaml
# Kubernetes审计策略
apiVersion: audit.k8s.io/v1
kind: Policy
rules:
# 记录所有安全相关资源
- level: RequestResponse
  verbs: ["create", "update", "patch", "delete"]
  resources:
  - group: "security.istio.io"
  - group: "policy.linkerd.io"
  - group: ""
    resources: ["secrets", "serviceaccounts"]

# 记录AuthorizationPolicy变更
- level: RequestResponse
  verbs: ["create", "update", "patch", "delete"]
  resources:
  - group: "security.istio.io"
    resources: ["authorizationpolicies"]

# 记录证书操作
- level: RequestResponse
  verbs: ["create", "update", "patch", "delete"]
  resources:
  - group: "cert-manager.io"
    resources: ["certificates"]
```

#### 8.1.2 Istio访问日志

```yaml
# 启用访问日志（包含安全信息）
apiVersion: telemetry.istio.io/v1alpha1
kind: Telemetry
metadata:
  name: access-logging
  namespace: istio-system
spec:
  accessLogging:
  - providers:
    - name: envoy
    filter:
      expression: "true"  # 记录所有请求
```

```bash
# 查看包含认证信息的访问日志
kubectl logs -n istio-system -l app=istiod --tail=100 | grep "principal"

# 输出示例
[2025-10-19T10:00:00.000Z] "GET /api/users HTTP/1.1" 200 - via_upstream - "-" 0 156 2 1 "-" "curl/7.68.0" "abc-123" "api.default.svc.cluster.local:8080" "10.1.0.5:8080" inbound|8080|| 127.0.0.6:45678 10.1.0.5:8080 10.1.0.4:54321 - default
principal="cluster.local/ns/default/sa/frontend"
```

### 8.2 合规标准

```yaml
合规标准对照:

1. PCI DSS (支付卡行业数据安全标准):
   要求: 传输中的持卡人数据加密
   实现: ✅ mTLS自动加密所有流量
   
   要求: 访问控制
   实现: ✅ AuthorizationPolicy细粒度控制
   
   要求: 审计日志
   实现: ✅ 完整的访问日志和审计跟踪

2. HIPAA (健康保险流通与责任法案):
   要求: 数据传输加密
   实现: ✅ mTLS端到端加密
   
   要求: 访问控制和审计
   实现: ✅ RBAC + 审计日志
   
   要求: 身份验证
   实现: ✅ SPIFFE身份 + JWT

3. GDPR (通用数据保护条例):
   要求: 数据保护
   实现: ✅ 加密传输 + 访问控制
   
   要求: 数据访问审计
   实现: ✅ 完整审计日志
   
   要求: 数据最小化
   实现: ✅ 最小权限原则

4. SOC 2:
   要求: 安全性
   实现: ✅ mTLS + 零信任架构
   
   要求: 可用性
   实现: ✅ 服务网格高可用
   
   要求: 机密性
   实现: ✅ 加密 + 访问控制
   
   要求: 处理完整性
   实现: ✅ mTLS保证数据完整性
   
   要求: 隐私
   实现: ✅ 细粒度授权

5. ISO 27001:
   要求: 信息安全管理
   实现: ✅ 统一策略管理
   
   要求: 访问控制
   实现: ✅ RBAC/ABAC
   
   要求: 密码学控制
   实现: ✅ mTLS + PKI
```

### 8.3 安全审计实践

```yaml
安全审计清单:

日常审计:
  □ 检查mTLS状态
  □ 审查访问日志异常
  □ 监控证书过期
  □ 检查授权策略变更

周度审计:
  □ 审查新增/修改的AuthorizationPolicy
  □ 检查异常流量模式
  □ 审计ServiceAccount权限
  □ 检查未使用的权限

月度审计:
  □ 全面安全评估
  □ 漏洞扫描
  □ 渗透测试
  □ 合规性检查
  □ 策略有效性审查

季度审计:
  □ 红队演练
  □ 第三方安全审计
  □ 灾难恢复演练
  □ 更新安全策略
```

---

## 9. 安全实战案例

### 9.1 金融级零信任架构

```yaml
# 金融级零信任完整架构

# 第1层：网络隔离
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: payment-netpol
  namespace: payment
spec:
  podSelector:
    matchLabels:
      app: payment-service
  policyTypes:
  - Ingress
  - Egress
  ingress:
  - from:
    - namespaceSelector:
        matchLabels:
          name: api-gateway
    ports:
    - protocol: TCP
      port: 8080
  egress:
  - to:
    - namespaceSelector:
        matchLabels:
          name: database
    ports:
    - protocol: TCP
      port: 5432
---
# 第2层：严格mTLS
apiVersion: security.istio.io/v1beta1
kind: PeerAuthentication
metadata:
  name: strict-mtls
  namespace: payment
spec:
  mtls:
    mode: STRICT
---
# 第3层：默认拒绝
apiVersion: security.istio.io/v1beta1
kind: AuthorizationPolicy
metadata:
  name: deny-all
  namespace: payment
spec:
  {}
---
# 第4层：服务身份授权
apiVersion: security.istio.io/v1beta1
kind: AuthorizationPolicy
metadata:
  name: allow-api-gateway
  namespace: payment
spec:
  selector:
    matchLabels:
      app: payment-service
  action: ALLOW
  rules:
  - from:
    - source:
        principals:
        - "cluster.local/ns/api-gateway/sa/api-gateway"
    to:
    - operation:
        methods: ["POST"]
        paths: ["/api/payment/process"]
---
# 第5层：终端用户JWT验证
apiVersion: security.istio.io/v1beta1
kind: RequestAuthentication
metadata:
  name: jwt-auth
  namespace: payment
spec:
  selector:
    matchLabels:
      app: payment-service
  jwtRules:
  - issuer: "https://bank-auth.example.com"
    jwksUri: "https://bank-auth.example.com/.well-known/jwks.json"
    audiences:
    - "payment-api"
---
# 第6层：基于Claims的授权
apiVersion: security.istio.io/v1beta1
kind: AuthorizationPolicy
metadata:
  name: jwt-claims-authz
  namespace: payment
spec:
  selector:
    matchLabels:
      app: payment-service
  action: ALLOW
  rules:
  # 只允许已认证的银行员工
  - when:
    - key: request.auth.claims[department]
      values: ["banking"]
    - key: request.auth.claims[clearance_level]
      values: ["L3", "L4", "L5"]
    - key: request.auth.claims[mfa_verified]
      values: ["true"]
---
# 第7层：审计日志
apiVersion: telemetry.istio.io/v1alpha1
kind: Telemetry
metadata:
  name: audit-logging
  namespace: payment
spec:
  accessLogging:
  - providers:
    - name: envoy
```

### 9.2 多租户隔离

```yaml
# 多租户完全隔离架构

# 租户A的Namespace
apiVersion: v1
kind: Namespace
metadata:
  name: tenant-a
  labels:
    tenant: tenant-a
    istio-injection: enabled
---
# 租户B的Namespace
apiVersion: v1
kind: Namespace
metadata:
  name: tenant-b
  labels:
    tenant: tenant-b
    istio-injection: enabled
---
# 租户A的mTLS
apiVersion: security.istio.io/v1beta1
kind: PeerAuthentication
metadata:
  name: tenant-a-mtls
  namespace: tenant-a
spec:
  mtls:
    mode: STRICT
---
# 租户A的默认拒绝
apiVersion: security.istio.io/v1beta1
kind: AuthorizationPolicy
metadata:
  name: deny-all
  namespace: tenant-a
spec:
  {}
---
# 租户A内部允许
apiVersion: security.istio.io/v1beta1
kind: AuthorizationPolicy
metadata:
  name: allow-tenant-a-internal
  namespace: tenant-a
spec:
  action: ALLOW
  rules:
  - from:
    - source:
        namespaces: ["tenant-a"]
---
# 租户A的网络策略（额外隔离）
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: tenant-a-isolation
  namespace: tenant-a
spec:
  podSelector: {}
  policyTypes:
  - Ingress
  - Egress
  ingress:
  # 只允许同namespace和ingress
  - from:
    - namespaceSelector:
        matchLabels:
          tenant: tenant-a
  - from:
    - namespaceSelector:
        matchLabels:
          name: ingress
  egress:
  # 只允许到同namespace、DNS和外部
  - to:
    - namespaceSelector:
        matchLabels:
          tenant: tenant-a
  - to:
    - namespaceSelector:
        matchLabels:
          name: kube-system
    podSelector:
      matchLabels:
        k8s-app: kube-dns
  - to:
    - namespaceSelector: {}
    podSelector: {}
    ports:
    - protocol: TCP
      port: 443
---
# 跨租户访问（特殊场景）
apiVersion: security.istio.io/v1beta1
kind: AuthorizationPolicy
metadata:
  name: allow-cross-tenant-api
  namespace: tenant-b
spec:
  selector:
    matchLabels:
      app: shared-api
  action: ALLOW
  rules:
  - from:
    - source:
        namespaces: ["tenant-a"]
        principals: ["cluster.local/ns/tenant-a/sa/approved-service"]
    to:
    - operation:
        methods: ["GET"]
        paths: ["/api/shared/*"]
```

### 9.3 东西向流量加密

```bash
# 验证东西向流量全部加密

# 1. 检查所有服务的mTLS状态
istioctl authn tls-check $(kubectl get pods -n default -o jsonpath='{.items[0].metadata.name}').default

# 输出应该全部显示 mTLS
HOST:PORT                          STATUS     SERVER     CLIENT     AUTHN POLICY
service-a.default.svc.cluster.local:8080  OK      mTLS       mTLS       default/
service-b.default.svc.cluster.local:8080  OK      mTLS       mTLS       default/
service-c.default.svc.cluster.local:8080  OK      mTLS       mTLS       default/

# 2. 抓包验证加密
kubectl exec -it <pod-name> -c istio-proxy -- tcpdump -i any -A 'tcp port 8080'

# 应该看到加密的二进制数据，而不是明文

# 3. 监控mTLS使用率
kubectl exec -it <pod-name> -c istio-proxy -- \
  curl localhost:15000/stats/prometheus | grep "ssl_handshake"

# 4. Prometheus查询mTLS覆盖率
sum(istio_requests_total{connection_security_policy="mutual_tls"}) 
/ 
sum(istio_requests_total) * 100

# 应该接近100%
```

---

## 10. 安全最佳实践

```yaml
服务网格安全最佳实践:

部署阶段:
  1. 启用严格mTLS
     ✅ 全局STRICT模式
     ✅ 拒绝明文连接
     ✅ 验证mTLS覆盖率

  2. 实施零信任架构
     ✅ 默认拒绝所有
     ✅ 显式授权
     ✅ 最小权限

  3. 集成PKI
     ✅ 使用cert-manager
     ✅ 自动证书轮换
     ✅ 监控证书过期

  4. 启用审计日志
     ✅ 记录所有访问
     ✅ 包含身份信息
     ✅ 集中存储

运维阶段:
  5. 持续监控
     ✅ mTLS状态
     ✅ 授权策略生效
     ✅ 证书健康
     ✅ 异常流量

  6. 定期审计
     ✅ 审查授权策略
     ✅ 检查未使用权限
     ✅ 漏洞扫描
     ✅ 渗透测试

  7. 版本管理
     ✅ 跟踪CVE
     ✅ 及时升级
     ✅ 测试后推广

  8. 灾难恢复
     ✅ 备份证书
     ✅ 备份配置
     ✅ 定期演练

合规阶段:
  9. 符合标准
     ✅ PCI DSS
     ✅ HIPAA
     ✅ GDPR
     ✅ SOC 2

  10. 文档化
      ✅ 架构图
      ✅ 安全策略
      ✅ 运维手册
      ✅ 审计报告
```

---

## 11. 总结

### 11.1 服务网格安全核心价值

```yaml
服务网格安全价值:

1. 透明加密:
   ✅ 自动mTLS
   ✅ 零代码修改
   ✅ 东西向流量加密
   ✅ 100%覆盖率

2. 强身份:
   ✅ SPIFFE标准
   ✅ 自动证书管理
   ✅ 短期证书
   ✅ 自动轮换

3. 细粒度授权:
   ✅ 服务级别
   ✅ 方法级别
   ✅ 路径级别
   ✅ Claims级别

4. 可观测性:
   ✅ 完整审计日志
   ✅ 流量可视化
   ✅ 安全指标
   ✅ 异常检测

5. 合规性:
   ✅ 满足监管要求
   ✅ 审计追踪
   ✅ 加密证明
   ✅ 访问控制
```

### 11.2 Istio vs Linkerd安全对比

```yaml
Istio安全:
  优势:
    ✅ 功能最全面
    ✅ JWT/OAuth2支持
    ✅ 外部授权 (OPA)
    ✅ 复杂策略支持
  
  适用:
    - 复杂安全需求
    - 多种认证方式
    - 细粒度授权

Linkerd安全:
  优势:
    ✅ 默认安全
    ✅ 零配置mTLS
    ✅ 最简单易用
    ✅ 高性能
  
  适用:
    - 简单安全需求
    - 追求性能
    - 快速上手

共同点:
  ✅ SPIFFE标准
  ✅ 自动mTLS
  ✅ 证书管理
  ✅ 零信任架构
```

### 11.3 未来展望

```yaml
服务网格安全趋势:

1. 零信任成为标准:
   - 默认拒绝
   - 持续验证
   - 微分段

2. AI/ML安全:
   - 异常检测
   - 自动响应
   - 威胁预测

3. 供应链安全:
   - SBOM标准化
   - 签名验证强制
   - 漏洞自动修复

4. 跨云安全:
   - 统一身份
   - 跨云授权
   - 联邦信任

5. 量子安全:
   - 后量子密码
   - 量子密钥分发
   - 密码敏捷性
```

---

**本章完成！** ✅

**下一章预告**: [05_流量管理与灰度发布](./05_流量管理与灰度发布.md)

**相关章节**:

- [02_Istio深度解析](./02_Istio深度解析.md)
- [03_Linkerd轻量级服务网格](./03_Linkerd轻量级服务网格.md)

---

**文档版本**: v1.0  
**最后更新**: 2025-10-19  
**作者**: vSphere & Container Technology Team  
**字数**: 约15,000字  
**代码示例**: 40+个
