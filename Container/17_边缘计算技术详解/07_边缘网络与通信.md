# 07_边缘网络与通信

## 目录

---

## 边缘网络概述

### 边缘网络特点

```yaml
核心需求:
  低延迟:
    - 工业控制: <1ms
    - AR/VR: <10ms
    - 自动驾驶: <5ms
    - 远程医疗: <20ms
  
  高可靠:
    - 5个9可用性 (99.999%)
    - 丢包率 <0.01%
    - 故障切换 <50ms
  
  大带宽:
    - 4K视频: 25Mbps
    - 8K视频: 100Mbps
    - 工业数据: 1Gbps+
  
  海量连接:
    - IoT设备: 百万级
    - 并发连接: 十万级
```

### 网络架构

```yaml
三层架构:
  边缘接入层:
    - WiFi 6/6E (802.11ax)
    - 5G NR (Sub-6/mmWave)
    - 工业以太网 (TSN)
    - LoRaWAN / NB-IoT
  
  边缘汇聚层:
    - SD-WAN聚合
    - 边缘路由器
    - 负载均衡
    - QoS调度
  
  云端核心层:
    - 核心网关
    - 多云互联
    - 全球骨干网
```

### 关键技术

```yaml
网络技术:
  - TSN (时间敏感网络)
  - eBPF (内核级网络优化)
  - SD-WAN (软件定义广域网)
  - IPv6/SRv6 (段路由)
  - MPLS-TE (流量工程)

通信协议:
  - MQTT (轻量级消息)
  - CoAP (受约束应用)
  - OPC-UA (工业标准)
  - DDS (数据分发服务)
  - WebRTC (实时通信)

5G技术:
  - URLLC (超低延迟)
  - 网络切片
  - MEC (移动边缘计算)
  - 5G LAN
```

---

## 时间敏感网络TSN

### TSN标准

```yaml
IEEE 802.1 系列:
  核心标准:
    - 802.1AS: 时间同步 (gPTP)
    - 802.1Qbv: 时间感知调度 (TAS)
    - 802.1Qbu: 帧抢占
    - 802.1Qcc: 流预留协议 (SRP)
    - 802.1CB: 帧复制与消除
    - 802.1Qci: 每流过滤与监管

时间同步精度:
  - 工业控制: <1μs
  - 音视频: <10μs
  - 一般应用: <100μs
```

### 时间感知调度 (TAS)

```yaml
原理:
  1. 将时间划分为固定周期 (Cycle)
  2. 每个周期划分为多个时间窗口 (Time Slot)
  3. 不同优先级流量分配到不同窗口
  4. 保证高优先级流量确定性延迟

示例:
  Cycle = 1ms
  Slot 1 (0-200μs): 关键控制流量 (Priority 7)
  Slot 2 (200-500μs): 实时数据 (Priority 5)
  Slot 3 (500-1000μs): 尽力而为流量 (Priority 0)
```

#### TSN配置示例

```bash
# Linux TSN配置 (tc命令)

# 1. 安装taprio qdisc (时间感知调度)
tc qdisc add dev eth0 parent root handle 100 taprio \
  num_tc 3 \
  map 0 0 1 1 2 2 2 2 2 2 2 2 2 2 2 2 \
  queues 1@0 1@1 1@2 \
  base-time 1000000000 \
  sched-entry S 01 200000 \
  sched-entry S 02 300000 \
  sched-entry S 04 500000 \
  clockid CLOCK_TAI

# 参数说明:
# - num_tc 3: 3个流量类别
# - map: VLAN PCP到TC的映射
# - queues: 每个TC的队列分配
# - base-time: 调度起始时间 (TAI纳秒)
# - sched-entry: 调度条目 (S=开放的gate, 时长ns)
# - clockid: 时钟源 (TAI = International Atomic Time)

# 2. 配置时间同步 (linuxptp)
# /etc/linuxptp/ptp4l.conf
cat > /etc/linuxptp/ptp4l.conf << EOF
[global]
tx_timestamp_timeout 10
logMinDelayReqInterval -3
logSyncInterval -3
twoStepFlag 1
summary_interval 0

[eth0]
network_transport L2
delay_mechanism E2E
EOF

# 启动PTP守护进程
ptp4l -i eth0 -f /etc/linuxptp/ptp4l.conf -m

# 同步系统时钟到PTP
phc2sys -s eth0 -c CLOCK_REALTIME -O 0 -m

# 3. 验证时间同步
pmc -u -b 0 'GET TIME_STATUS_NP'
pmc -u -b 0 'GET CURRENT_DATA_SET'
```

#### TSN Python控制

```python
# tsn_controller.py
import socket
import struct
import time
from ctypes import *

class TSNController:
    """TSN网络控制器"""
    
    def __init__(self, interface='eth0'):
        self.interface = interface
        self.base_time = self._get_tai_time()
        self.cycle_time_ns = 1_000_000  # 1ms周期
    
    def _get_tai_time(self):
        """获取TAI时间 (纳秒)"""
        # TAI = UTC + 37秒 (2025年闰秒数)
        utc_ns = time.time_ns()
        tai_ns = utc_ns + 37_000_000_000
        return tai_ns
    
    def configure_tas(self, schedule):
        """
        配置时间感知调度
        
        schedule = [
            {'gate': 0b001, 'duration_ns': 200000},  # 只开放Queue 0
            {'gate': 0b010, 'duration_ns': 300000},  # 只开放Queue 1
            {'gate': 0b100, 'duration_ns': 500000},  # 只开放Queue 2
        ]
        """
        import subprocess
        
        # 构建tc命令
        cmd = f"tc qdisc add dev {self.interface} parent root handle 100 taprio"
        cmd += f" num_tc {len(schedule)}"
        cmd += " map " + " ".join(["0"] * 16)
        cmd += f" queues " + " ".join([f"1@{i}" for i in range(len(schedule))])
        cmd += f" base-time {self.base_time}"
        
        for entry in schedule:
            gate_mask = entry['gate']
            duration = entry['duration_ns']
            cmd += f" sched-entry S {gate_mask:02X} {duration}"
        
        cmd += " clockid CLOCK_TAI"
        
        # 执行配置
        subprocess.run(cmd, shell=True, check=True)
        print(f"TSN TAS configured on {self.interface}")
    
    def send_tsn_packet(self, data, priority=7, dst_mac='ff:ff:ff:ff:ff:ff'):
        """发送TSN高优先级数据包"""
        # 创建原始套接字
        sock = socket.socket(socket.AF_PACKET, socket.SOCK_RAW, socket.IPPROTO_RAW)
        sock.bind((self.interface, 0))
        
        # 构造以太网帧
        dst = bytes.fromhex(dst_mac.replace(':', ''))
        src = bytes.fromhex('aa:bb:cc:dd:ee:ff')  # 源MAC
        
        # VLAN标签 (802.1Q)
        vlan_tpid = b'\x81\x00'  # 802.1Q TPID
        vlan_tci = struct.pack('!H', (priority << 13) | 0x001)  # PCP + VLAN ID
        
        # 以太网类型
        eth_type = b'\x08\x00'  # IPv4
        
        # 组装帧
        frame = dst + src + vlan_tpid + vlan_tci + eth_type + data
        
        # 发送
        sock.send(frame)
        sock.close()
        
        print(f"Sent TSN packet (Priority {priority})")
    
    def monitor_tsn_stats(self, duration=10):
        """监控TSN统计信息"""
        import subprocess
        
        print(f"Monitoring {self.interface} for {duration}s...")
        
        # 获取初始统计
        result = subprocess.run(
            f"tc -s qdisc show dev {self.interface}",
            shell=True,
            capture_output=True,
            text=True
        )
        print(result.stdout)
        
        time.sleep(duration)
        
        # 获取最终统计
        result = subprocess.run(
            f"tc -s qdisc show dev {self.interface}",
            shell=True,
            capture_output=True,
            text=True
        )
        print(result.stdout)

# 使用示例
if __name__ == '__main__':
    tsn = TSNController('eth0')
    
    # 配置调度
    schedule = [
        {'gate': 0b001, 'duration_ns': 200_000},   # 200μs - 关键控制
        {'gate': 0b010, 'duration_ns': 300_000},   # 300μs - 实时数据
        {'gate': 0b100, 'duration_ns': 500_000},   # 500μs - 尽力而为
    ]
    tsn.configure_tas(schedule)
    
    # 发送高优先级数据
    tsn.send_tsn_packet(b'Critical Control Data', priority=7)
    
    # 监控统计
    tsn.monitor_tsn_stats(duration=10)
```

### TSN与OT集成

```yaml
工业以太网集成:
  EtherCAT + TSN:
    - EtherCAT over TSN
    - 周期时间: <1ms
    - 抖动: <1μs
  
  PROFINET + TSN:
    - IRT (等时实时)
    - 循环时间: 31.25μs - 4ms
    - TSN增强确定性
  
  Ethernet/IP + TSN:
    - CIP Motion over TSN
    - 实时运动控制
    - <100μs延迟

架构示例:
  [PLC] --TSN-- [TSN Switch] --TSN-- [Drive]
          |                     |
      [Sensor]              [HMI]
  
  - 控制流量: Priority 7 (最高)
  - 状态数据: Priority 5
  - HMI流量: Priority 3
  - 网络管理: Priority 0
```

---

## eBPF网络技术

### eBPF概述

```yaml
什么是eBPF:
  - Extended Berkeley Packet Filter
  - 内核级可编程数据平面
  - 无需修改内核代码
  - JIT编译 (Just-In-Time)
  - 验证器保证安全性

优势:
  - 极低延迟 (内核空间处理)
  - 高性能 (零拷贝)
  - 灵活性 (动态加载卸载)
  - 安全性 (验证器)
  - 可观测性 (详细追踪)

应用场景:
  - 网络加速 (XDP)
  - 负载均衡
  - 安全过滤
  - 可观测性 (追踪/监控)
  - 容器网络 (Cilium)
```

### XDP (eXpress Data Path)

```yaml
XDP处理流程:
  1. 网卡驱动接收数据包
  2. 立即触发XDP程序 (在skb分配前)
  3. XDP程序决策:
     - XDP_PASS: 继续正常处理
     - XDP_DROP: 丢弃数据包
     - XDP_TX: 原路返回
     - XDP_REDIRECT: 重定向到其他接口
  4. 高性能转发 (跳过内核网络栈)

性能:
  - 处理延迟: <50μs
  - 吞吐量: 24Mpps+ (10Gbps网卡)
  - vs iptables: 10-100x faster
  - vs kernel: 零拷贝
```

#### XDP程序示例

```c
// xdp_filter.c
#include <linux/bpf.h>
#include <linux/if_ether.h>
#include <linux/ip.h>
#include <linux/tcp.h>
#include <bpf/bpf_helpers.h>

// XDP防火墙: 阻止特定IP和端口

SEC("xdp_firewall")
int xdp_filter_func(struct xdp_md *ctx)
{
    void *data_end = (void *)(long)ctx->data_end;
    void *data = (void *)(long)ctx->data;
    
    // 解析以太网头
    struct ethhdr *eth = data;
    if ((void *)(eth + 1) > data_end)
        return XDP_PASS;
    
    // 检查是否为IP包
    if (eth->h_proto != __constant_htons(ETH_P_IP))
        return XDP_PASS;
    
    // 解析IP头
    struct iphdr *ip = (void *)(eth + 1);
    if ((void *)(ip + 1) > data_end)
        return XDP_PASS;
    
    // 阻止来自 192.168.1.100 的流量
    __u32 blocked_ip = 0xC0A80164;  // 192.168.1.100
    if (ip->saddr == __constant_htonl(blocked_ip))
        return XDP_DROP;
    
    // 检查TCP端口
    if (ip->protocol == IPPROTO_TCP) {
        struct tcphdr *tcp = (void *)ip + (ip->ihl * 4);
        if ((void *)(tcp + 1) > data_end)
            return XDP_PASS;
        
        // 阻止目标端口 22 (SSH)
        if (tcp->dest == __constant_htons(22))
            return XDP_DROP;
    }
    
    return XDP_PASS;
}

char _license[] SEC("license") = "GPL";
```

#### 编译和加载XDP

```bash
# 编译XDP程序
clang -O2 -target bpf -c xdp_filter.c -o xdp_filter.o

# 加载到网卡
ip link set dev eth0 xdp obj xdp_filter.o sec xdp_firewall

# 查看加载状态
ip link show dev eth0

# 卸载XDP程序
ip link set dev eth0 xdp off

# 使用bpftool查看
bpftool prog show
bpftool prog dump xlated id <prog_id>
```

#### Python加载XDP (使用bcc)

```python
# xdp_loader.py
from bcc import BPF

# XDP程序 (嵌入Python字符串)
xdp_code = """
#include <linux/bpf.h>
#include <linux/if_ether.h>
#include <linux/ip.h>

BPF_ARRAY(rxcnt, u64, 256);

int xdp_stats(struct xdp_md *ctx)
{
    void *data_end = (void *)(long)ctx->data_end;
    void *data = (void *)(long)ctx->data;
    
    struct ethhdr *eth = data;
    if ((void *)(eth + 1) > data_end)
        return XDP_PASS;
    
    u64 nh_off = sizeof(*eth);
    struct iphdr *ip = data + nh_off;
    if ((void *)(ip + 1) > data_end)
        return XDP_PASS;
    
    // 统计每个协议的包数
    u32 key = ip->protocol;
    u64 *value = rxcnt.lookup(&key);
    if (value) {
        *value += 1;
    }
    
    return XDP_PASS;
}
"""

# 加载XDP程序
b = BPF(text=xdp_code, cflags=["-w"])
fn = b.load_func("xdp_stats", BPF.XDP)

# 附加到网卡
device = "eth0"
b.attach_xdp(device, fn, 0)

print(f"XDP program loaded on {device}")
print("Collecting stats... Press Ctrl+C to exit")

try:
    rxcnt = b["rxcnt"]
    protocol_names = {
        1: "ICMP",
        6: "TCP",
        17: "UDP",
        58: "ICMPv6"
    }
    
    while True:
        import time
        time.sleep(1)
        
        print("\n=== Protocol Statistics ===")
        for k, v in rxcnt.items():
            protocol = k.value
            count = v.value
            if count > 0:
                name = protocol_names.get(protocol, f"Protocol-{protocol}")
                print(f"{name}: {count} packets")

except KeyboardInterrupt:
    print("\nRemoving XDP program...")

finally:
    b.remove_xdp(device, 0)
    print("XDP program removed")
```

### Cilium容器网络

```yaml
Cilium特点:
  - 基于eBPF的CNI插件
  - 替代iptables (更高性能)
  - L3-L7安全策略
  - 服务网格加速
  - 可观测性 (Hubble)

性能优势:
  - vs kube-proxy: 3-5x latency reduction
  - vs Calico: 2x throughput
  - 网络策略: 10x faster enforcement

架构:
  Cilium Agent (每节点)
    ↓
  eBPF程序 (内核)
    ↓
  网卡 (XDP可选)
```

#### Cilium安装

```bash
# Kubernetes集群安装Cilium

# 1. 添加Helm仓库
helm repo add cilium https://helm.cilium.io/
helm repo update

# 2. 安装Cilium
helm install cilium cilium/cilium \
  --version 1.14.5 \
  --namespace kube-system \
  --set kubeProxyReplacement=strict \
  --set k8sServiceHost=<K8S_API_SERVER> \
  --set k8sServicePort=6443 \
  --set hubble.enabled=true \
  --set hubble.relay.enabled=true \
  --set hubble.ui.enabled=true

# 3. 验证安装
cilium status --wait

# 4. 启用Hubble可观测性
cilium hubble enable --ui

# 5. 端口转发Hubble UI
kubectl port-forward -n kube-system svc/hubble-ui 12000:80

# 访问 http://localhost:12000
```

#### Cilium网络策略

```yaml
# cilium-network-policy.yaml
apiVersion: cilium.io/v2
kind: CiliumNetworkPolicy
metadata:
  name: allow-frontend-to-backend
  namespace: default
spec:
  endpointSelector:
    matchLabels:
      app: backend
  
  ingress:
  - fromEndpoints:
    - matchLabels:
        app: frontend
    toPorts:
    - ports:
      - port: "8080"
        protocol: TCP
      rules:
        http:
        - method: GET
          path: /api/.*
        - method: POST
          path: /api/create

  egress:
  - toEndpoints:
    - matchLabels:
        app: database
    toPorts:
    - ports:
      - port: "5432"
        protocol: TCP

  - toFQDNs:
    - matchName: "api.example.com"
    toPorts:
    - ports:
      - port: "443"
        protocol: TCP

---
# L7负载均衡
apiVersion: cilium.io/v2
kind: CiliumNetworkPolicy
metadata:
  name: http-loadbalancer
spec:
  endpointSelector:
    matchLabels:
      app: web
  
  ingress:
  - fromEntities:
    - world
    toPorts:
    - ports:
      - port: "80"
        protocol: TCP
      rules:
        http:
        - method: GET
          path: /
        - method: POST
          path: /api/.*
      
      # HTTP负载均衡
      originatingTLS:
        certificate: "tls-secret"
        privateKey: "tls-secret"
```

```bash
# 应用策略
kubectl apply -f cilium-network-policy.yaml

# 查看策略
cilium policy get

# 实时观察流量 (Hubble)
hubble observe --pod default/frontend

# 查看策略决策
hubble observe --verdict DROPPED
hubble observe --verdict FORWARDED
```

### eBPF可观测性

```python
# ebpf_tcp_monitor.py
from bcc import BPF

# 监控TCP连接
bpf_code = """
#include <uapi/linux/ptrace.h>
#include <net/sock.h>
#include <bcc/proto.h>

BPF_HASH(currsock, u32, struct sock *);

struct tcp_event_t {
    u32 pid;
    char comm[16];
    u32 saddr;
    u32 daddr;
    u16 sport;
    u16 dport;
    u64 bytes;
};
BPF_PERF_OUTPUT(tcp_events);

int trace_tcp_connect(struct pt_regs *ctx, struct sock *sk)
{
    u32 pid = bpf_get_current_pid_tgid() >> 32;
    
    // 保存socket
    currsock.update(&pid, &sk);
    
    return 0;
}

int trace_tcp_connect_return(struct pt_regs *ctx)
{
    int ret = PT_REGS_RC(ctx);
    u32 pid = bpf_get_current_pid_tgid() >> 32;
    
    struct sock **skpp = currsock.lookup(&pid);
    if (skpp == 0)
        return 0;
    
    if (ret != 0) {
        currsock.delete(&pid);
        return 0;
    }
    
    struct sock *skp = *skpp;
    
    // 提取连接信息
    struct tcp_event_t event = {};
    event.pid = pid;
    bpf_get_current_comm(&event.comm, sizeof(event.comm));
    event.saddr = skp->__sk_common.skc_rcv_saddr;
    event.daddr = skp->__sk_common.skc_daddr;
    event.sport = skp->__sk_common.skc_num;
    event.dport = skp->__sk_common.skc_dport;
    event.dport = ntohs(event.dport);
    
    tcp_events.perf_submit(ctx, &event, sizeof(event));
    
    currsock.delete(&pid);
    return 0;
}
"""

# 加载eBPF程序
b = BPF(text=bpf_code)
b.attach_kprobe(event="tcp_v4_connect", fn_name="trace_tcp_connect")
b.attach_kretprobe(event="tcp_v4_connect", fn_name="trace_tcp_connect_return")

print("Monitoring TCP connections... Press Ctrl+C to exit")

# 事件回调
def print_event(cpu, data, size):
    event = b["tcp_events"].event(data)
    import socket
    saddr = socket.inet_ntoa(event.saddr.to_bytes(4, 'little'))
    daddr = socket.inet_ntoa(event.daddr.to_bytes(4, 'little'))
    print(f"{event.pid:6d} {event.comm.decode('utf-8', 'replace'):16s} "
          f"{saddr}:{event.sport} -> {daddr}:{event.dport}")

b["tcp_events"].open_perf_buffer(print_event)

try:
    while True:
        b.perf_buffer_poll()
except KeyboardInterrupt:
    print("\nExiting...")
```

---

## 物联网通信协议

### MQTT协议

```yaml
MQTT特点:
  - 轻量级发布/订阅模式
  - 低带宽 (<1KB overhead)
  - 三种QoS级别 (0/1/2)
  - 保留消息和遗嘱消息
  - 广泛IoT支持

架构:
  [Publisher] ---> [MQTT Broker] ---> [Subscriber]
                   (Mosquitto)
  
  Topic层级:
    home/livingroom/temperature
    factory/machine1/status
    sensor/+/data  (+ 单层通配符)
    sensor/#       (# 多层通配符)
```

#### Mosquitto Broker部署

```bash
# Docker部署Mosquitto
docker run -d \
  --name mosquitto \
  -p 1883:1883 \
  -p 9001:9001 \
  -v $(pwd)/mosquitto.conf:/mosquitto/config/mosquitto.conf \
  eclipse-mosquitto

# mosquitto.conf
cat > mosquitto.conf << EOF
listener 1883
protocol mqtt

listener 9001
protocol websockets

allow_anonymous true
log_type all
EOF

# Kubernetes部署
kubectl apply -f - << EOF
apiVersion: apps/v1
kind: Deployment
metadata:
  name: mosquitto
spec:
  replicas: 1
  selector:
    matchLabels:
      app: mosquitto
  template:
    metadata:
      labels:
        app: mosquitto
    spec:
      containers:
      - name: mosquitto
        image: eclipse-mosquitto:2.0
        ports:
        - containerPort: 1883
          name: mqtt
        - containerPort: 9001
          name: websockets
        volumeMounts:
        - name: config
          mountPath: /mosquitto/config
      volumes:
      - name: config
        configMap:
          name: mosquitto-config
---
apiVersion: v1
kind: Service
metadata:
  name: mosquitto
spec:
  type: LoadBalancer
  ports:
  - port: 1883
    targetPort: 1883
    name: mqtt
  - port: 9001
    targetPort: 9001
    name: websockets
  selector:
    app: mosquitto
EOF
```

#### MQTT Python客户端

```python
# mqtt_edge_client.py
import paho.mqtt.client as mqtt
import json
import time
import random

class EdgeMQTTClient:
    """边缘MQTT客户端"""
    
    def __init__(self, broker_host='localhost', broker_port=1883):
        self.client = mqtt.Client(client_id=f"edge_client_{random.randint(0,1000)}")
        self.broker_host = broker_host
        self.broker_port = broker_port
        
        # 回调函数
        self.client.on_connect = self.on_connect
        self.client.on_message = self.on_message
        self.client.on_disconnect = self.on_disconnect
        
        self.connected = False
    
    def on_connect(self, client, userdata, flags, rc):
        """连接回调"""
        if rc == 0:
            print(f"Connected to MQTT Broker at {self.broker_host}:{self.broker_port}")
            self.connected = True
            
            # 订阅主题
            self.client.subscribe("edge/+/command", qos=1)
            self.client.subscribe("edge/broadcast", qos=0)
        else:
            print(f"Connection failed with code {rc}")
    
    def on_message(self, client, userdata, msg):
        """消息回调"""
        topic = msg.topic
        payload = msg.payload.decode('utf-8')
        
        print(f"[{topic}] {payload}")
        
        # 处理命令
        if 'command' in topic:
            try:
                command = json.loads(payload)
                self.handle_command(command)
            except json.JSONDecodeError:
                print(f"Invalid JSON: {payload}")
    
    def on_disconnect(self, client, userdata, rc):
        """断开连接回调"""
        print(f"Disconnected with code {rc}")
        self.connected = False
    
    def connect(self):
        """连接到Broker"""
        self.client.connect(self.broker_host, self.broker_port, keepalive=60)
        self.client.loop_start()
        
        # 等待连接
        while not self.connected:
            time.sleep(0.1)
    
    def disconnect(self):
        """断开连接"""
        self.client.loop_stop()
        self.client.disconnect()
    
    def publish_sensor_data(self, sensor_id, data):
        """发布传感器数据"""
        topic = f"edge/{sensor_id}/data"
        payload = json.dumps({
            'sensor_id': sensor_id,
            'timestamp': time.time(),
            'data': data
        })
        
        # QoS 1: 至少一次送达
        self.client.publish(topic, payload, qos=1)
    
    def handle_command(self, command):
        """处理命令"""
        cmd_type = command.get('type')
        
        if cmd_type == 'reboot':
            print("Rebooting device...")
        elif cmd_type == 'update_config':
            config = command.get('config', {})
            print(f"Updating config: {config}")
        else:
            print(f"Unknown command: {cmd_type}")

# 使用示例
if __name__ == '__main__':
    client = EdgeMQTTClient('localhost', 1883)
    client.connect()
    
    try:
        # 模拟传感器数据上报
        sensor_id = 'sensor001'
        while True:
            data = {
                'temperature': random.uniform(20.0, 30.0),
                'humidity': random.uniform(40.0, 80.0),
                'pressure': random.uniform(980.0, 1020.0)
            }
            client.publish_sensor_data(sensor_id, data)
            print(f"Published: {data}")
            time.sleep(5)
    
    except KeyboardInterrupt:
        print("\nExiting...")
        client.disconnect()
```

#### MQTT性能优化

```python
# mqtt_performance.py
import paho.mqtt.client as mqtt
import time
import threading

class HighPerformanceMQTT:
    """高性能MQTT客户端"""
    
    def __init__(self, broker, port=1883, max_inflight=20, max_queued=100):
        self.client = mqtt.Client()
        
        # 性能优化配置
        self.client.max_inflight_messages_set(max_inflight)  # 并发发送消息数
        self.client.max_queued_messages_set(max_queued)      # 队列消息数
        
        # 连接参数
        self.client.connect(broker, port, keepalive=60)
        self.client.loop_start()
        
        # 统计
        self.sent_count = 0
        self.ack_count = 0
        self.lock = threading.Lock()
        
        self.client.on_publish = self.on_publish
    
    def on_publish(self, client, userdata, mid):
        """发布确认回调"""
        with self.lock:
            self.ack_count += 1
    
    def bulk_publish(self, topic, messages, qos=1):
        """批量发布"""
        start = time.time()
        
        for msg in messages:
            self.client.publish(topic, msg, qos=qos)
            self.sent_count += 1
        
        # 等待所有消息确认
        while self.ack_count < self.sent_count:
            time.sleep(0.001)
        
        elapsed = time.time() - start
        throughput = len(messages) / elapsed
        
        print(f"Published {len(messages)} messages in {elapsed:.2f}s")
        print(f"Throughput: {throughput:.0f} msg/s")
    
    def disconnect(self):
        self.client.loop_stop()
        self.client.disconnect()

# 性能测试
if __name__ == '__main__':
    mqtt_client = HighPerformanceMQTT('localhost')
    
    # 生成测试消息
    messages = [f"Message-{i}" for i in range(10000)]
    
    # 批量发布
    mqtt_client.bulk_publish('test/performance', messages, qos=1)
    
    mqtt_client.disconnect()
```

### CoAP协议

```yaml
CoAP特点:
  - 基于UDP (轻量级)
  - RESTful API (GET/POST/PUT/DELETE)
  - 二进制格式 (极小开销 ~4字节)
  - 可靠传输 (CON消息)
  - 资源发现 (/.well-known/core)
  - 观察模式 (Observe)

对比HTTP:
  - 头部: 4字节 vs 数百字节
  - 传输: UDP vs TCP
  - 适用: 受限设备 vs 通用

使用: 受限设备 vs 通用
```

#### CoAP Python客户端

```python
# coap_client.py
from aiocoap import *
import asyncio

class EdgeCoAPClient:
    """边缘CoAP客户端"""
    
    async def get_resource(self, uri):
        """GET请求"""
        protocol = await Context.create_client_context()
        
        request = Message(code=GET, uri=uri)
        
        try:
            response = await protocol.request(request).response
            print(f"Response Code: {response.code}")
            print(f"Payload: {response.payload.decode('utf-8')}")
            return response.payload
        except Exception as e:
            print(f"Error: {e}")
    
    async def post_data(self, uri, data):
        """POST请求"""
        protocol = await Context.create_client_context()
        
        request = Message(code=POST, uri=uri, payload=data.encode('utf-8'))
        request.opt.content_format = 0  # text/plain
        
        try:
            response = await protocol.request(request).response
            print(f"POST Response: {response.code}")
            return response.payload
        except Exception as e:
            print(f"Error: {e}")
    
    async def observe_resource(self, uri, callback):
        """观察资源 (Observe)"""
        protocol = await Context.create_client_context()
        
        request = Message(code=GET, uri=uri, observe=0)
        
        observation = protocol.request(request)
        
        try:
            async for response in observation.observation:
                print(f"[Observe] {response.payload.decode('utf-8')}")
                callback(response.payload)
        except Exception as e:
            print(f"Observation ended: {e}")

# 使用示例
async def main():
    client = EdgeCoAPClient()
    
    # GET请求
    await client.get_resource('coap://localhost/sensors/temperature')
    
    # POST数据
    await client.post_data('coap://localhost/actuators/led', 'ON')
    
    # 观察资源
    def on_update(payload):
        print(f"Resource updated: {payload}")
    
    await client.observe_resource('coap://localhost/sensors/temperature', on_update)

if __name__ == '__main__':
    asyncio.run(main())
```

### OPC-UA协议

```yaml
OPC-UA特点:
  - 工业标准通信协议
  - 平台无关 (跨Windows/Linux)
  - 安全性强 (X.509证书 + 加密)
  - 数据建模 (信息模型)
  - 历史数据访问
  - 订阅/发布机制

架构:
  OPC-UA Server (PLC/SCADA)
    ↓
  OPC-UA Client (边缘网关)
    ↓
  云端分析平台

数据模型:
  - 对象 (Object)
  - 变量 (Variable)
  - 方法 (Method)
  - 事件 (Event)
```

#### OPC-UA Python示例

```python
# opcua_edge_client.py
from opcua import Client, ua
import time

class EdgeOPCUAClient:
    """边缘OPC-UA客户端"""
    
    def __init__(self, server_url):
        self.client = Client(server_url)
        self.client.set_security_string("Basic256Sha256,SignAndEncrypt,certificate.pem,private_key.pem")
    
    def connect(self):
        """连接到OPC-UA服务器"""
        self.client.connect()
        print(f"Connected to {self.client.server_url}")
        
        # 获取根节点
        self.root = self.client.get_root_node()
        self.objects = self.client.get_objects_node()
    
    def disconnect(self):
        """断开连接"""
        self.client.disconnect()
        print("Disconnected")
    
    def read_variable(self, node_id):
        """读取变量"""
        node = self.client.get_node(node_id)
        value = node.get_value()
        print(f"Node {node_id}: {value}")
        return value
    
    def write_variable(self, node_id, value):
        """写入变量"""
        node = self.client.get_node(node_id)
        node.set_value(ua.DataValue(ua.Variant(value, ua.VariantType.Float)))
        print(f"Written {value} to {node_id}")
    
    def subscribe(self, node_ids, callback):
        """订阅变量变化"""
        handler = SubscriptionHandler(callback)
        subscription = self.client.create_subscription(100, handler)  # 100ms更新间隔
        
        for node_id in node_ids:
            node = self.client.get_node(node_id)
            subscription.subscribe_data_change(node)
        
        print(f"Subscribed to {len(node_ids)} nodes")
        return subscription
    
    def call_method(self, object_id, method_id, *args):
        """调用方法"""
        obj = self.client.get_node(object_id)
        method = obj.get_child(method_id)
        result = obj.call_method(method, *args)
        print(f"Method result: {result}")
        return result

class SubscriptionHandler:
    """订阅处理器"""
    
    def __init__(self, callback):
        self.callback = callback
    
    def datachange_notification(self, node, val, data):
        """数据变化通知"""
        self.callback(node, val, data)

# 使用示例
if __name__ == '__main__':
    client = EdgeOPCUAClient("opc.tcp://localhost:4840")
    client.connect()
    
    try:
        # 读取温度
        temp = client.read_variable("ns=2;i=2")
        
        # 写入设定值
        client.write_variable("ns=2;i=3", 25.5)
        
        # 订阅变化
        def on_change(node, val, data):
            print(f"[Subscribe] {node}: {val}")
        
        subscription = client.subscribe(["ns=2;i=2", "ns=2;i=4"], on_change)
        
        # 保持运行
        time.sleep(60)
    
    finally:
        client.disconnect()
```

### DDS协议

```yaml
DDS特点:
  - 数据分发服务 (Data Distribution Service)
  - 实时发布/订阅
  - QoS策略 (23种QoS策略)
  - 去中心化 (无Broker)
  - 自动发现
  - 应用: 国防、航空、自动驾驶

QoS策略:
  - RELIABILITY: 可靠性 (Reliable/Best-Effort)
  - DURABILITY: 持久性 (Volatile/Transient/Persistent)
  - DEADLINE: 截止期限
  - LATENCY_BUDGET: 延迟预算
  - HISTORY: 历史深度
```

#### DDS Python示例

```python
# dds_edge_pubsub.py
import rticonnextdds_connector as rti

class EdgeDDSPublisher:
    """边缘DDS发布者"""
    
    def __init__(self, config_file, participant_name):
        self.connector = rti.Connector(participant_name, config_file)
        self.output = self.connector.get_output("SensorPublisher::SensorWriter")
    
    def publish_sensor_data(self, sensor_id, temperature, humidity):
        """发布传感器数据"""
        self.output.instance.set_number("sensor_id", sensor_id)
        self.output.instance.set_number("temperature", temperature)
        self.output.instance.set_number("humidity", humidity)
        self.output.instance.set_number("timestamp", time.time())
        
        self.output.write()
        print(f"Published: Sensor {sensor_id}, Temp={temperature}, Hum={humidity}")
    
    def close(self):
        self.connector.close()

class EdgeDDSSubscriber:
    """边缘DDS订阅者"""
    
    def __init__(self, config_file, participant_name):
        self.connector = rti.Connector(participant_name, config_file)
        self.input = self.connector.get_input("SensorSubscriber::SensorReader")
    
    def read_data(self):
        """读取数据"""
        self.input.take()
        
        for sample in self.input.samples.valid_data_iter:
            sensor_id = sample.get_number("sensor_id")
            temp = sample.get_number("temperature")
            hum = sample.get_number("humidity")
            timestamp = sample.get_number("timestamp")
            
            print(f"Received: Sensor {sensor_id}, Temp={temp}, Hum={hum}, Time={timestamp}")
    
    def wait_for_data(self, timeout=1):
        """等待数据"""
        self.connector.wait(timeout)
    
    def close(self):
        self.connector.close()

# 使用示例
if __name__ == '__main__':
    import time
    import random
    
    # 发布者
    pub = EdgeDDSPublisher("sensor.xml", "SensorDomain::SensorParticipant")
    
    try:
        for i in range(100):
            pub.publish_sensor_data(
                sensor_id=1,
                temperature=random.uniform(20.0, 30.0),
                humidity=random.uniform(40.0, 80.0)
            )
            time.sleep(1)
    finally:
        pub.close()
```

---

## 5G网络增强

### 5G网络切片

```yaml
网络切片类型:
  eMBB (增强移动宽带):
    - 带宽: 高 (Gbps级)
    - 延迟: 中 (10-20ms)
    - 应用: 4K/8K视频、AR/VR
  
  URLLC (超可靠低延迟):
    - 带宽: 中
    - 延迟: 极低 (<1ms)
    - 可靠性: 99.999%
    - 应用: 工业控制、自动驾驶
  
  mMTC (海量机器通信):
    - 带宽: 低
    - 延迟: 高 (秒级可接受)
    - 连接数: 百万级/km²
    - 应用: 物联网、智慧城市

切片管理:
  - 切片模板 (Slice Template)
  - 切片实例 (Slice Instance)
  - SLA保障
  - 动态调整
```

#### 5G切片配置 (Open5GS)

```yaml
# 5g_slice_config.yaml
# Open5GS 5G网络切片配置

db_uri: mongodb://localhost/open5gs

amf:
  plmn_support:
    - plmn_id:
        mcc: 001
        mnc: 01
      s_nssai:
        - sst: 1  # eMBB
          sd: 000001
        - sst: 2  # URLLC
          sd: 000002
        - sst: 3  # mMTC
          sd: 000003

smf:
  pfcp:
    - addr: 192.168.0.111
  upf:
    - addr: 192.168.0.112
  
  session:
    - subnet: 10.45.0.0/16
      dnn: internet
      s_nssai:
        sst: 1
        sd: 000001
    
    - subnet: 10.46.0.0/16
      dnn: urllc
      s_nssai:
        sst: 2
        sd: 000002
      qos:
        index: 1  # QCI 1 (超低延迟)
        arp:
          priority_level: 1
          pre_emption_capability: 1
          pre_emption_vulnerability: 0
    
    - subnet: 10.47.0.0/16
      dnn: iot
      s_nssai:
        sst: 3
        sd: 000003
      qos:
        index: 9  # QCI 9 (尽力而为)
```

### 5G QoS流

```yaml
5QI (5G QoS Identifier):
  GBR流 (保证比特率):
    - 5QI 1: 100ms, 10^-2 丢包 (对话语音)
    - 5QI 2: 150ms, 10^-3 (对话视频)
    - 5QI 3: 50ms, 10^-3 (实时游戏)
    - 5QI 4: 300ms, 10^-6 (非对话视频)
  
  Non-GBR流:
    - 5QI 5: 100ms, 10^-6 (IMS信令)
    - 5QI 6: 300ms, 10^-6 (视频流)
    - 5QI 7: 100ms, 10^-3 (语音/视频/交互游戏)
    - 5QI 8: 300ms, 10^-6 (视频流)
    - 5QI 9: 300ms, 10^-6 (默认承载)

URLLC优化:
  - 5QI 82: 10ms, 10^-4
  - 5QI 83: 10ms, 10^-5
  - 5QI 84: 30ms, 10^-5
  - 5QI 85: 5ms, 10^-5
```

#### 5G QoS应用程序

```python
# 5g_qos_manager.py
import requests
import json

class FiveGQoSManager:
    """5G QoS管理器"""
    
    def __init__(self, nef_url):
        """
        NEF: Network Exposure Function (网络开放功能)
        """
        self.nef_url = nef_url
        self.api_key = "your-api-key"
    
    def create_qos_flow(self, ue_ipv4, app_id, qos_reference):
        """创建QoS流"""
        endpoint = f"{self.nef_url}/3gpp-as-session-with-qos/v1/qos-flows"
        
        payload = {
            "ueIpv4Addr": ue_ipv4,
            "appId": app_id,
            "qosReference": qos_reference,  # 例如 "5QI_1"
            "notificationUri": "https://edge.example.com/notify",
            "requestedQos": {
                "maxBitrateUl": "10 Mbps",
                "maxBitrateDl": "50 Mbps",
                "guaranteedBitrateUl": "5 Mbps",
                "guaranteedBitrateDl": "25 Mbps",
                "packetDelayBudget": 50,  # ms
                "packetErrorRate": "10^-5"
            }
        }
        
        headers = {
            "Content-Type": "application/json",
            "Authorization": f"Bearer {self.api_key}"
        }
        
        response = requests.post(endpoint, json=payload, headers=headers)
        
        if response.status_code == 201:
            flow_id = response.json()['qosFlowId']
            print(f"QoS flow created: {flow_id}")
            return flow_id
        else:
            print(f"Error: {response.status_code} - {response.text}")
            return None
    
    def delete_qos_flow(self, flow_id):
        """删除QoS流"""
        endpoint = f"{self.nef_url}/3gpp-as-session-with-qos/v1/qos-flows/{flow_id}"
        
        headers = {"Authorization": f"Bearer {self.api_key}"}
        
        response = requests.delete(endpoint, headers=headers)
        
        if response.status_code == 204:
            print(f"QoS flow {flow_id} deleted")
        else:
            print(f"Error: {response.status_code}")
    
    def get_flow_status(self, flow_id):
        """查询QoS流状态"""
        endpoint = f"{self.nef_url}/3gpp-as-session-with-qos/v1/qos-flows/{flow_id}"
        
        headers = {"Authorization": f"Bearer {self.api_key}"}
        
        response = requests.get(endpoint, headers=headers)
        
        if response.status_code == 200:
            status = response.json()
            print(f"Flow status: {json.dumps(status, indent=2)}")
            return status
        else:
            print(f"Error: {response.status_code}")
            return None

# 使用示例
if __name__ == '__main__':
    qos_mgr = FiveGQoSManager("https://nef.operator.com")
    
    # 为自动驾驶应用创建URLLC QoS流
    flow_id = qos_mgr.create_qos_flow(
        ue_ipv4="10.45.1.100",
        app_id="autonomous-driving",
        qos_reference="5QI_82"  # 10ms延迟, 10^-4丢包
    )
    
    if flow_id:
        # 查询状态
        qos_mgr.get_flow_status(flow_id)
        
        # 使用完毕后删除
        # qos_mgr.delete_qos_flow(flow_id)
```

---

## SD-WAN技术

### SD-WAN架构

```yaml
组件:
  SD-WAN Edge (边缘设备):
    - CPE (客户端设备)
    - 多WAN接口 (MPLS/互联网/LTE/5G)
    - 本地策略执行
  
  SD-WAN Controller (控制器):
    - 集中配置管理
    - 策略分发
    - 路径优化
    - 可视化监控
  
  SD-WAN Orchestrator (编排器):
    - 多租户管理
    - 自动化部署
    - 生命周期管理

优势:
  - 应用感知路由
  - 自动故障切换
  - 链路聚合 (带宽叠加)
  - 成本优化 (减少MPLS依赖)
  - 零接触部署 (ZTP)
```

#### SD-WAN配置示例

```yaml
# sdwan_config.yaml
# VeloCloud SD-WAN配置示例

edges:
  - name: edge-factory-01
    location: Factory A
    interfaces:
      - name: wan1
        type: mpls
        bandwidth: 100Mbps
        cost: 10  # 高成本
      
      - name: wan2
        type: internet
        bandwidth: 500Mbps
        cost: 2  # 低成本
      
      - name: wan3
        type: lte
        bandwidth: 50Mbps
        cost: 5  # 中等成本 (备用)
    
    business_policies:
      - name: ERP_Traffic
        match:
          application: SAP_ERP
        action:
          preferred_link: wan1  # MPLS
          backup_link: wan2
          sla:
            latency: 50ms
            jitter: 10ms
            loss: 0.1%
      
      - name: Video_Conference
        match:
          application: Zoom
        action:
          preferred_link: wan2  # 互联网
          backup_link: wan1
          qos:
            priority: high
            bandwidth_reserve: 10Mbps
      
      - name: Bulk_Transfer
        match:
          application: Cloud_Backup
        action:
          preferred_link: wan2
          time_window: "00:00-06:00"  # 夜间传输
      
      - name: Default
        match:
          any: true
        action:
          load_balance: [wan1, wan2]
          method: weighted_round_robin
          weights: [30, 70]  # 70%流量走互联网

  firewall_rules:
    - name: allow_https
      source: LAN
      destination: any
      service: https
      action: allow
    
    - name: block_social_media
      source: LAN
      destination: any
      application: [Facebook, Twitter, Instagram]
      action: deny
      log: true
```

#### SD-WAN Python管理

```python
# sdwan_manager.py
import requests
import json

class SDWANManager:
    """SD-WAN管理器"""
    
    def __init__(self, controller_url, api_token):
        self.controller_url = controller_url
        self.api_token = api_token
        self.headers = {
            "Authorization": f"Bearer {self.api_token}",
            "Content-Type": "application/json"
        }
    
    def get_edge_status(self, edge_id):
        """获取边缘设备状态"""
        url = f"{self.controller_url}/api/v1/edges/{edge_id}/status"
        response = requests.get(url, headers=self.headers)
        
        if response.status_code == 200:
            status = response.json()
            print(f"Edge {edge_id}:")
            print(f"  State: {status['state']}")
            print(f"  Uptime: {status['uptime']}s")
            print(f"  Links:")
            for link in status['links']:
                print(f"    - {link['name']}: {link['state']} "
                      f"({link['rx_mbps']:.2f} / {link['tx_mbps']:.2f} Mbps)")
            return status
        else:
            print(f"Error: {response.status_code}")
            return None
    
    def update_business_policy(self, edge_id, policy):
        """更新业务策略"""
        url = f"{self.controller_url}/api/v1/edges/{edge_id}/policies"
        response = requests.post(url, json=policy, headers=self.headers)
        
        if response.status_code == 200:
            print(f"Policy updated for edge {edge_id}")
            return True
        else:
            print(f"Error: {response.status_code} - {response.text}")
            return False
    
    def trigger_failover(self, edge_id, from_link, to_link):
        """触发故障切换"""
        policy = {
            "action": "failover",
            "from_link": from_link,
            "to_link": to_link,
            "reason": "manual_trigger"
        }
        
        url = f"{self.controller_url}/api/v1/edges/{edge_id}/actions"
        response = requests.post(url, json=policy, headers=self.headers)
        
        if response.status_code == 200:
            print(f"Failover triggered: {from_link} -> {to_link}")
            return True
        else:
            print(f"Error: {response.status_code}")
            return False
    
    def get_application_stats(self, edge_id, time_range="1h"):
        """获取应用统计"""
        url = f"{self.controller_url}/api/v1/edges/{edge_id}/application-stats"
        params = {"time_range": time_range}
        response = requests.get(url, headers=self.headers, params=params)
        
        if response.status_code == 200:
            stats = response.json()
            print(f"\nApplication Statistics (last {time_range}):")
            for app in stats['applications']:
                print(f"  {app['name']}:")
                print(f"    - Traffic: {app['bytes_sent']/1e9:.2f} GB")
                print(f"    - Avg Latency: {app['avg_latency']:.1f} ms")
                print(f"    - Packet Loss: {app['loss_rate']*100:.2f}%")
            return stats
        else:
            print(f"Error: {response.status_code}")
            return None

# 使用示例
if __name__ == '__main__':
    mgr = SDWANManager(
        controller_url="https://vco.velocloud.net",
        api_token="your-api-token"
    )
    
    edge_id = "edge-factory-01"
    
    # 获取状态
    mgr.get_edge_status(edge_id)
    
    # 获取应用统计
    mgr.get_application_stats(edge_id, time_range="24h")
    
    # 更新策略 (优先使用5G链路)
    new_policy = {
        "name": "Critical_IoT",
        "match": {
            "source_subnet": "10.0.10.0/24",
            "application": "Industrial_Control"
        },
        "action": {
            "preferred_link": "wan3",  # 5G
            "sla": {
                "latency": 10,
                "jitter": 2,
                "loss": 0.01
            }
        }
    }
    mgr.update_business_policy(edge_id, new_policy)
```

---

## 实时通信方案

### WebRTC架构

```yaml
WebRTC组件:
  Signaling (信令):
    - 建立会话 (SDP offer/answer)
    - ICE候选交换
    - 协议: WebSocket/HTTP

  STUN Server:
    - 发现公网IP和端口
    - NAT穿透

  TURN Server:
    - 中继服务器 (NAT无法穿透时)
    - 流量转发

  Media Channels:
    - DTLS-SRTP加密
    - UDP传输 (低延迟)
    - RTCP反馈 (QoS控制)

应用场景:
  - 视频会议
  - 远程协助
  - 实时监控
  - 云游戏
```

#### WebRTC信令服务器

```python
# webrtc_signaling_server.py
import asyncio
import websockets
import json
from collections import defaultdict

class SignalingServer:
    """WebRTC信令服务器"""
    
    def __init__(self):
        self.rooms = defaultdict(set)  # room_id -> set of websockets
        self.users = {}  # websocket -> user_id
    
    async def handle_client(self, websocket, path):
        """处理客户端连接"""
        try:
            async for message in websocket:
                await self.handle_message(websocket, message)
        except websockets.exceptions.ConnectionClosed:
            await self.handle_disconnect(websocket)
    
    async def handle_message(self, websocket, message):
        """处理消息"""
        data = json.loads(message)
        msg_type = data.get('type')
        
        if msg_type == 'join':
            await self.handle_join(websocket, data)
        elif msg_type == 'offer':
            await self.relay_to_room(websocket, data)
        elif msg_type == 'answer':
            await self.relay_to_room(websocket, data)
        elif msg_type == 'ice_candidate':
            await self.relay_to_room(websocket, data)
        elif msg_type == 'leave':
            await self.handle_leave(websocket, data)
    
    async def handle_join(self, websocket, data):
        """处理加入房间"""
        room_id = data['room_id']
        user_id = data['user_id']
        
        self.rooms[room_id].add(websocket)
        self.users[websocket] = user_id
        
        # 通知房间内其他用户
        await self.broadcast_to_room(room_id, {
            'type': 'user_joined',
            'user_id': user_id
        }, exclude=websocket)
        
        print(f"User {user_id} joined room {room_id}")
    
    async def handle_leave(self, websocket, data):
        """处理离开房间"""
        room_id = data['room_id']
        user_id = self.users.get(websocket)
        
        if websocket in self.rooms[room_id]:
            self.rooms[room_id].remove(websocket)
        
        if websocket in self.users:
            del self.users[websocket]
        
        await self.broadcast_to_room(room_id, {
            'type': 'user_left',
            'user_id': user_id
        })
        
        print(f"User {user_id} left room {room_id}")
    
    async def handle_disconnect(self, websocket):
        """处理断开连接"""
        user_id = self.users.get(websocket)
        
        # 从所有房间移除
        for room_id, members in self.rooms.items():
            if websocket in members:
                members.remove(websocket)
                await self.broadcast_to_room(room_id, {
                    'type': 'user_left',
                    'user_id': user_id
                })
        
        if websocket in self.users:
            del self.users[websocket]
        
        print(f"User {user_id} disconnected")
    
    async def relay_to_room(self, sender, data):
        """转发到房间"""
        room_id = data.get('room_id')
        if room_id:
            await self.broadcast_to_room(room_id, data, exclude=sender)
    
    async def broadcast_to_room(self, room_id, data, exclude=None):
        """广播到房间"""
        message = json.dumps(data)
        tasks = []
        
        for websocket in self.rooms[room_id]:
            if websocket != exclude:
                tasks.append(websocket.send(message))
        
        if tasks:
            await asyncio.gather(*tasks, return_exceptions=True)

# 启动服务器
async def main():
    server = SignalingServer()
    async with websockets.serve(server.handle_client, "0.0.0.0", 8765):
        print("Signaling server started on ws://0.0.0.0:8765")
        await asyncio.Future()  # 永久运行

if __name__ == '__main__':
    asyncio.run(main())
```

#### WebRTC客户端示例

```javascript
// webrtc_client.js
class WebRTCClient {
    constructor(signalingServerUrl, roomId, userId) {
        this.signalingServerUrl = signalingServerUrl;
        this.roomId = roomId;
        this.userId = userId;
        
        this.ws = null;
        this.peerConnection = null;
        this.localStream = null;
        
        this.config = {
            iceServers: [
                { urls: 'stun:stun.l.google.com:19302' },
                { 
                    urls: 'turn:turn.example.com:3478',
                    username: 'user',
                    credential: 'pass'
                }
            ]
        };
    }
    
    async connect() {
        // 连接信令服务器
        this.ws = new WebSocket(this.signalingServerUrl);
        
        this.ws.onopen = () => {
            console.log('Connected to signaling server');
            this.joinRoom();
        };
        
        this.ws.onmessage = (event) => {
            this.handleSignalingMessage(JSON.parse(event.data));
        };
        
        // 获取本地媒体流
        this.localStream = await navigator.mediaDevices.getUserMedia({
            video: { width: 1280, height: 720 },
            audio: true
        });
        
        document.getElementById('localVideo').srcObject = this.localStream;
    }
    
    joinRoom() {
        this.send({
            type: 'join',
            room_id: this.roomId,
            user_id: this.userId
        });
    }
    
    async handleSignalingMessage(data) {
        const { type } = data;
        
        switch (type) {
            case 'user_joined':
                console.log(`User ${data.user_id} joined`);
                // 创建offer
                await this.createOffer();
                break;
            
            case 'offer':
                await this.handleOffer(data);
                break;
            
            case 'answer':
                await this.handleAnswer(data);
                break;
            
            case 'ice_candidate':
                await this.handleIceCandidate(data);
                break;
            
            case 'user_left':
                console.log(`User ${data.user_id} left`);
                this.closePeerConnection();
                break;
        }
    }
    
    async createOffer() {
        this.peerConnection = new RTCPeerConnection(this.config);
        this.setupPeerConnection();
        
        // 添加本地流
        this.localStream.getTracks().forEach(track => {
            this.peerConnection.addTrack(track, this.localStream);
        });
        
        // 创建offer
        const offer = await this.peerConnection.createOffer();
        await this.peerConnection.setLocalDescription(offer);
        
        this.send({
            type: 'offer',
            room_id: this.roomId,
            sdp: offer.sdp
        });
    }
    
    async handleOffer(data) {
        this.peerConnection = new RTCPeerConnection(this.config);
        this.setupPeerConnection();
        
        this.localStream.getTracks().forEach(track => {
            this.peerConnection.addTrack(track, this.localStream);
        });
        
        await this.peerConnection.setRemoteDescription({
            type: 'offer',
            sdp: data.sdp
        });
        
        const answer = await this.peerConnection.createAnswer();
        await this.peerConnection.setLocalDescription(answer);
        
        this.send({
            type: 'answer',
            room_id: this.roomId,
            sdp: answer.sdp
        });
    }
    
    async handleAnswer(data) {
        await this.peerConnection.setRemoteDescription({
            type: 'answer',
            sdp: data.sdp
        });
    }
    
    async handleIceCandidate(data) {
        if (this.peerConnection) {
            await this.peerConnection.addIceCandidate(data.candidate);
        }
    }
    
    setupPeerConnection() {
        // ICE候选
        this.peerConnection.onicecandidate = (event) => {
            if (event.candidate) {
                this.send({
                    type: 'ice_candidate',
                    room_id: this.roomId,
                    candidate: event.candidate
                });
            }
        };
        
        // 远程流
        this.peerConnection.ontrack = (event) => {
            const remoteVideo = document.getElementById('remoteVideo');
            remoteVideo.srcObject = event.streams[0];
        };
        
        // 连接状态
        this.peerConnection.onconnectionstatechange = () => {
            console.log('Connection state:', this.peerConnection.connectionState);
        };
    }
    
    closePeerConnection() {
        if (this.peerConnection) {
            this.peerConnection.close();
            this.peerConnection = null;
        }
    }
    
    send(data) {
        if (this.ws && this.ws.readyState === WebSocket.OPEN) {
            this.ws.send(JSON.stringify(data));
        }
    }
    
    disconnect() {
        this.send({
            type: 'leave',
            room_id: this.roomId
        });
        
        this.closePeerConnection();
        
        if (this.localStream) {
            this.localStream.getTracks().forEach(track => track.stop());
        }
        
        if (this.ws) {
            this.ws.close();
        }
    }
}

// 使用
const client = new WebRTCClient('ws://localhost:8765', 'room123', 'user001');
client.connect();
```

---

## 网络性能优化

### 延迟优化

```yaml
关键技术:
  1. 边缘部署:
     - 接近用户
     - 减少跳数
     - CDN加速
  
  2. 协议优化:
     - HTTP/3 (QUIC)
     - BBR拥塞控制
     - 0-RTT握手
  
  3. 硬件加速:
     - DPDK (数据平面开发套件)
     - SR-IOV (单根I/O虚拟化)
     - RDMA (远程直接内存访问)
  
  4. 路径优化:
     - Anycast路由
     - 智能DNS
     - SD-WAN动态路径选择

性能目标:
  - P50延迟: <10ms
  - P95延迟: <50ms
  - P99延迟: <100ms
```

#### BBR拥塞控制

```bash
# 启用BBR拥塞控制 (Linux内核 4.9+)

# 1. 加载BBR模块
modprobe tcp_bbr

# 2. 配置系统参数
cat >> /etc/sysctl.conf << EOF
net.core.default_qdisc = fq
net.ipv4.tcp_congestion_control = bbr

# 优化TCP参数
net.ipv4.tcp_notsent_lowat = 16384
net.ipv4.tcp_slow_start_after_idle = 0
net.ipv4.tcp_mtu_probing = 1
EOF

# 3. 应用配置
sysctl -p

# 4. 验证
sysctl net.ipv4.tcp_congestion_control
# 输出: net.ipv4.tcp_congestion_control = bbr

# 5. 查看TCP统计
ss -tin | grep bbr
```

#### DPDK高性能数据面

```python
# dpdk_forwarder.py (伪代码)
from rte_sdk import *

class DPDKForwarder:
    """DPDK高性能转发器"""
    
    def __init__(self, num_ports=2):
        # 初始化EAL (Environment Abstraction Layer)
        rte_eal_init()
        
        # 初始化内存池
        self.mbuf_pool = rte_pktmbuf_pool_create(
            name="MBUF_POOL",
            n=8192,
            cache_size=256,
            priv_size=0,
            data_room_size=RTE_MBUF_DEFAULT_BUF_SIZE,
            socket_id=rte_socket_id()
        )
        
        # 配置网卡
        self.ports = []
        for port_id in range(num_ports):
            self.configure_port(port_id)
            self.ports.append(port_id)
    
    def configure_port(self, port_id):
        """配置网卡"""
        port_conf = rte_eth_conf()
        
        # 配置接收队列
        rte_eth_dev_configure(port_id, 1, 1, port_conf)
        
        # 配置RX队列
        rte_eth_rx_queue_setup(
            port_id, 0, 1024,
            rte_eth_dev_socket_id(port_id),
            None,
            self.mbuf_pool
        )
        
        # 配置TX队列
        rte_eth_tx_queue_setup(
            port_id, 0, 1024,
            rte_eth_dev_socket_id(port_id),
            None
        )
        
        # 启动网卡
        rte_eth_dev_start(port_id)
        rte_eth_promiscuous_enable(port_id)
    
    def forward_loop(self):
        """转发循环 (运行在单独线程)"""
        while True:
            for port_in, port_out in [(0, 1), (1, 0)]:
                # 批量接收数据包 (burst)
                pkts = rte_eth_rx_burst(port_in, 0, burst_size=32)
                
                if len(pkts) > 0:
                    # 批量发送到另一个端口
                    sent = rte_eth_tx_burst(port_out, 0, pkts)
                    
                    # 释放未发送的包
                    for i in range(sent, len(pkts)):
                        rte_pktmbuf_free(pkts[i])
    
    def run(self):
        """启动转发"""
        print("Starting DPDK forwarding...")
        print(f"Performance: ~10-20 Mpps per core")
        
        # 启动工作线程
        rte_eal_mp_remote_launch(self.forward_loop)
        
        # 等待线程结束
        rte_eal_mp_wait_lcore()

# 使用 (需要DPDK环境)
if __name__ == '__main__':
    forwarder = DPDKForwarder(num_ports=2)
    forwarder.run()
```

### 带宽优化

```yaml
技术:
  1. 数据压缩:
     - Gzip/Brotli (HTTP)
     - LZ4/Zstd (实时压缩)
     - 视频编码优化 (H.265/AV1)
  
  2. 缓存策略:
     - CDN边缘缓存
     - HTTP缓存头
     - 应用层缓存
  
  3. 流量整形:
     - Token Bucket
     - Leaky Bucket
     - HTB (Hierarchical Token Bucket)
  
  4. 协议优化:
     - WebSocket (持久连接)
     - gRPC (Protobuf)
     - QUIC (多路复用)
```

#### Linux流量整形

```bash
# tc (Traffic Control) 流量整形

# 1. 限制总带宽为 100Mbps
tc qdisc add dev eth0 root handle 1: htb default 30
tc class add dev eth0 parent 1: classid 1:1 htb rate 100mbit

# 2. 创建子类 (不同优先级)
# 高优先级 (40Mbps保证)
tc class add dev eth0 parent 1:1 classid 1:10 htb rate 40mbit ceil 80mbit prio 1
# 中优先级 (30Mbps保证)
tc class add dev eth0 parent 1:1 classid 1:20 htb rate 30mbit ceil 60mbit prio 2
# 低优先级 (20Mbps保证)
tc class add dev eth0 parent 1:1 classid 1:30 htb rate 20mbit ceil 40mbit prio 3

# 3. 添加公平队列 (SFQ - Stochastic Fairness Queueing)
tc qdisc add dev eth0 parent 1:10 handle 10: sfq perturb 10
tc qdisc add dev eth0 parent 1:20 handle 20: sfq perturb 10
tc qdisc add dev eth0 parent 1:30 handle 30: sfq perturb 10

# 4. 流量分类 (根据端口)
# SSH (22) -> 高优先级
tc filter add dev eth0 protocol ip parent 1:0 prio 1 u32 \
  match ip dport 22 0xffff flowid 1:10

# HTTP/HTTPS (80/443) -> 中优先级
tc filter add dev eth0 protocol ip parent 1:0 prio 2 u32 \
  match ip dport 80 0xffff flowid 1:20
tc filter add dev eth0 protocol ip parent 1:0 prio 2 u32 \
  match ip dport 443 0xffff flowid 1:20

# 其他 -> 低优先级
# (默认走 classid 1:30)

# 5. 查看配置
tc -s qdisc show dev eth0
tc -s class show dev eth0
tc -s filter show dev eth0

# 6. 删除配置
tc qdisc del dev eth0 root
```

### 网络监控

```python
# network_monitor.py
import psutil
import time
from collections import deque
from dataclasses import dataclass
from typing import Dict

@dataclass
class NetworkStats:
    """网络统计"""
    bytes_sent: int
    bytes_recv: int
    packets_sent: int
    packets_recv: int
    errin: int
    errout: int
    dropin: int
    dropout: int

class NetworkMonitor:
    """网络监控器"""
    
    def __init__(self, interface='eth0', window_size=60):
        self.interface = interface
        self.window_size = window_size
        
        # 历史数据 (sliding window)
        self.history = {
            'bytes_sent': deque(maxlen=window_size),
            'bytes_recv': deque(maxlen=window_size),
            'packets_sent': deque(maxlen=window_size),
            'packets_recv': deque(maxlen=window_size),
        }
        
        self.last_stats = None
    
    def get_stats(self) -> NetworkStats:
        """获取当前统计"""
        stats = psutil.net_io_counters(pernic=True)[self.interface]
        
        return NetworkStats(
            bytes_sent=stats.bytes_sent,
            bytes_recv=stats.bytes_recv,
            packets_sent=stats.packets_sent,
            packets_recv=stats.packets_recv,
            errin=stats.errin,
            errout=stats.errout,
            dropin=stats.dropin,
            dropout=stats.dropout
        )
    
    def get_rate(self, interval=1.0) -> Dict:
        """获取速率"""
        stats1 = self.get_stats()
        time.sleep(interval)
        stats2 = self.get_stats()
        
        bytes_sent_rate = (stats2.bytes_sent - stats1.bytes_sent) / interval
        bytes_recv_rate = (stats2.bytes_recv - stats1.bytes_recv) / interval
        packets_sent_rate = (stats2.packets_sent - stats1.packets_sent) / interval
        packets_recv_rate = (stats2.packets_recv - stats1.packets_recv) / interval
        
        # 保存到历史
        self.history['bytes_sent'].append(bytes_sent_rate)
        self.history['bytes_recv'].append(bytes_recv_rate)
        self.history['packets_sent'].append(packets_sent_rate)
        self.history['packets_recv'].append(packets_recv_rate)
        
        return {
            'bytes_sent_mbps': bytes_sent_rate * 8 / 1e6,  # Mbps
            'bytes_recv_mbps': bytes_recv_rate * 8 / 1e6,
            'packets_sent_pps': packets_sent_rate,
            'packets_recv_pps': packets_recv_rate,
            'errors': stats2.errin + stats2.errout,
            'drops': stats2.dropin + stats2.dropout
        }
    
    def get_average_rate(self) -> Dict:
        """获取平均速率"""
        if not self.history['bytes_sent']:
            return {}
        
        return {
            'avg_bytes_sent_mbps': sum(self.history['bytes_sent']) / len(self.history['bytes_sent']) * 8 / 1e6,
            'avg_bytes_recv_mbps': sum(self.history['bytes_recv']) / len(self.history['bytes_recv']) * 8 / 1e6,
            'avg_packets_sent_pps': sum(self.history['packets_sent']) / len(self.history['packets_sent']),
            'avg_packets_recv_pps': sum(self.history['packets_recv']) / len(self.history['packets_recv'])
        }
    
    def get_peak_rate(self) -> Dict:
        """获取峰值速率"""
        if not self.history['bytes_sent']:
            return {}
        
        return {
            'peak_bytes_sent_mbps': max(self.history['bytes_sent']) * 8 / 1e6,
            'peak_bytes_recv_mbps': max(self.history['bytes_recv']) * 8 / 1e6,
            'peak_packets_sent_pps': max(self.history['packets_sent']),
            'peak_packets_recv_pps': max(self.history['packets_recv'])
        }
    
    def print_dashboard(self):
        """打印监控面板"""
        rate = self.get_rate(interval=1.0)
        avg = self.get_average_rate()
        peak = self.get_peak_rate()
        
        print(f"\n{'='*60}")
        print(f"Network Monitor - {self.interface}")
        print(f"{'='*60}")
        
        print(f"\n[Current]")
        print(f"  TX: {rate['bytes_sent_mbps']:8.2f} Mbps  |  RX: {rate['bytes_recv_mbps']:8.2f} Mbps")
        print(f"  TX: {rate['packets_sent_pps']:8.0f} pps   |  RX: {rate['packets_recv_pps']:8.0f} pps")
        print(f"  Errors: {rate['errors']}  |  Drops: {rate['drops']}")
        
        if avg:
            print(f"\n[Average (last {self.window_size}s)]")
            print(f"  TX: {avg['avg_bytes_sent_mbps']:8.2f} Mbps  |  RX: {avg['avg_bytes_recv_mbps']:8.2f} Mbps")
            print(f"  TX: {avg['avg_packets_sent_pps']:8.0f} pps   |  RX: {avg['avg_packets_recv_pps']:8.0f} pps")
        
        if peak:
            print(f"\n[Peak]")
            print(f"  TX: {peak['peak_bytes_sent_mbps']:8.2f} Mbps  |  RX: {peak['peak_bytes_recv_mbps']:8.2f} Mbps")
            print(f"  TX: {peak['peak_packets_sent_pps']:8.0f} pps   |  RX: {peak['peak_packets_recv_pps']:8.0f} pps")

# 使用示例
if __name__ == '__main__':
    monitor = NetworkMonitor('eth0', window_size=60)
    
    try:
        while True:
            monitor.print_dashboard()
            time.sleep(1)
    except KeyboardInterrupt:
        print("\nExiting...")
```

---

## 最佳实践

### 1. 网络设计原则

```yaml
分层设计:
  - 接入层: 设备连接
  - 汇聚层: 流量聚合
  - 核心层: 高速转发

冗余设计:
  - 双链路备份
  - 多路径路由
  - 快速收敛 (<50ms)

QoS策略:
  - 关键业务: 高优先级
  - 实时流量: 低延迟队列
  - 尽力而为: 默认队列

安全隔离:
  - VLAN分段
  - 防火墙策略
  - 零信任网络
```

### 2. 故障排查流程

```bash
# 1. 检查物理连接
ip link show eth0
ethtool eth0

# 2. 检查IP配置
ip addr show eth0
ip route show

# 3. 测试连通性
ping -c 4 8.8.8.8
traceroute 8.8.8.8

# 4. 检查DNS
nslookup example.com
dig example.com

# 5. 检查端口
ss -tuln | grep :80
netstat -anp | grep :80

# 6. 抓包分析
tcpdump -i eth0 -nn port 80 -w capture.pcap
# 使用Wireshark分析

# 7. 检查防火墙
iptables -L -n -v
firewall-cmd --list-all

# 8. 检查性能
iperf3 -c server_ip -t 30
```

### 3. 性能调优清单

```yaml
内核参数:
  - net.core.rmem_max: 接收缓冲区
  - net.core.wmem_max: 发送缓冲区
  - net.ipv4.tcp_rmem/wmem: TCP缓冲区
  - net.ipv4.tcp_congestion_control: BBR
  - net.core.netdev_max_backlog: 接收队列

网卡优化:
  - RSS (Receive Side Scaling)
  - TSO (TCP Segmentation Offload)
  - GSO (Generic Segmentation Offload)
  - GRO (Generic Receive Offload)
  - 中断合并

应用层:
  - 连接池复用
  - 批量处理
  - 异步I/O
  - 零拷贝 (sendfile)
```

---

## 参考资料

### 标准文档

```yaml
TSN:
  - IEEE 802.1AS-2020 (时间同步)
  - IEEE 802.1Qbv-2015 (时间感知调度)
  - IEEE 802.1CB-2017 (帧复制与消除)

MQTT:
  - MQTT 5.0 Specification (OASIS Standard)
  - ISO/IEC 20922:2016

OPC-UA:
  - IEC 62541 (OPC Unified Architecture)

DDS:
  - OMG DDS 1.4 Specification

5G:
  - 3GPP TS 23.501 (5G系统架构)
  - 3GPP TS 23.502 (5G流程)
  - 3GPP TS 28.530 (网络切片)
```

### 开源项目

```yaml
eBPF:
  - BCC: https://github.com/iovisor/bcc
  - Cilium: https://github.com/cilium/cilium
  - Calico/eBPF: https://github.com/projectcalico/calico

MQTT:
  - Mosquitto: https://mosquitto.org/
  - EMQX: https://github.com/emqx/emqx
  - VerneMQ: https://github.com/vernemq/vernemq

WebRTC:
  - Janus Gateway: https://github.com/meetecho/janus-gateway
  - Kurento: https://github.com/Kurento/kurento
  - mediasoup: https://github.com/versatica/mediasoup

SD-WAN:
  - OpenWRT: https://openwrt.org/
  - VyOS: https://vyos.io/
```

### 学习资源

```yaml
书籍:
  - "Linux Advanced Routing & Traffic Control HOWTO"
  - "BPF Performance Tools" (Brendan Gregg)
  - "High Performance Browser Networking"

在线课程:
  - eBPF Summit: https://ebpf.io/summit
  - Cilium Hands-On Lab
  - WebRTC School: https://webrtcforthecurious.com/

博客:
  - Cloudflare Blog (网络技术)
  - Netflix Tech Blog (流媒体优化)
  - Facebook Engineering (大规模网络)
```

---

**文档完成时间**: 2025-10-19  
**技术覆盖**: TSN/eBPF/MQTT/CoAP/OPC-UA/DDS/5G/SD-WAN/WebRTC  
**代码示例**: 25+个完整示例  
**文档字数**: 约13,000字

**Edge Networking, Low Latency, High Performance!** 🚀🌐💨
