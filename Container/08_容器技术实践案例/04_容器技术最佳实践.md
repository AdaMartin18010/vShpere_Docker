    # 容器技术最佳实践

## 目录

- [容器技术最佳实践](#容器技术最佳实践)
  - [1. 容器设计最佳实践](#1-容器设计最佳实践)
    - [1.1 单一职责原则](#11-单一职责原则)
      - [一个容器一个进程](#一个容器一个进程)
- [好的做法：单一职责](#好的做法单一职责)
- [避免的做法：多进程](#避免的做法多进程)
- [不推荐：一个容器运行多个服务](#不推荐一个容器运行多个服务)
      - [应用配置分离](#应用配置分离)
- [使用ConfigMap管理配置](#使用configmap管理配置)
    - [1.2 无状态设计](#12-无状态设计)
      - [状态外置](#状态外置)
- [使用外部存储](#使用外部存储)
      - [会话管理](#会话管理)
- [使用Redis管理会话](#使用redis管理会话)
    - [1.3 健康检查](#13-健康检查)
      - [健康检查配置](#健康检查配置)
- [Dockerfile中的健康检查](#dockerfile中的健康检查)
      - [Kubernetes健康检查](#kubernetes健康检查)
  - [2. 镜像构建最佳实践](#2-镜像构建最佳实践)
    - [2.1 多阶段构建](#21-多阶段构建)
      - [优化镜像大小](#优化镜像大小)
- [多阶段构建示例](#多阶段构建示例)
      - [构建缓存优化](#构建缓存优化)
- [优化构建缓存](#优化构建缓存)
    - [2.2 基础镜像选择](#22-基础镜像选择)
      - [选择合适的基础镜像](#选择合适的基础镜像)
- [推荐：使用官方镜像](#推荐使用官方镜像)
- [推荐：使用distroless镜像](#推荐使用distroless镜像)
- [避免：使用过大的基础镜像](#避免使用过大的基础镜像)
      - [镜像标签管理](#镜像标签管理)
- [使用语义化版本](#使用语义化版本)
- [使用Git提交哈希](#使用git提交哈希)
- [使用构建时间戳](#使用构建时间戳)
    - [2.3 安全扫描](#23-安全扫描)
      - [集成安全扫描](#集成安全扫描)
- [CI/CD中的安全扫描](#cicd中的安全扫描)
  - [3. 容器运行最佳实践](#3-容器运行最佳实践)
    - [3.1 资源限制](#31-资源限制)
      - [设置资源限制](#设置资源限制)
      - [资源监控](#资源监控)
- [资源监控配置](#资源监控配置)
    - [3.2 环境变量管理](#32-环境变量管理)
      - [使用Secret管理敏感信息](#使用secret管理敏感信息)
      - [使用ConfigMap管理配置](#使用configmap管理配置)
    - [3.3 日志管理](#33-日志管理)
      - [结构化日志](#结构化日志)
- [Python应用结构化日志](#python应用结构化日志)
- [配置日志](#配置日志)
      - [日志收集](#日志收集)
- [Fluentd日志收集配置](#fluentd日志收集配置)
  - [4. 安全最佳实践](#4-安全最佳实践)
    - [4.1 非root用户运行](#41-非root用户运行)
      - [创建非root用户](#创建非root用户)
- [创建非root用户](#创建非root用户)
      - [使用非特权容器](#使用非特权容器)
    - [4.2 网络安全](#42-网络安全)
      - [网络策略](#网络策略)
      - [服务网格安全](#服务网格安全)
- [Istio安全策略](#istio安全策略)
    - [4.3 镜像安全](#43-镜像安全)
      - [镜像签名](#镜像签名)
- [镜像签名](#镜像签名)
- [使用Cosign签名](#使用cosign签名)
      - [漏洞扫描](#漏洞扫描)
- [漏洞扫描配置](#漏洞扫描配置)
  - [5. 性能优化最佳实践](#5-性能优化最佳实践)
    - [5.1 资源优化](#51-资源优化)
      - [CPU优化](#cpu优化)
      - [内存优化](#内存优化)
    - [5.2 缓存优化](#52-缓存优化)
      - [应用缓存](#应用缓存)
- [Redis缓存配置](#redis缓存配置)
      - [镜像缓存](#镜像缓存)
- [优化镜像构建缓存](#优化镜像构建缓存)
    - [5.3 网络优化](#53-网络优化)
      - [网络配置优化](#网络配置优化)
  - [6. 监控运维最佳实践](#6-监控运维最佳实践)
    - [6.1 监控配置](#61-监控配置)
      - [应用监控](#应用监控)
- [Prometheus监控配置](#prometheus监控配置)
      - [告警配置](#告警配置)
- [告警规则配置](#告警规则配置)
    - [6.2 日志管理](#62-日志管理)
      - [结构化日志1](#结构化日志1)
      - [日志收集1](#日志收集1)
- [Fluentd日志收集配置](#fluentd日志收集配置)
    - [6.3 自动化运维](#63-自动化运维)
      - [自动扩缩容](#自动扩缩容)
- [HPA配置](#hpa配置)
      - [自动恢复](#自动恢复)
- [自动恢复配置](#自动恢复配置)
  - [7. 网络存储最佳实践](#7-网络存储最佳实践)
    - [7.1 网络配置](#71-网络配置)
      - [服务发现](#服务发现)
- [服务配置](#服务配置)
- [Ingress配置](#ingress配置)
      - [负载均衡](#负载均衡)
- [负载均衡配置](#负载均衡配置)
    - [7.2 存储配置](#72-存储配置)
      - [持久化存储](#持久化存储)
- [PVC配置](#pvc配置)
- [Pod使用PVC](#pod使用pvc)
      - [存储类配置](#存储类配置)
- [存储类配置](#存储类配置)
  - [8. 编排管理最佳实践](#8-编排管理最佳实践)
    - [8.1 部署策略](#81-部署策略)
      - [滚动更新](#滚动更新)
- [滚动更新配置](#滚动更新配置)
      - [蓝绿部署](#蓝绿部署)
- [蓝绿部署配置](#蓝绿部署配置)
    - [8.2 配置管理](#82-配置管理)
      - [配置热更新](#配置热更新)
- [ConfigMap配置](#configmap配置)
- [使用ConfigMap](#使用configmap)
      - [环境变量管理](#环境变量管理)
- [环境变量配置](#环境变量配置)
  - [9. 故障处理最佳实践](#9-故障处理最佳实践)
    - [9.1 故障检测](#91-故障检测)
      - [健康检查](#健康检查)
- [健康检查配置](#健康检查配置)
      - [故障监控](#故障监控)
- [故障监控配置](#故障监控配置)
    - [9.2 故障恢复](#92-故障恢复)
      - [自动恢复1](#自动恢复1)
- [自动恢复配置](#自动恢复配置)
      - [故障转移](#故障转移)
- [故障转移配置](#故障转移配置)
    - [9.3 故障分析](#93-故障分析)
      - [日志分析](#日志分析)
- [日志分析脚本](#日志分析脚本)
      - [性能分析](#性能分析)
- [性能分析脚本](#性能分析脚本)
  - [10. 团队协作最佳实践](#10-团队协作最佳实践)
    - [10.1 开发流程](#101-开发流程)
      - [代码审查](#代码审查)
- [代码审查配置](#代码审查配置)
      - [持续集成](#持续集成)
- [CI配置](#ci配置)
    - [10.2 文档管理](#102-文档管理)
      - [API文档](#api文档)
- [API文档配置](#api文档配置)
      - [运维文档](#运维文档)
- [运维文档模板](#运维文档模板)
  - [服务概述](#服务概述)
  - [部署信息](#部署信息)
  - [监控配置](#监控配置)
  - [故障处理](#故障处理)
  - [联系方式](#联系方式)
    - [10.3 知识分享](#103-知识分享)
      - [技术分享](#技术分享)
- [技术分享配置](#技术分享配置)
      - [经验总结](#经验总结)
- [经验总结配置](#经验总结配置)

- [容器技术最佳实践](#容器技术最佳实践)
  - [1. 容器设计最佳实践](#1-容器设计最佳实践)
    - [1.1 单一职责原则](#11-单一职责原则)
      - [一个容器一个进程](#一个容器一个进程)
- [好的做法：单一职责](#好的做法单一职责)
- [避免的做法：多进程](#避免的做法多进程)
- [不推荐：一个容器运行多个服务](#不推荐一个容器运行多个服务)
      - [应用配置分离](#应用配置分离)
- [使用ConfigMap管理配置](#使用configmap管理配置)
    - [1.2 无状态设计](#12-无状态设计)
      - [状态外置](#状态外置)
- [使用外部存储](#使用外部存储)
      - [会话管理](#会话管理)
- [使用Redis管理会话](#使用redis管理会话)
    - [1.3 健康检查](#13-健康检查)
      - [健康检查配置](#健康检查配置)
- [Dockerfile中的健康检查](#dockerfile中的健康检查)
      - [Kubernetes健康检查](#kubernetes健康检查)
  - [2. 镜像构建最佳实践](#2-镜像构建最佳实践)
    - [2.1 多阶段构建](#21-多阶段构建)
      - [优化镜像大小](#优化镜像大小)
- [多阶段构建示例](#多阶段构建示例)
      - [构建缓存优化](#构建缓存优化)
- [优化构建缓存](#优化构建缓存)
    - [2.2 基础镜像选择](#22-基础镜像选择)
      - [选择合适的基础镜像](#选择合适的基础镜像)
- [推荐：使用官方镜像](#推荐使用官方镜像)
- [推荐：使用distroless镜像](#推荐使用distroless镜像)
- [避免：使用过大的基础镜像](#避免使用过大的基础镜像)
      - [镜像标签管理](#镜像标签管理)
- [使用语义化版本](#使用语义化版本)
- [使用Git提交哈希](#使用git提交哈希)
- [使用构建时间戳](#使用构建时间戳)
    - [2.3 安全扫描](#23-安全扫描)
      - [集成安全扫描](#集成安全扫描)
- [CI/CD中的安全扫描](#cicd中的安全扫描)
  - [3. 容器运行最佳实践](#3-容器运行最佳实践)
    - [3.1 资源限制](#31-资源限制)
      - [设置资源限制](#设置资源限制)
      - [资源监控](#资源监控)
- [资源监控配置](#资源监控配置)
- [监控资源使用情况](#监控资源使用情况)
    - [3.2 环境变量管理](#32-环境变量管理)
      - [使用Secret管理敏感信息](#使用secret管理敏感信息)
      - [使用ConfigMap管理配置](#使用configmap管理配置)
    - [3.3 日志管理](#33-日志管理)
      - [结构化日志](#结构化日志)
- [Python应用结构化日志](#python应用结构化日志)
- [配置日志](#配置日志)
      - [日志收集](#日志收集)
- [Fluentd日志收集配置](#fluentd日志收集配置)
  - [4. 安全最佳实践](#4-安全最佳实践)
    - [4.1 非root用户运行](#41-非root用户运行)
      - [创建非root用户](#创建非root用户)
- [创建非root用户](#创建非root用户)
      - [使用非特权容器](#使用非特权容器)
    - [4.2 网络安全](#42-网络安全)
      - [网络策略](#网络策略)
      - [服务网格安全](#服务网格安全)
- [Istio安全策略](#istio安全策略)
    - [4.3 镜像安全](#43-镜像安全)
      - [镜像签名](#镜像签名)
- [镜像签名](#镜像签名)
- [使用Cosign签名](#使用cosign签名)
      - [漏洞扫描](#漏洞扫描)
- [漏洞扫描配置](#漏洞扫描配置)
- [漏洞扫描脚本](#漏洞扫描脚本)
- [Trivy扫描](#trivy扫描)
- [检查高危漏洞](#检查高危漏洞)
  - [5. 性能优化最佳实践](#5-性能优化最佳实践)
    - [5.1 资源优化](#51-资源优化)
      - [CPU优化](#cpu优化)
      - [内存优化](#内存优化)
    - [5.2 缓存优化](#52-缓存优化)
      - [应用缓存](#应用缓存)
- [Redis缓存配置](#redis缓存配置)
      - [镜像缓存](#镜像缓存)
- [优化镜像构建缓存](#优化镜像构建缓存)
    - [5.3 网络优化](#53-网络优化)
      - [网络配置优化](#网络配置优化)
  - [6. 监控运维最佳实践](#6-监控运维最佳实践)
    - [6.1 监控配置](#61-监控配置)
      - [应用监控](#应用监控)
- [Prometheus监控配置](#prometheus监控配置)
      - [告警配置](#告警配置)
- [告警规则配置](#告警规则配置)
    - [6.2 日志管理](#62-日志管理)
      - [结构化日志1](#结构化日志1)
      - [日志收集1](#日志收集1)
- [Fluentd日志收集配置](#fluentd日志收集配置)
    - [6.3 自动化运维](#63-自动化运维)
      - [自动扩缩容](#自动扩缩容)
- [HPA配置](#hpa配置)
      - [自动恢复](#自动恢复)
- [自动恢复配置](#自动恢复配置)
- [自动恢复脚本](#自动恢复脚本)
- [重启服务](#重启服务)
- [等待服务恢复](#等待服务恢复)
- [发送告警](#发送告警)
- [恢复所有服务](#恢复所有服务)
  - [7. 网络存储最佳实践](#7-网络存储最佳实践)
    - [7.1 网络配置](#71-网络配置)
      - [服务发现](#服务发现)
- [服务配置](#服务配置)
- [Ingress配置](#ingress配置)
      - [负载均衡](#负载均衡)
- [负载均衡配置](#负载均衡配置)
    - [7.2 存储配置](#72-存储配置)
      - [持久化存储](#持久化存储)
- [PVC配置](#pvc配置)
- [Pod使用PVC](#pod使用pvc)
      - [存储类配置](#存储类配置)
- [存储类配置](#存储类配置)
  - [8. 编排管理最佳实践](#8-编排管理最佳实践)
    - [8.1 部署策略](#81-部署策略)
      - [滚动更新](#滚动更新)
- [滚动更新配置](#滚动更新配置)
      - [蓝绿部署](#蓝绿部署)
- [蓝绿部署配置](#蓝绿部署配置)
    - [8.2 配置管理](#82-配置管理)
      - [配置热更新](#配置热更新)
- [ConfigMap配置](#configmap配置)
- [使用ConfigMap](#使用configmap)
      - [环境变量管理](#环境变量管理)
- [环境变量配置](#环境变量配置)
  - [9. 故障处理最佳实践](#9-故障处理最佳实践)
    - [9.1 故障检测](#91-故障检测)
      - [健康检查](#健康检查)
- [健康检查配置](#健康检查配置)
      - [故障监控](#故障监控)
- [故障监控配置](#故障监控配置)
- [故障监控脚本](#故障监控脚本)
- [检查服务健康状态](#检查服务健康状态)
- [检查响应时间](#检查响应时间)
    - [9.2 故障恢复](#92-故障恢复)
      - [自动恢复1](#自动恢复1)
- [自动恢复配置](#自动恢复配置)
- [自动恢复脚本](#自动恢复脚本)
- [重启服务](#重启服务)
- [等待服务恢复](#等待服务恢复)
- [发送告警](#发送告警)
- [恢复所有服务](#恢复所有服务)
      - [故障转移](#故障转移)
- [故障转移配置](#故障转移配置)
    - [9.3 故障分析](#93-故障分析)
      - [日志分析](#日志分析)
- [日志分析脚本](#日志分析脚本)
- [获取错误日志](#获取错误日志)
- [获取警告日志](#获取警告日志)
- [统计日志级别](#统计日志级别)
      - [性能分析](#性能分析)
- [性能分析脚本](#性能分析脚本)
- [获取资源使用情况](#获取资源使用情况)
- [获取Pod状态](#获取pod状态)
- [获取事件](#获取事件)
  - [10. 团队协作最佳实践](#10-团队协作最佳实践)
    - [10.1 开发流程](#101-开发流程)
      - [代码审查](#代码审查)
- [代码审查配置](#代码审查配置)
- [代码审查脚本](#代码审查脚本)
- [检查代码质量](#检查代码质量)
- [运行测试](#运行测试)
- [安全检查](#安全检查)
- [依赖检查](#依赖检查)
      - [持续集成](#持续集成)
- [CI配置](#ci配置)
    - [10.2 文档管理](#102-文档管理)
      - [API文档](#api文档)
- [API文档配置](#api文档配置)
      - [运维文档](#运维文档)
- [运维文档模板](#运维文档模板)
  - [服务概述](#服务概述)
  - [部署信息](#部署信息)
  - [监控配置](#监控配置)
  - [故障处理](#故障处理)
  - [联系方式](#联系方式)
    - [10.3 知识分享](#103-知识分享)
      - [技术分享](#技术分享)
- [技术分享配置](#技术分享配置)
- [容器技术分享](#容器技术分享)
  - [分享主题](#分享主题)
  - [分享内容](#分享内容)
  - [分享时间](#分享时间)
  - [参与人员](#参与人员)
      - [经验总结](#经验总结)
- [经验总结配置](#经验总结配置)
- [容器化经验总结](#容器化经验总结)
  - [成功经验](#成功经验)
  - [挑战与解决方案](#挑战与解决方案)
  - [最佳实践](#最佳实践)
  - [未来规划](#未来规划)

- [容器技术最佳实践](#容器技术最佳实践)
  - [1. 容器设计最佳实践](#1-容器设计最佳实践)
  - [2. 镜像构建最佳实践](#2-镜像构建最佳实践)
  - [3. 容器运行最佳实践](#3-容器运行最佳实践)
  - [4. 安全最佳实践](#4-安全最佳实践)
  - [5. 性能优化最佳实践](#5-性能优化最佳实践)
  - [6. 监控运维最佳实践](#6-监控运维最佳实践)
  - [7. 网络存储最佳实践](#7-网络存储最佳实践)
  - [8. 编排管理最佳实践](#8-编排管理最佳实践)
  - [9. 故障处理最佳实践](#9-故障处理最佳实践)
  - [10. 团队协作最佳实践](#10-团队协作最佳实践)

## 1. 容器设计最佳实践

### 1.1 单一职责原则

#### 一个容器一个进程

```dockerfile
    # 好的做法：单一职责
FROM node:16-alpine
WORKDIR /app
COPY package*.json ./
RUN npm install
COPY . .
EXPOSE 3000
CMD ["npm", "start"]

    # 避免的做法：多进程
FROM ubuntu:20.04
RUN apt-get update && apt-get install -y nginx mysql-server
    # 不推荐：一个容器运行多个服务
```

#### 应用配置分离

```yaml
    # 使用ConfigMap管理配置
apiVersion: v1
kind: ConfigMap
metadata:
  name: app-config
data:
  app.properties: |
    database.url=jdbc:mysql://mysql:3306/mydb
    database.username=appuser
    database.password=apppass
    server.port=8080
    logging.level=INFO
```

### 1.2 无状态设计

#### 状态外置

```yaml
    # 使用外部存储
apiVersion: v1
kind: Pod
metadata:
  name: stateless-app
spec:
  containers:
  - name: app
    image: myapp:latest
    volumeMounts:
    - name: app-data
      mountPath: /app/data
  volumes:
  - name: app-data
    persistentVolumeClaim:
      claimName: app-data-pvc
```

#### 会话管理

```yaml
    # 使用Redis管理会话
apiVersion: v1
kind: ConfigMap
metadata:
  name: app-config
data:
  application.yml: |
    spring:
      session:
        store-type: redis
        redis:
          host: redis
          port: 6379
```

### 1.3 健康检查

#### 健康检查配置

```dockerfile
    # Dockerfile中的健康检查
FROM node:16-alpine
WORKDIR /app
COPY package*.json ./
RUN npm install
COPY . .
EXPOSE 3000
HEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \
  CMD curl -f http://localhost:3000/health || exit 1
CMD ["npm", "start"]
```

#### Kubernetes健康检查

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: healthy-app
spec:
  containers:
  - name: app
    image: myapp:latest
    ports:
    - containerPort: 8080
    livenessProbe:
      httpGet:
        path: /health
        port: 8080
      initialDelaySeconds: 30
      periodSeconds: 10
      timeoutSeconds: 5
      failureThreshold: 3
    readinessProbe:
      httpGet:
        path: /ready
        port: 8080
      initialDelaySeconds: 5
      periodSeconds: 5
      timeoutSeconds: 3
      failureThreshold: 3
```

## 2. 镜像构建最佳实践

### 2.1 多阶段构建

#### 优化镜像大小

```dockerfile
    # 多阶段构建示例
FROM maven:3.8.4-openjdk-11-slim AS builder
WORKDIR /app
COPY pom.xml .
RUN mvn dependency:go-offline
COPY src ./src
RUN mvn clean package -DskipTests

FROM openjdk:11-jre-slim
WORKDIR /app
COPY --from=builder /app/target/*.jar app.jar
RUN addgroup --system spring && adduser --system spring --ingroup spring
USER spring:spring
EXPOSE 8080
ENTRYPOINT ["java", "-jar", "app.jar"]
```

#### 构建缓存优化

```dockerfile
    # 优化构建缓存
FROM node:16-alpine AS dependencies
WORKDIR /app
COPY package*.json ./
RUN npm ci --only=production

FROM node:16-alpine AS build
WORKDIR /app
COPY package*.json ./
RUN npm ci
COPY . .
RUN npm run build

FROM node:16-alpine AS runtime
WORKDIR /app
COPY --from=dependencies /app/node_modules ./node_modules
COPY --from=build /app/dist ./dist
COPY --from=build /app/package*.json ./
EXPOSE 3000
CMD ["npm", "start"]
```

### 2.2 基础镜像选择

#### 选择合适的基础镜像

```dockerfile
    # 推荐：使用官方镜像
FROM node:16-alpine

    # 推荐：使用distroless镜像
FROM gcr.io/distroless/java:11

    # 避免：使用过大的基础镜像
FROM ubuntu:20.04  # 不推荐用于生产环境
```

#### 镜像标签管理

```bash
    # 使用语义化版本
docker build -t myapp:1.0.0 .
docker build -t myapp:latest .

    # 使用Git提交哈希
docker build -t myapp:$(git rev-parse --short HEAD) .

    # 使用构建时间戳
docker build -t myapp:$(date +%Y%m%d-%H%M%S) .
```

### 2.3 安全扫描

#### 集成安全扫描

```yaml
    # CI/CD中的安全扫描
stages:
  - build
  - security-scan
  - deploy

security-scan:
  stage: security-scan
  script:
    - docker build -t myapp:$CI_COMMIT_SHA .
    - trivy image --exit-code 1 --severity HIGH,CRITICAL myapp:$CI_COMMIT_SHA
    - docker run --rm -v /var/run/docker.sock:/var/run/docker.sock \
        aquasec/trivy:latest image --exit-code 1 --severity HIGH,CRITICAL myapp:$CI_COMMIT_SHA
```

## 3. 容器运行最佳实践

### 3.1 资源限制

#### 设置资源限制

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: resource-limited-pod
spec:
  containers:
  - name: app
    image: myapp:latest
    resources:
      requests:
        cpu: 100m
        memory: 256Mi
      limits:
        cpu: 500m
        memory: 512Mi
```

#### 资源监控

```yaml
    # 资源监控配置
apiVersion: v1
kind: ConfigMap
metadata:
  name: resource-monitor
data:
  monitor.sh: |
    #!/bin/bash
    # 监控资源使用情况
    kubectl top pods --containers
    kubectl describe pod myapp-pod
    kubectl get events --sort-by=.metadata.creationTimestamp
```

### 3.2 环境变量管理

#### 使用Secret管理敏感信息

```yaml
apiVersion: v1
kind: Secret
metadata:
  name: app-secrets
type: Opaque
data:
  database-password: cGFzc3dvcmQ=  # base64编码
  api-key: YXBpa2V5  # base64编码

---
apiVersion: v1
kind: Pod
metadata:
  name: app-with-secrets
spec:
  containers:
  - name: app
    image: myapp:latest
    env:
    - name: DATABASE_PASSWORD
      valueFrom:
        secretKeyRef:
          name: app-secrets
          key: database-password
    - name: API_KEY
      valueFrom:
        secretKeyRef:
          name: app-secrets
          key: api-key
```

#### 使用ConfigMap管理配置

```yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: app-config
data:
  app.properties: |
    server.port=8080
    logging.level=INFO
    database.url=jdbc:mysql://mysql:3306/mydb

---
apiVersion: v1
kind: Pod
metadata:
  name: app-with-config
spec:
  containers:
  - name: app
    image: myapp:latest
    env:
    - name: SPRING_PROFILES_ACTIVE
      value: "production"
    volumeMounts:
    - name: config-volume
      mountPath: /app/config
  volumes:
  - name: config-volume
    configMap:
      name: app-config
```

### 3.3 日志管理

#### 结构化日志

```python
    # Python应用结构化日志
import json
import logging
from datetime import datetime

class StructuredFormatter(logging.Formatter):
    def format(self, record):
        log_entry = {
            'timestamp': datetime.utcnow().isoformat(),
            'level': record.levelname,
            'logger': record.name,
            'message': record.getMessage(),
            'module': record.module,
            'function': record.funcName,
            'line': record.lineno
        }
        
        if record.exc_info:
            log_entry['exception'] = self.formatException(record.exc_info)
        
        return json.dumps(log_entry)

    # 配置日志
logger = logging.getLogger()
handler = logging.StreamHandler()
handler.setFormatter(StructuredFormatter())
logger.addHandler(handler)
```

#### 日志收集

```yaml
    # Fluentd日志收集配置
apiVersion: v1
kind: ConfigMap
metadata:
  name: fluentd-config
data:
  fluent.conf: |
    <source>
      @type tail
      path /var/log/containers/*.log
      pos_file /var/log/fluentd-containers.log.pos
      tag kubernetes.*
      format json
    </source>
    
    <filter kubernetes.**>
      @type kubernetes_metadata
    </filter>
    
    <match kubernetes.**>
      @type elasticsearch
      host elasticsearch.logging.svc.cluster.local
      port 9200
      index_name app-logs
    </match>
```

## 4. 安全最佳实践

### 4.1 非root用户运行

#### 创建非root用户

```dockerfile
    # 创建非root用户
FROM node:16-alpine
RUN addgroup --system --gid 1001 nodejs
RUN adduser --system --uid 1001 nextjs
WORKDIR /app
COPY --chown=nextjs:nodejs . .
USER nextjs
EXPOSE 3000
CMD ["npm", "start"]
```

#### 使用非特权容器

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: non-root-pod
spec:
  securityContext:
    runAsNonRoot: true
    runAsUser: 1000
    runAsGroup: 1000
    fsGroup: 1000
  containers:
  - name: app
    image: myapp:latest
    securityContext:
      allowPrivilegeEscalation: false
      readOnlyRootFilesystem: true
      capabilities:
        drop:
        - ALL
```

### 4.2 网络安全

#### 网络策略

```yaml
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: app-network-policy
spec:
  podSelector:
    matchLabels:
      app: myapp
  policyTypes:
  - Ingress
  - Egress
  ingress:
  - from:
    - namespaceSelector:
        matchLabels:
          name: ingress-nginx
    ports:
    - protocol: TCP
      port: 8080
  egress:
  - to:
    - namespaceSelector:
        matchLabels:
          name: database
    ports:
    - protocol: TCP
      port: 3306
```

#### 服务网格安全

```yaml
    # Istio安全策略
apiVersion: security.istio.io/v1beta1
kind: AuthorizationPolicy
metadata:
  name: app-auth-policy
spec:
  selector:
    matchLabels:
      app: myapp
  rules:
  - from:
    - source:
        principals: ["cluster.local/ns/default/sa/myapp"]
    to:
    - operation:
        methods: ["GET", "POST"]
        paths: ["/api/*"]
```

### 4.3 镜像安全

#### 镜像签名

```bash
    # 镜像签名
docker build -t myapp:latest .
docker tag myapp:latest myapp:$(date +%Y%m%d-%H%M%S)
docker push myapp:latest
docker push myapp:$(date +%Y%m%d-%H%M%S)

    # 使用Cosign签名
cosign sign --key cosign.key myapp:latest
cosign verify --key cosign.pub myapp:latest
```

#### 漏洞扫描

```yaml
    # 漏洞扫描配置
apiVersion: v1
kind: ConfigMap
metadata:
  name: vulnerability-scan
data:
  scan.sh: |
    #!/bin/bash
    # 漏洞扫描脚本
    scan_image() {
      local image=$1
      
      echo "Scanning image $image for vulnerabilities"
      
      # Trivy扫描
      trivy image --format json --output scan-results.json $image
      
      # 检查高危漏洞
      high_vulns=$(jq '.Results[].Vulnerabilities[] | select(.Severity == "HIGH")' scan-results.json | jq -s 'length')
      critical_vulns=$(jq '.Results[].Vulnerabilities[] | select(.Severity == "CRITICAL")' scan-results.json | jq -s 'length')
      
      if [ $critical_vulns -gt 0 ]; then
        echo "Found $critical_vulns critical vulnerabilities"
        exit 1
      fi
      
      if [ $high_vulns -gt 5 ]; then
        echo "Found $high_vulns high severity vulnerabilities (threshold: 5)"
        exit 1
      fi
      
      echo "Vulnerability scan passed"
    }
    
    scan_image "myapp:latest"
```

## 5. 性能优化最佳实践

### 5.1 资源优化

#### CPU优化

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: cpu-optimized-pod
spec:
  containers:
  - name: app
    image: myapp:latest
    resources:
      requests:
        cpu: 100m
      limits:
        cpu: 500m
    env:
    - name: JAVA_OPTS
      value: "-XX:+UseG1GC -XX:MaxGCPauseMillis=200"
```

#### 内存优化

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: memory-optimized-pod
spec:
  containers:
  - name: app
    image: myapp:latest
    resources:
      requests:
        memory: 256Mi
      limits:
        memory: 512Mi
    env:
    - name: JAVA_OPTS
      value: "-Xms256m -Xmx512m -XX:+UseG1GC"
```

### 5.2 缓存优化

#### 应用缓存

```yaml
    # Redis缓存配置
apiVersion: apps/v1
kind: Deployment
metadata:
  name: redis-cache
spec:
  replicas: 3
  selector:
    matchLabels:
      app: redis
  template:
    metadata:
      labels:
        app: redis
    spec:
      containers:
      - name: redis
        image: redis:7-alpine
        ports:
        - containerPort: 6379
        resources:
          requests:
            cpu: 100m
            memory: 256Mi
          limits:
            cpu: 500m
            memory: 512Mi
        command:
        - redis-server
        - --maxmemory
        - 256mb
        - --maxmemory-policy
        - allkeys-lru
```

#### 镜像缓存

```dockerfile
    # 优化镜像构建缓存
FROM node:16-alpine AS dependencies
WORKDIR /app
COPY package*.json ./
RUN npm ci --only=production && npm cache clean --force

FROM node:16-alpine AS build
WORKDIR /app
COPY package*.json ./
RUN npm ci
COPY . .
RUN npm run build

FROM node:16-alpine AS runtime
WORKDIR /app
COPY --from=dependencies /app/node_modules ./node_modules
COPY --from=build /app/dist ./dist
COPY --from=build /app/package*.json ./
EXPOSE 3000
CMD ["npm", "start"]
```

### 5.3 网络优化

#### 网络配置优化

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: network-optimized-pod
spec:
  containers:
  - name: app
    image: myapp:latest
    ports:
    - containerPort: 8080
    env:
    - name: NETWORK_OPTIMIZATIONS
      value: "true"
    - name: TCP_KEEPALIVE
      value: "true"
    - name: TCP_KEEPALIVE_TIME
      value: "600"
```

## 6. 监控运维最佳实践

### 6.1 监控配置

#### 应用监控

```yaml
    # Prometheus监控配置
apiVersion: v1
kind: ConfigMap
metadata:
  name: prometheus-config
data:
  prometheus.yml: |
    global:
      scrape_interval: 15s
    scrape_configs:
    - job_name: 'kubernetes-pods'
      kubernetes_sd_configs:
      - role: pod
      relabel_configs:
      - source_labels: [__meta_kubernetes_pod_annotation_prometheus_io_scrape]
        action: keep
        regex: true
      - source_labels: [__meta_kubernetes_pod_annotation_prometheus_io_path]
        action: replace
        target_label: __metrics_path__
        regex: (.+)
```

#### 告警配置

```yaml
    # 告警规则配置
apiVersion: v1
kind: ConfigMap
metadata:
  name: alert-rules
data:
  alerts.yml: |
    groups:
    - name: app-alerts
      rules:
      - alert: HighErrorRate
        expr: rate(http_requests_total{status=~"5.."}[5m]) > 0.1
        for: 5m
        labels:
          severity: critical
        annotations:
          summary: "High error rate detected"
          description: "Error rate is {{ $value }}"
      
      - alert: HighResponseTime
        expr: histogram_quantile(0.95, rate(http_request_duration_seconds_bucket[5m])) > 1
        for: 5m
        labels:
          severity: warning
        annotations:
          summary: "High response time detected"
          description: "95th percentile response time is {{ $value }}s"
```

### 6.2 日志管理

#### 结构化日志1

```java
// Java应用结构化日志
@RestController
public class UserController {
    
    private static final Logger logger = LoggerFactory.getLogger(UserController.class);
    
    @GetMapping("/users/{id}")
    public ResponseEntity<User> getUser(@PathVariable String id) {
        logger.info("Getting user with id: {}", id);
        
        try {
            User user = userService.getUser(id);
            logger.info("Successfully retrieved user: {}", user.getName());
            return ResponseEntity.ok(user);
        } catch (UserNotFoundException e) {
            logger.warn("User not found with id: {}", id);
            return ResponseEntity.notFound().build();
        } catch (Exception e) {
            logger.error("Error retrieving user with id: {}", id, e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();
        }
    }
}
```

#### 日志收集1

```yaml
    # Fluentd日志收集配置
apiVersion: v1
kind: ConfigMap
metadata:
  name: fluentd-config
data:
  fluent.conf: |
    <source>
      @type tail
      path /var/log/containers/*.log
      pos_file /var/log/fluentd-containers.log.pos
      tag kubernetes.*
      format json
    </source>
    
    <filter kubernetes.**>
      @type kubernetes_metadata
    </filter>
    
    <filter kubernetes.**>
      @type record_transformer
      <record>
        service_name ${record["kubernetes"]["labels"]["app"]}
        service_version ${record["kubernetes"]["labels"]["version"]}
        environment ${record["kubernetes"]["labels"]["environment"]}
      </record>
    </filter>
    
    <match kubernetes.**>
      @type elasticsearch
      host elasticsearch.logging.svc.cluster.local
      port 9200
      index_name app-logs
    </match>
```

### 6.3 自动化运维

#### 自动扩缩容

```yaml
    # HPA配置
apiVersion: autoscaling/v2
kind: HorizontalPodAutoscaler
metadata:
  name: app-hpa
spec:
  scaleTargetRef:
    apiVersion: apps/v1
    kind: Deployment
    name: myapp
  minReplicas: 3
  maxReplicas: 10
  metrics:
  - type: Resource
    resource:
      name: cpu
      target:
        type: Utilization
        averageUtilization: 70
  - type: Resource
    resource:
      name: memory
      target:
        type: Utilization
        averageUtilization: 80
```

#### 自动恢复

```yaml
    # 自动恢复配置
apiVersion: v1
kind: ConfigMap
metadata:
  name: auto-recovery
data:
  recovery.sh: |
    #!/bin/bash
    # 自动恢复脚本
    recover_service() {
      local service=$1
      echo "Attempting to recover $service"
      
      # 重启服务
      kubectl rollout restart deployment/$service
      
      # 等待服务恢复
      kubectl rollout status deployment/$service --timeout=300s
      
      if [ $? -eq 0 ]; then
        echo "$service recovered successfully"
      else
        echo "$service recovery failed"
        # 发送告警
        curl -X POST http://alertmanager:9093/api/v1/alerts \
          -d "[{\"labels\":{\"alertname\":\"ServiceRecoveryFailed\",\"service\":\"$service\"}}]"
      fi
    }
    
    # 恢复所有服务
    recover_service "myapp"
```

## 7. 网络存储最佳实践

### 7.1 网络配置

#### 服务发现

```yaml
    # 服务配置
apiVersion: v1
kind: Service
metadata:
  name: myapp-service
spec:
  selector:
    app: myapp
  ports:
  - port: 80
    targetPort: 8080
  type: ClusterIP

---
    # Ingress配置
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: myapp-ingress
  annotations:
    nginx.ingress.kubernetes.io/rewrite-target: /
spec:
  rules:
  - host: myapp.example.com
    http:
      paths:
      - path: /
        pathType: Prefix
        backend:
          service:
            name: myapp-service
            port:
              number: 80
```

#### 负载均衡

```yaml
    # 负载均衡配置
apiVersion: v1
kind: Service
metadata:
  name: myapp-lb
spec:
  selector:
    app: myapp
  ports:
  - port: 80
    targetPort: 8080
  type: LoadBalancer
  loadBalancerSourceRanges:
  - 10.0.0.0/8
  - 172.16.0.0/12
  - 192.168.0.0/16
```

### 7.2 存储配置

#### 持久化存储

```yaml
    # PVC配置
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: app-data-pvc
spec:
  accessModes:
  - ReadWriteOnce
  resources:
    requests:
      storage: 10Gi
  storageClassName: fast-ssd

---
    # Pod使用PVC
apiVersion: v1
kind: Pod
metadata:
  name: app-with-storage
spec:
  containers:
  - name: app
    image: myapp:latest
    volumeMounts:
    - name: app-data
      mountPath: /app/data
  volumes:
  - name: app-data
    persistentVolumeClaim:
      claimName: app-data-pvc
```

#### 存储类配置

```yaml
    # 存储类配置
apiVersion: storage.k8s.io/v1
kind: StorageClass
metadata:
  name: fast-ssd
provisioner: kubernetes.io/aws-ebs
parameters:
  type: gp3
  iops: "3000"
  throughput: "125"
  fsType: ext4
reclaimPolicy: Retain
allowVolumeExpansion: true
```

## 8. 编排管理最佳实践

### 8.1 部署策略

#### 滚动更新

```yaml
    # 滚动更新配置
apiVersion: apps/v1
kind: Deployment
metadata:
  name: myapp
spec:
  replicas: 5
  strategy:
    type: RollingUpdate
    rollingUpdate:
      maxUnavailable: 1
      maxSurge: 1
  selector:
    matchLabels:
      app: myapp
  template:
    metadata:
      labels:
        app: myapp
    spec:
      containers:
      - name: myapp
        image: myapp:latest
        ports:
        - containerPort: 8080
```

#### 蓝绿部署

```yaml
    # 蓝绿部署配置
apiVersion: argoproj.io/v1alpha1
kind: Rollout
metadata:
  name: myapp-rollout
spec:
  replicas: 5
  strategy:
    blueGreen:
      activeService: myapp-active
      previewService: myapp-preview
      autoPromotionEnabled: false
      scaleDownDelaySeconds: 30
  selector:
    matchLabels:
      app: myapp
  template:
    metadata:
      labels:
        app: myapp
    spec:
      containers:
      - name: myapp
        image: myapp:latest
        ports:
        - containerPort: 8080
```

### 8.2 配置管理

#### 配置热更新

```yaml
    # ConfigMap配置
apiVersion: v1
kind: ConfigMap
metadata:
  name: app-config
data:
  app.properties: |
    server.port=8080
    logging.level=INFO
    database.url=jdbc:mysql://mysql:3306/mydb

---
    # 使用ConfigMap
apiVersion: v1
kind: Pod
metadata:
  name: app-with-config
spec:
  containers:
  - name: app
    image: myapp:latest
    volumeMounts:
    - name: config-volume
      mountPath: /app/config
  volumes:
  - name: config-volume
    configMap:
      name: app-config
```

#### 环境变量管理

```yaml
    # 环境变量配置
apiVersion: v1
kind: Pod
metadata:
  name: app-with-env
spec:
  containers:
  - name: app
    image: myapp:latest
    env:
    - name: ENVIRONMENT
      value: "production"
    - name: LOG_LEVEL
      value: "INFO"
    - name: DATABASE_URL
      valueFrom:
        configMapKeyRef:
          name: app-config
          key: database.url
    - name: DATABASE_PASSWORD
      valueFrom:
        secretKeyRef:
          name: app-secrets
          key: database-password
```

## 9. 故障处理最佳实践

### 9.1 故障检测

#### 健康检查

```yaml
    # 健康检查配置
apiVersion: v1
kind: Pod
metadata:
  name: healthy-app
spec:
  containers:
  - name: app
    image: myapp:latest
    ports:
    - containerPort: 8080
    livenessProbe:
      httpGet:
        path: /health
        port: 8080
      initialDelaySeconds: 30
      periodSeconds: 10
      timeoutSeconds: 5
      failureThreshold: 3
    readinessProbe:
      httpGet:
        path: /ready
        port: 8080
      initialDelaySeconds: 5
      periodSeconds: 5
      timeoutSeconds: 3
      failureThreshold: 3
```

#### 故障监控

```yaml
    # 故障监控配置
apiVersion: v1
kind: ConfigMap
metadata:
  name: fault-monitor
data:
  monitor.sh: |
    #!/bin/bash
    # 故障监控脚本
    monitor_service() {
      local service=$1
      local endpoint=$2
      
      echo "Monitoring $service at $endpoint"
      
      # 检查服务健康状态
      if ! curl -f "$endpoint/health" > /dev/null 2>&1; then
        echo "Service $service is unhealthy"
        return 1
      fi
      
      # 检查响应时间
      response_time=$(curl -o /dev/null -s -w '%{time_total}' $endpoint)
      if (( $(echo "$response_time > 5.0" | bc -l) )); then
        echo "Service $service has high response time: ${response_time}s"
        return 1
      fi
      
      echo "Service $service is healthy"
      return 0
    }
    
    monitor_service "myapp" "http://myapp:8080"
```

### 9.2 故障恢复

#### 自动恢复1

```yaml
    # 自动恢复配置
apiVersion: v1
kind: ConfigMap
metadata:
  name: auto-recovery
data:
  recovery.sh: |
    #!/bin/bash
    # 自动恢复脚本
    recover_service() {
      local service=$1
      echo "Attempting to recover $service"
      
      # 重启服务
      kubectl rollout restart deployment/$service
      
      # 等待服务恢复
      kubectl rollout status deployment/$service --timeout=300s
      
      if [ $? -eq 0 ]; then
        echo "$service recovered successfully"
      else
        echo "$service recovery failed"
        # 发送告警
        curl -X POST http://alertmanager:9093/api/v1/alerts \
          -d "[{\"labels\":{\"alertname\":\"ServiceRecoveryFailed\",\"service\":\"$service\"}}]"
      fi
    }
    
    # 恢复所有服务
    recover_service "myapp"
```

#### 故障转移

```yaml
    # 故障转移配置
apiVersion: v1
kind: Service
metadata:
  name: myapp-failover
spec:
  selector:
    app: myapp
  ports:
  - port: 80
    targetPort: 8080
  type: ClusterIP

---
apiVersion: v1
kind: Service
metadata:
  name: myapp-backup
spec:
  selector:
    app: myapp-backup
  ports:
  - port: 80
    targetPort: 8080
  type: ClusterIP
```

### 9.3 故障分析

#### 日志分析

```bash
    # 日志分析脚本
#!/bin/bash
analyze_logs() {
    local service=$1
    local time_range=$2
    
    echo "Analyzing logs for $service in the last $time_range"
    
    # 获取错误日志
    kubectl logs -l app=$service --since=$time_range | grep -i error | head -20
    
    # 获取警告日志
    kubectl logs -l app=$service --since=$time_range | grep -i warn | head -20
    
    # 统计日志级别
    kubectl logs -l app=$service --since=$time_range | grep -o '\[ERROR\]\|[WARN\]\|[INFO\]' | sort | uniq -c
}

analyze_logs "myapp" "1h"
```

#### 性能分析

```bash
    # 性能分析脚本
#!/bin/bash
analyze_performance() {
    local service=$1
    
    echo "Analyzing performance for $service"
    
    # 获取资源使用情况
    kubectl top pods -l app=$service
    
    # 获取Pod状态
    kubectl get pods -l app=$service -o wide
    
    # 获取事件
    kubectl get events --field-selector involvedObject.name=$(kubectl get pods -l app=$service -o jsonpath='{.items[0].metadata.name}')
}

analyze_performance "myapp"
```

## 10. 团队协作最佳实践

### 10.1 开发流程

#### 代码审查

```yaml
    # 代码审查配置
apiVersion: v1
kind: ConfigMap
metadata:
  name: code-review
data:
  review.sh: |
    #!/bin/bash
    # 代码审查脚本
    review_code() {
      local pr_number=$1
      
      echo "Reviewing PR #$pr_number"
      
      # 检查代码质量
      sonar-scanner -Dsonar.pullrequest.key=$pr_number
      
      # 运行测试
      mvn test
      
      # 安全检查
      npm audit
      
      # 依赖检查
      snyk test
    }
    
    review_code $1
```

#### 持续集成

```yaml
    # CI配置
stages:
  - build
  - test
  - security-scan
  - deploy

build:
  stage: build
  script:
    - mvn clean package -DskipTests
  artifacts:
    paths:
      - target/*.jar

test:
  stage: test
  script:
    - mvn test
  artifacts:
    reports:
      junit: target/surefire-reports/*.xml

security-scan:
  stage: security-scan
  script:
    - sonar-scanner
    - npm audit
    - snyk test

deploy:
  stage: deploy
  script:
    - docker build -t myapp:$CI_COMMIT_SHA .
    - docker push myapp:$CI_COMMIT_SHA
    - kubectl set image deployment/myapp myapp=myapp:$CI_COMMIT_SHA
```

### 10.2 文档管理

#### API文档

```yaml
    # API文档配置
apiVersion: v1
kind: ConfigMap
metadata:
  name: api-docs
data:
  swagger.yaml: |
    openapi: 3.0.0
    info:
      title: MyApp API
      version: 1.0.0
      description: MyApp API Documentation
    servers:
    - url: http://myapp:8080
      description: Development server
    paths:
      /users:
        get:
          summary: Get all users
          responses:
            '200':
              description: Successful response
              content:
                application/json:
                  schema:
                    type: array
                    items:
                      $ref: '#/components/schemas/User'
    components:
      schemas:
        User:
          type: object
          properties:
            id:
              type: integer
            name:
              type: string
            email:
              type: string
```

#### 运维文档

```markdown
    # 运维文档模板

## 服务概述
- 服务名称：myapp
- 服务版本：1.0.0
- 部署环境：production

## 部署信息
- 镜像：myapp:1.0.0
- 副本数：3
- 资源限制：CPU 500m, Memory 512Mi

## 监控配置
- 健康检查：/health
- 就绪检查：/ready
- 指标端点：/metrics

## 故障处理
- 自动重启：是
- 故障转移：是
- 告警通知：Slack #alerts

## 联系方式
- 开发团队：dev-team@company.com
- 运维团队：ops-team@company.com
```

### 10.3 知识分享

#### 技术分享

```yaml
    # 技术分享配置
apiVersion: v1
kind: ConfigMap
metadata:
  name: tech-sharing
data:
  sharing.md: |
    # 容器技术分享
    
    ## 分享主题
    - 容器化最佳实践
    - Kubernetes运维经验
    - 微服务架构设计
    
    ## 分享内容
    1. 容器设计原则
    2. 镜像构建优化
    3. 安全最佳实践
    4. 性能优化技巧
    5. 故障处理经验
    
    ## 分享时间
    - 每周五下午2点
    - 会议室：A101
    
    ## 参与人员
    - 开发团队
    - 运维团队
    - 测试团队
```

#### 经验总结

```yaml
    # 经验总结配置
apiVersion: v1
kind: ConfigMap
metadata:
  name: experience-summary
data:
  summary.md: |
    # 容器化经验总结
    
    ## 成功经验
    1. 渐进式迁移策略
    2. 自动化优先原则
    3. 完善的监控体系
    4. 团队协作机制
    
    ## 挑战与解决方案
    1. 服务拆分：合理划分服务边界
    2. 数据一致性：使用分布式事务
    3. 性能优化：持续优化和监控
    4. 故障处理：建立完善流程
    
    ## 最佳实践
    1. 容器设计：单一职责原则
    2. 镜像构建：多阶段构建
    3. 安全实践：非root用户运行
    4. 监控运维：全面监控告警
    
    ## 未来规划
    1. 服务网格：引入Istio
    2. 云原生：向云原生演进
    3. AI运维：智能化运维
    4. 边缘计算：支持边缘场景
```
